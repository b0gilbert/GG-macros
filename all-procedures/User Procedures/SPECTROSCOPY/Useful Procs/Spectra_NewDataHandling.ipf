#pragma TextEncoding = "UTF-8"#pragma rtGlobals=1		// Use modern global access method.//	+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++////				THIS IS NOW THE MAIN ROUTINE FOR CREATING A NEW LOAD FOLDER FOR WAVES IN MEMORY////	+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++// ***************************************************************************// **************** 		Incorporate any data-axis pair into a proper loaded data// ***************************************************************************Function AdoptLocalAxisAndData(Axis,Data)	Wave Axis, Data		String cmd, AxisName, DataName, DataFolderName = ":"	cmd = "AdoptAxisAndDataFromMemory(\""+NameOfWave(Axis)+"\",\"null\",\""+DataFolderName+"\",\""+NameOfWave(Data)+"\",\"null\",\""+DataFolderName+"\",\""+NameOfWave(Data)+"\",\"\",0,0)"	Execute cmdEnd// Simplest just to require that the folder be given explicitly, not as "" if we're in the folder already. Function /T AdoptAxisAndDataFromMemory(AxisName,AxisErrorsName,AxisFolder,DataName,DataErrorsName,DataFolder,NewDataName,CopySuffix,UserNameFlag,SortFlag,StripNaNsFlag)	String AxisName, AxisErrorsName, AxisFolder, DataName, DataErrorsName, DataFolder, NewDataName, CopySuffix	Variable UserNameFlag, SortFlag, StripNaNsFlag		Wave/T wDataList			= root:SPECTRA:wDataList	Wave wDataSelection		= root:SPECTRA:wDataSel	Wave wDataGroup			= root:SPECTRA:wDataGroup		if (strlen(AxisFolder) == 0)		WAVE Axis_IN 		= $(AxisName)		WAVE AxisErrors 	= $(AxisErrorsName)	else		WAVE Axis_IN 		= $(CheckFolderColon(AxisFolder)+AxisName)		WAVE AxisErrors 	= $(CheckFolderColon(AxisFolder)+AxisErrorsName)	endif	if (strlen(DataFolder) == 0)		WAVE Data_IN 		= $(DataName)		WAVE DataErrors 	= $(DataErrorsName)	else		WAVE Data_IN 		= $(CheckFolderColon(DataFolder)+DataName)		WAVE DataErrors 	= $(CheckFolderColon(DataFolder)+DataErrorsName)	endif		if (WaveExists(Data_IN) == 0)		return ""	else		WaveStats /Q/M=1 Data_IN		if (V_numNans == DimSize(Data,0))			return ""		endif	endif		// 2021-12 Remove any wave scaling which causes problems with data fitting routines	Duplicate /FREE Data_IN, Data	Duplicate /FREE Axis_IN, Axis	SetScale /P x, 0, 1, Data, Axis		// Check if there is a DataNote. The original Data Filename is expected to be in the first line. 	String DataNote, DataFileName	DataNote 				= Note(Data)	if (strlen(DataNote) > 0)		DataFileName 	= ReturnTextBeforeNthChar(DataNote,"\r",1)	else		DataFileName 	= "" 	endif		DisplayPlottingPanel()		Variable NDataPts		if (WaveExists(Axis) == 1)//		if (!CheckMonotonic(Axis))//			Print " *** ",NameOfWave(Axis),"is not monotonic!. Aborting data load"//			return ""//		endif		if (numpnts(Axis) < numpnts(Data))			Print " *** ",NameOfWave(Axis),"has",numpnts(Axis),"points and",NameOfWave(Data),"has",numpnts(Data),"points! Truncating the data wave. "		elseif (numpnts(Axis) > numpnts(Data))			Print " *** ",NameOfWave(Axis),"has",numpnts(Axis),"points and",NameOfWave(Data),"has",numpnts(Data),"points! Truncating the axis wave. "		endif		NDataPts = min(numpnts(Axis),numpnts(Data))	else		NDataPts = numpnts(Data)	endif		// ******* NUMBERING THE LOAD FOLDERS *******	Variable NextLoadFolder 	= NextLoadFolderNumber()	// *************************************		String NewAxisName, NewAxisErrorsName, NewDataErrorsName, FitName, NewFitName, NewResName, BGName, NewBGName	String GpFolderName = "Load" + num2str(NextLoadFolder)	String FullFolderPath = "root:SPECTRA:Data:" + GpFolderName, OrigFolderPath = FullFolderPath+":Originals"	String SortingList		NewDataName = GetSampleName(NewDataName,"",CopySuffix,0,UserNameFlag,1) + "_data"	if ((cmpstr("_data",NewDataName) == 0) || (cmpstr("_quit!__data",NewDataName) == 0))		return ""	endif		// 	The input AXIS	NewAxisName 			= AnyNameFromDataName(NewDataName,"axis")	if (WaveExists(Axis) == 0)		Print " *** Making a separate axis for adopted data, using wave scaling. "		Duplicate /O/D Data, $(CheckFolderColon(DataFolder) + NewAxisName)		WAVE Axis = $(CheckFolderColon(DataFolder) + NewAxisName)		Axis = pnt2x(Data,p)	endif		NewAxisErrorsName 	= AnyNameFromDataName(NewDataName,"axis_sig")	NewDataErrorsName 	= AnyNameFromDataName(NewDataName,"data_sig")		String OldDF = getDataFolder(1)	NewDataFolder/O/S $(FullFolderPath)				// The adopted AXIS		SortingList 	= ParseFilePath(2,FullFolderPath,":",0,0) + NewAxisName + ";"		Duplicate /O/D Axis, $NewAxisName		Redimension /N=(NDataPts) $NewAxisName				if (WaveExists(AxisErrors) == 1)			// The (optional) adopted axis ERRORS			SortingList 	+= ParseFilePath(2,FullFolderPath,":",0,0) + NewAxisErrorsName + ";"			Duplicate /O/D AxisErrors, $NewAxisErrorsName			Redimension /N=(NDataPts) $NewAxisErrorsName		endif				// The adopted DATA		SortingList 	+= ParseFilePath(2,FullFolderPath,":",0,0) + NewDataName + ";"		Duplicate /O/D Data, $NewDataName		Redimension /N=(NDataPts) $NewDataName				if (WaveExists(DataErrors) == 1)			// The (optional) adopted data ERRORS			SortingList 	+= ParseFilePath(2,FullFolderPath,":",0,0) + NewDataErrorsName + ";"			Duplicate /O/D DataErrors, $NewDataErrorsName			Redimension /N=(NDataPts) $NewDataErrorsName		endif				if(StripNaNsFlag == 1)			StripNANsFromAxisDataErrors($NewAxisName,$NewAxisErrorsName,$NewDataName,$NewDataErrorsName)		endif				// Look to see if there is a FIT result wave. 		FitName 		= AnyNameFromDataName(DataName,"fit")		WAVE Fit 		= $(CheckFolderColon(DataFolder)+FitName)		if (WaveExists(Fit) == 1)			NewFitName 	= AnyNameFromDataName(NewDataName,"fit")			SortingList 	+= ParseFilePath(2,FullFolderPath,":",0,0) + NewFitName + ";"			Duplicate /O/D Fit, $NewFitName			Redimension /N=(NDataPts) $NewFitName						// Now create the residuals			Duplicate /O/D Fit, Resids			Resids = Data - Fit 						NewResName 	= AnyNameFromDataName(NewDataName,"res")			SortingList 	+= ParseFilePath(2,FullFolderPath,":",0,0) + NewResName + ";"			Duplicate /O/D Resids, $NewResName			Redimension /N=(NDataPts) $NewResName						// If there's a BACKGROUND wave, duplicate that too			BGName 		= AnyNameFromDataName(DataName,"bg")			WAVE BG 		= $(CheckFolderColon(DataFolder)+BGName)			if (WaveExists(BG) == 1)				NewBGName 	= AnyNameFromDataName(NewDataName,"bg")				SortingList 	+= ParseFilePath(2,FullFolderPath,":",0,0) + NewBGName + ";"				Duplicate /O/D BG, $NewBGName				Redimension /N=(NDataPts) $NewBGName			endif		endif				NewDataFolder /O Originals		DuplicateAllWavesInDataFolder(FullFolderPath,OrigFolderPath,ReplaceString("_data",NewDataName,"")+"*",0)			SetDataFolder $(OldDF)		if (SortFlag == 1)		SortWavesFromList(SortingList,0)	endif		Variable NumLoaded = numpnts(wDataList)	ReDimension /N=(NumLoaded+1) wDataList		wDataList[NumLoaded] 	= NewDataName		ReDimension /N=(NumLoaded+1) wDataSelection, wDataGroup		wDataSelection[NumLoaded]	= 0//		wDataGroup[NumLoaded] 		= NumberOfLoadFolders		wDataGroup[NumLoaded] 		= NextLoadFolder//		wDataGroup[NumLoaded] 		= gNumGroupsLoaded			return ParseFilePath(2,FullFolderPath,":",0,0) + NewDataNameEnd//	+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++////						THE FOLLOWING ROUTINES OPERATE ON LOADED DATA via wDataList////	+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++Function FindSelectedData(DataSel)	Wave DataSel		FindValue /V=1 DataSel	return V_valueEndFunction /T ListOfLoadedSpectra([NPnts])	Variable NPnts		WAVE /T wDataList 	= root:SPECTRA:wDataList	WAVE wDataGroup 	= root:SPECTRA:wDataGroup		Variable i	String SpectraList = ""		if (ParamIsDefault(NPnts))		SpectraList 	=  ReplaceString("_data",TextWaveToList(wDataList,-1,"",""),"")	else			for (i=0;i<numpnts(wDataList);i+=1)			WAVE Data = $("root:SPECTRA:Data:Load" + num2str(wDataGroup[i]) + ":" + wDataList[i])						if (numpnts(Data) == NPnts)				SpectraList = SpectraList + ";"			endif		endfor	endif		return SpectraListEnd// Make a partial copy of the loaded data listFunction SelectedDataList(SelectAll,MakeFitWaves,DataListName,DataListFolder,DataType)	Variable SelectAll, MakeFitWaves	String DataListName, DataListFolder, DataType	WAVE /T DataList 	= root:SPECTRA:wDataList	WAVE DataSel 	 	= root:SPECTRA:wDataSel	WAVE DataGroup 	= root:SPECTRA:wDataGroup		Variable i, n=0, Selected	String DataName, FitName, ResName, TypeOfData		Make /N=0/O/T $(ParseFilePath(2,DataListFolder,":",0,0) + DataListName+"List") /WAVE=NewDataList	Make /N=0/O $(ParseFilePath(2,DataListFolder,":",0,0) + DataListName+"Sel") /WAVE=NewDataSel	Make /N=0/O $(ParseFilePath(2,DataListFolder,":",0,0) + DataListName+"Group") /WAVE=NewDataGroup		for (i=0;i<numpnts(DataSel);i+=1)		if (SelectAll == 1)					// Select all. 			Selected = 1		elseif ((DataSel[i] & 2^0) != 0)	// Bit 0 is set: Normal selection. 			Selected = 1		elseif  ((DataSel[i] & 2^3) != 0)	// Bit 3 is set: Shift-selection			Selected = 1		else			Selected = 0		endif				// (optionally) check the data wave is of the correct type		if (strlen(DataType)>0)			DataName 	= "root:SPECTRA:Data:Load"+num2str(DataGroup[i])+":"+DataList[i]			WAVE Data 	= $DataName			TypeOfData = StringByKey("DataType", note(Data), "=")			if (cmpstr(TypeOfData,DataType) != 0)				Selected = 0			endif		endif				if (Selected)			n += 1			Redimension /N=(n) NewDataList, NewDataSel, NewDataGroup			NewDataList[n] 		= DataList[i]			NewDataSel[n] 		= DataSel[i]			NewDataGroup[n] 	= DataGroup[i]						if (MakeFitWaves)				DataName 	= "root:SPECTRA:Data:Load"+num2str(DataGroup[i])+":"+DataList[i]				FitName 		= "root:SPECTRA:Data:Load"+num2str(DataGroup[i])+":"+ReplaceString("_data",DataList[i],"_fit")				ResName 		= "root:SPECTRA:Data:Load"+num2str(DataGroup[i])+":"+ReplaceString("_data",DataList[i],"_res")								if (!WaveExists($FitName) || !WaveExists($ResName))					Duplicate /O/D $DataName, $ResName, $FitName					if (BitTest(WaveType($DataName),0))						WAVE /C FitC = $FitName						WAVE /C ResC = $ResName						FitC = cmplx(NaN,NaN)						ResC = cmplx(NaN,NaN)					else						WAVE Fit = $FitName						WAVE Res = $ResName						Fit = NaN						Res = NaN					endif				endif							endif		endif	endfor		return nEnd// ***************************************************************************// **************** 				DATA DELETION ROUTINES// ***************************************************************************Function DeleteAllData()		WAVE wDataSel 	 			= root:SPECTRA:wDataSel	String OldDF = getDataFolder(1)	SetDataFolder root:SPECTRA		DoWindow /K SpectraPlotPanel		KillPlotsPanelsAndTables("Graph*","plots")		KillPlotsPanelsAndTables("Table*","tables")		KillPlotsPanelsAndTables("Panel*","panels")				Make /T/O/N=0 wDataList		Make /O/N=0 wDataSel, wDataGroup			KillMatchingDataFolders("root:SPECTRA:Data","Load")		KillMatchingDataFolders("root:SPECTRA:Plotting","Graph")				Print " *** DELETING ALL DATA FROM EXPERIMENT"	SetDataFolderOrRoot(OldDf)EndFunction DeleteSelectedData(DataList, DataSel, DataGroup)	Wave DataSel, DataGroup	Wave /T DataList		WAVE /T wDataList 			= root:SPECTRA:wDataList	WAVE wDataSel 	 			= root:SPECTRA:wDataSel	WAVE wDataGroup 			= root:SPECTRA:wDataGroup		String DelFolderName	Variable i=0, bit0,bit3		do		if (((DataSel[i]&2^0) != 0) || ((DataSel[i]&2^3) != 0))			DeleteSingleDataOrGroup(i,0)		else			i+=1		endif	while(i<numpnts(DataSel))	if (numpnts(wDataSel) > 0)		ListBox DataListBox, selRow= 0		PlotDataInViewer()	else		DoWindow /K SpectraPlotPanel	endif		DataSel[0]=1EndFunction DeleteSingleDataOrGroup(DataNum,DeleteGroupFlag)	Variable DataNum, DeleteGroupFlag		WAVE /T wDataList 			= root:SPECTRA:wDataList	WAVE wDataSel 	 			= root:SPECTRA:wDataSel	WAVE wDataGroup 			= root:SPECTRA:wDataGroup		String DeleteDataList, DeleteTextList, DeleteTwoDList, FolderNonAxisList		// Need to explicitly delete ALL the interior folders that may have been created. 	String SampleName 		= SampleNameFromDataName(wDataList[DataNum])	String DelFolderName 	= ReturnDataLoadFolder(DataNum)	String OrigFolderList 	= DelFolderName+":Originals;"	String TwoDFolderList 	= DelFolderName+":TwoD;"	String FoilFolderList 		= DelFolderName+":Foil;"	String PreEdgeFolderList = DelFolderName+":XANESPreEdge;"		if (DeleteGroupFlag == 2)		DeleteDataList = FolderWaveList(DelFolderName,"!*_axis",";","",-1,0)		DeleteTextList = FolderWaveList(DelFolderName,"!*_axis",";","",-1,0)	else		DeleteDataList = FolderWaveList(DelFolderName,SampleName+"*",";","",-1,0) 	// Numeric waves		DeleteTextList = FolderWaveList(DelFolderName,SampleName+"*",";","",-1,1)	// Text waves		DeleteTwoDList = FolderWaveList(DelFolderName+":TwoD",SampleName+"*",";","",-1,0)	// Numeric waves	endif		KillWavesInFolderFromList(DelFolderName+":TwoD",DeleteTwoDList)	KillWavesInFolderFromList(DelFolderName,DeleteDataList)	KillWavesInFolderFromList(DeleteTextList,DeleteDataList)		// These don't make any sense because it does not look up the names of the waves in the specific folders! 	KillWavesInFolderFromList(OrigFolderList,DeleteDataList)	KillWavesInFolderFromList(FoilFolderList,DeleteDataList)	KillWavesInFolderFromList(PreEdgeFolderList,DeleteDataList)		// Not sure where this was created ... 	KillWaves /Z $(DelFolderName+":Resids")	// List remaning data in the folder	FolderNonAxisList = FolderWaveList(DelFolderName,"!*_axis",";","",-1,0)		// Delete the entire folder if requested, or if there are no more data in it. 	if ((DeleteGroupFlag == 1) || (ItemsInList(FolderNonAxisList) == 0))		KillWaves /A/Z		KillDataFolder /Z $(DelFolderName)	endif		DeletePoints (DataNum), 1, wDataList, wDataGroup, wDataSelEnd// ***************************************************************************// **************** 				Duplicate Loaded Data// ***************************************************************************// *!*! 2025-09 Debug to (1) delete original waves and (2) transfer components Function DuplicateSelectedData(DataList, DataSel, DataGroup, CopySuffix,Cmpx2RealFlag)	Wave DataSel, DataGroup	Wave /T DataList	String CopySuffix	Variable Cmpx2RealFlag			Variable i	String AxisName, AxisAndFolderName, DataName, DataFolderName, DataAndFolderName, FolderStem = "root:SPECTRA:Data:Load"	String SampleName,NewSampleName, NewAxisName, NewDataName, NewDataAndFolder, NewFolder, NewName, NewSuffix		for (i=0;i<numpnts(DataSel);i+=1)		if (((DataSel[i]&2^0) != 0) || ((DataSel[i]&2^3) != 0))			DataName				= DataList[i]			SampleName 			= SampleNameFromDataName(DataName)			DataFolderName		= FolderStem + num2str(DataGroup[i])			DataAndFolderName	= DataFolderName + ":" + DataName			AxisName 				= AxisNameFromDataName(DataName)			AxisAndFolderName	= AxisNameFromDataName(DataAndFolderName)						// Autoname the new data, and look for errors//			NewDataAndFolder 	= AdoptAxisAndDataFromMemory(AxisName,AxisName+"_sig",DataFolderName,DataName,DataName+"_sig",DataFolderName,DataName,CopySuffix,0,0,1)			// do not strip NaNs! 						// 			if (Cmpx2RealFlag && (WaveType($DataAndFolderName) & 0x01))				WAVE CData = $DataAndFolderName				Duplicate /O $AxisAndFolderName, root:RealData /WAVE=RealData				Duplicate /O $AxisAndFolderName, root:ImagData /WAVE=ImagData				RealData = real(CData)				NewSuffix = CopySuffix+"r"				NewDataAndFolder 	= AdoptAxisAndDataFromMemory(AxisName,AxisName+"_sig",DataFolderName,"RealData",DataName+"_sig","root",DataName,NewSuffix,0,0,0)				ImagData = imag(CData)				NewSuffix = CopySuffix+"i"				NewDataAndFolder 	= AdoptAxisAndDataFromMemory(AxisName,AxisName+"_sig",DataFolderName,"ImagData",DataName+"_sig","root",DataName,NewSuffix,0,0,0)						else				// AdoptAxisAndData is needed to create the destination datafolder. 				NewDataAndFolder 	= AdoptAxisAndDataFromMemory(AxisName,AxisName+"_sig",DataFolderName,DataName,DataName+"_sig",DataFolderName,DataName,CopySuffix,0,0,0)				NewFolder 			= ParseFilePath(1,NewDataAndFolder,":",1,0)				NewName 				= ParseFilePath(0,NewDataAndFolder,":",1,0)				//Take care of additional waves				DuplicateAssociatedWaves(SampleName,CopySuffix,DataFolderName,NewFolder)//				DuplicateAllWavesInDataFolder(DataFolderName+":",NewFolder,"*",0)				//				String AdditionalWaveList 	= ListOfObjectsInFolder(1,FolderName,"", "")//				Variable j, NWaves = ItemsInList(AdditionalWaveList)//				for (j=0;j<NWaves;j+=1)//					String AddWaveName = StringFromList(j,AdditionalWaveList)//					if (strlen(ListMatch(AddWaveName,EditList)) == 0)//						EditList 	= EditList + FolderName + AddWaveName + ";"//					endif//				endfor												// Take care of any 2D data				DuplicateAllWavesInDataFolder(DataFolderName+":TwoD",NewFolder+"TwoD","*",0)				RenameAxisDataAndErrors(NewFolder+"TwoD:",ReplaceString("_data",DataName,""),ReplaceString("_data",NewName,""))				DuplicateAllWavesInDataFolder(NewFolder+"TwoD",NewFolder+"Originals","*_2D",0)			endif		endif	endfor	SetDataFolder root:	KillWaves /Z RealData, ImagDataEndFunction DuplicateAssociatedWaves(SampleName,Suffix,Df1,Df2)	String SampleName, Suffix, Df1, Df2		Variable i, NPnts, NWaves	String ListOfWaves, OrigName, CopyName		ListOfWaves = FolderWaveList(Df1,SampleName+"*",";","",-1,0)	ListOfWaves = ExclusiveWaveList(ExclusiveWaveList(ListOfWaves,"_data",";"),"_axis",";")	ListOfWaves = ExclusiveWaveList(ExclusiveWaveList(ListOfWaves,"_bg",";"),"_fit",";")	ListOfWaves = ExclusiveWaveList(ListOfWaves,"_res",";")		NWaves 		= ItemsInList(ListOfWaves)		for (i=0;i<NWaves;i+=1)		OrigName 		= StringFromList(i,ListOfWaves)		WAVE Orig 	= $(Df1+":"+OrigName)		NPnts 		= DimSize(Orig,0)		CopyName 		= ReplaceString(SampleName,OrigName,SampleName+"_"+Suffix)		Make /O/D/N=(NPnts) $(Df2+CopyName) /WAVE=Copy				Copy = Orig	endforEnd // ***************************************************************************// **************** 				Renaming Loaded Data// ***************************************************************************Function RenameSelectedData(DataList, DataSel, DataGroup)	Wave DataSel, DataGroup	Wave /T DataList		Variable i	String FolderStem, CopyFolderStem, DataName, NewDataName, SampleName,NewSampleName		for (i=0;i<numpnts(DataSel);i+=1)		if (((DataSel[i]&2^0) != 0) || ((DataSel[i]&2^3) != 0))			FolderStem 			= "root:SPECTRA:Data:Load" + num2str(DataGroup[i])  + ":"			DataName				= DataList[i]						SampleName 		= ReplaceString("_data",DataName,"")			NewSampleName	= GetSampleName(SampleName,"","",0,1,1)			if (cmpstr("_quit!_",NewSampleName)==0)				return -1			endif						if (cmpstr(SampleName,NewSampleName,1) != 0)				NewDataName 	= NewSampleName + "_data"				DataList[i]	= NewDataName								RenameAxisDataAndErrors(FolderStem,SampleName,NewSampleName)								CopyFolderStem 			= "root:SPECTRA:Data:Load" + num2str(DataGroup[i])  + ":Originals:"				RenameAxisDataAndErrors(CopyFolderStem,SampleName,NewSampleName)								CopyFolderStem 			= "root:SPECTRA:Data:Load" + num2str(DataGroup[i])  + ":TwoD:"				RenameAxisDataAndErrors(CopyFolderStem,SampleName,NewSampleName)			endif					endif	endfor	SetDataFolder root:EndFunction RenameAxisDataAndErrors(FolderStem,SampleName,NewSampleName)	String FolderStem,SampleName,NewSampleName		RenameSingleDataWave(FolderStem,SampleName,NewSampleName,"_axis")	RenameSingleDataWave(FolderStem,SampleName,NewSampleName,"_data")	RenameSingleDataWave(FolderStem,SampleName,NewSampleName,"_axis_sig")	RenameSingleDataWave(FolderStem,SampleName,NewSampleName,"_data_sig")		RenameSingleDataWave(FolderStem,SampleName,NewSampleName,"_res")	RenameSingleDataWave(FolderStem,SampleName,NewSampleName,"_fit")		RenameSingleDataWave(FolderStem,SampleName,NewSampleName,"_info")		RenameSingleDataWave(FolderStem,SampleName,NewSampleName,"_axis2")	RenameSingleDataWave(FolderStem,SampleName,NewSampleName,"_2Dx")	RenameSingleDataWave(FolderStem,SampleName,NewSampleName,"_2Dy")	RenameSingleDataWave(FolderStem,SampleName,NewSampleName,"_2D")	EndFunction RenameSingleDataWave(FolderStem,SampleName,NewSampleName,suffix)	String FolderStem,SampleName,NewSampleName,suffix		String FullDataName, NewDataName		FullDataName 		= FolderStem + SampleName + suffix	NewDataName 		= NewSampleName + suffix		if (WaveExists($FullDataName) == 1)		Rename $(FullDataName), $(NewDataName)	endifEnd// ***************************************************************************// **************** 				Replacing Data & Axes with saved originals// ***************************************************************************Function RevertSelectedData(DataList, DataSel, DataGroup, RevertData, RevertAxis, RevertAllFlag)	Wave DataSel, DataGroup	Wave /T DataList	Variable RevertData, RevertAxis, RevertAllFlag		Variable i, Sel	String AxisAndFolderName, DataName, SampleName, DataAndFolderName, FolderStem = "root:SPECTRA:Data:Load"	String SaveAxisAndFolderName, SaveDataAndFolderName, TwoDDataName		for (i=0;i<numpnts(DataSel);i+=1)		if (((DataSel[i]&2^0) != 0) || ((DataSel[i]&2^3) != 0) || (RevertAllFlag))			DataName				= DataList[i]			SampleName 			= ReplaceString("_data",DataName,"")			DataAndFolderName	= FolderStem + num2str(DataGroup[i]) + ":" + DataName			AxisAndFolderName	= AnyNameFromDataName(DataAndFolderName,"axis")						SaveDataAndFolderName	= FolderStem + num2str(DataGroup[i]) + ":Originals:" + DataName			SaveAxisAndFolderName	= AnyNameFromDataName(SaveDataAndFolderName,"axis")						if (RevertData == 1)				Duplicate /O/D $(SaveDataAndFolderName), $(DataAndFolderName)				if (WaveExists($(SaveDataAndFolderName+"_sig")))					Duplicate /O/D $(SaveDataAndFolderName+"_sig"), $(DataAndFolderName+"_sig")				endif				RevertPlotDataDuplicates(DataName,SaveDataAndFolderName)			endif			if (RevertAxis == 1)				Duplicate /O/D $(SaveAxisAndFolderName), $(AxisAndFolderName)				if (WaveExists($(SaveAxisAndFolderName+"_sig")))					Duplicate /O/D $(SaveAxisAndFolderName+"_sig"), $(AxisAndFolderName+"_sig")				endif			endif						TwoDDataName 			= FolderStem + num2str(DataGroup[i]) + ":TwoD:" + SampleName + "_2D"			SaveDataAndFolderName	= FolderStem + num2str(DataGroup[i]) + ":Originals:" + SampleName + "_2D"			if (WaveExists($TwoDDataName))				WAVE OriginalData 	= $(SaveDataAndFolderName)				WAVE UserData 		= $(TwoDDataName)				UserData 	= OriginalData//				Duplicate /O/D $(SaveDataAndFolderName), $(TwoDDataName)			endif		endif	endfor		// Some image plots display a duplicated version of the original 2D data, so best to update. 	//UpdatePlottedEEMs()	print " !! The routine 'UpdatePlottedEEMs' is not included in this release"		SetDataFolder root:End// Update Graph:DataDuplicates when the original data is Reverted from the DataPlottingPanelFunction RevertPlotDataDuplicates(DataName,SaveDataAndFolderName)	String DataName,SaveDataAndFolderName		Variable i, NumGraphs	String PlotFolder, GraphName, DataCopyFolder		PlotFolder 	= "root:SPECTRA:Plotting"	NumGraphs 	= CountObjects(PlotFolder, 4)		// Look through all the Graph folders. 	for (i=0;i<NumGraphs;i+=1)		GraphName 		= GetIndexedObjName (PlotFolder, 4,  i)				DataCopyFolder 	= CheckFolderColon(PlotFolder) + GraphName + ":DataDuplicates"		WAVE DataCopy 	= $(CheckFolderColon(DataCopyFolder) + DataName)				if (WaveExists(DataCopy) == 1)			Duplicate /O/D $(SaveDataAndFolderName), $(CheckFolderColon(DataCopyFolder) + DataName)		endif	endforEnd// // Update Data from Graph:DataDuplicatesFunction RevertPlottedData(PlotName,Selection1)	String PlotName,Selection1		String PlotFolderName = "root:SPECTRA:Plotting:" + PlotName	SVAR gSelection1 	= $(PlotFolderName+":gSelection1")		Variable i, NumTraces, RevertAllFlag = 1	String DataName, DataAndFolderName, SaveDataAndFolderName		if (cmpstr("_none_",Selection1) == 0)	elseif (cmpstr("_all_",Selection1) == 0)		DoAlert 1,"Revert ALL left-plotted traces to saved originals?"		RevertAllFlag = V_flag				if (RevertAllFlag==1)			NumTraces = ItemsInList(AxisTraceListBG(PlotName,"left",""))			for (i=0;i<NumTraces;i+=1)				DataName					= NameOfWave(WaveRefIndexed(PlotName,i,1))				DataAndFolderName		= GetWavesDataFolder(WaveRefIndexed(PlotName,i,1),2)				SaveDataAndFolderName	= PlotFolderName + ":DataDuplicates:" + DataName								Duplicate /O/D $(SaveDataAndFolderName), $(DataAndFolderName)			endfor		endif		else		DataName					= NameOfWave(TraceNameToWaveRef(PlotName,Selection1))		DataAndFolderName		= GetWavesDataFolder(TraceNameToWaveRef(PlotName,Selection1),2)		SaveDataAndFolderName	= PlotFolderName + ":DataDuplicates:" + DataName				Duplicate /O/D $(SaveDataAndFolderName), $(DataAndFolderName)	endifEnd// ***************************************************************************// **************** 				Making a Table of Selected Data// ***************************************************************************// 		If no data are selected, then create a blank data + errors wave. Function EditSelectedData(DataList, DataSel, DataGroup,TableFlag,CmdLineFlag)	Wave DataSel, DataGroup	Wave /T DataList	Variable TableFlag,CmdLineFlag		Variable i, NPts	String AxisName, AxisAndFolderName, DataName, DataAndFolderName, FolderStem = "root:SPECTRA:Data:Load", FolderName	String AxisSigName, AxisSigAndFolderName, DataSigName, DataSigAndFolderName, InfoAndFolderName, TimeAndFolderName, EditList		if (sum(DataSel) == 0)		CreateBlankData()		return 1	endif		for (i=0;i<numpnts(DataSel);i+=1)		if (((DataSel[i]&2^0) != 0) || ((DataSel[i]&2^3) != 0))			DataName				= DataList[i]			FolderName 				= FolderStem + num2str(DataGroup[i]) + ":"			DataAndFolderName	= FolderStem + num2str(DataGroup[i]) + ":" + DataName			AxisName 				= AxisNameFromDataName(DataName)			AxisAndFolderName	= AxisNameFromDataName(DataAndFolderName)			InfoAndFolderName 	= AnyNameFromDataName(DataAndFolderName,"info")			TimeAndFolderName	= AnyNameFromDataName(DataAndFolderName,"time")			NPts 					= numpnts($DataAndFolderName)						// First option is just to display the full data folder path for the selected waves. 			if (CmdLineFlag == 1)				Print " *** Full name of selected wave: "				Print AxisAndFolderName				Print DataAndFolderName			endif						// The second option is to display the waves for editing, and create new associated waves. 			if (TableFlag == 1)				AxisSigName					= AnyNameFromDataName(DataName,"axis_sig")				DataSigName					= AnyNameFromDataName(DataName,"data_sig")								if (strlen(DataSigName) < 32)									// Use this as a way to generate and manually fill errors and info waves					AxisSigAndFolderName		= AnyNameFromDataName(DataAndFolderName,"axis_sig")					if (waveexists($(AxisSigAndFolderName)) == 0)						Duplicate /O/D $(AxisAndFolderName), $(AxisSigAndFolderName)						WAVE AxisErrors	= $(AxisSigAndFolderName)						AxisErrors = 0					endif										DataSigAndFolderName		= AnyNameFromDataName(DataAndFolderName,"data_sig")					if (waveexists($(DataSigAndFolderName)) == 0)						Duplicate /O/D $(DataAndFolderName), $(DataSigAndFolderName)						WAVE DataErrors	= $(DataSigAndFolderName)						DataErrors = 0					endif										InfoAndFolderName		= AnyNameFromDataName(DataAndFolderName,"info")					if (waveexists($(InfoAndFolderName)) == 0)						MAKE /O/T/N=(NPts) $(InfoAndFolderName)						WAVE /T Info	= $(InfoAndFolderName)						Info = ""					endif									EditList = AxisAndFolderName+";"+AxisSigAndFolderName+";"+DataAndFolderName+";"+DataSigAndFolderName+";"+InfoAndFolderName+";"				endif								EditList = AxisAndFolderName+";"				if (WaveExists($AxisSigAndFolderName) == 1)					EditList 	= EditList + AxisSigAndFolderName + ";"				endif				EditList = EditList + DataAndFolderName+";"				if (WaveExists($DataSigAndFolderName) == 1)					EditList 	= EditList + DataSigAndFolderName + ";"				endif				if (WaveExists($InfoAndFolderName) == 1)					EditList 	= EditList + InfoAndFolderName + ";"				endif				if (waveexists($(TimeAndFolderName)) == 1)					EditList 	= EditList + TimeAndFolderName + ";"				endif								//THIS SECTION COULD REPLACE MUCH OF THE ABOVE				String AdditionalWaveList 	= ListOfObjectsInFolder(1,FolderName,"", "")				Variable j, NWaves = ItemsInList(AdditionalWaveList)				for (j=0;j<NWaves;j+=1)					String AddWaveName = StringFromList(j,AdditionalWaveList)					if (strlen(ListMatch(AddWaveName,EditList)) == 0)						EditList 	= EditList + FolderName + AddWaveName + ";"					endif				endfor								DisplayWavesInTable(EditList,ReplaceString("_data",DataName,""))							endif		endif	endfor	SetDataFolder root:EndFunction CreateBlankData()	WAVE /T wDataList 	= root:SPECTRA:wDataList	WAVE wDataSel 	 	= root:SPECTRA:wDataSel	WAVE wDataGroup 	= root:SPECTRA:wDataGroup	MakeStringIfNeeded("root:SPECTRA:Globals:gBlankName","")	MakeVariableIfNeeded("root:SPECTRA:Globals:gBlankNPts",128)		SVAR gBlankName 	= root:SPECTRA:GLOBALS:gBlankName	NVAR gBlankNPts 		= root:SPECTRA:GLOBALS:gBlankNPts	String BlankName 	= gBlankName	Prompt BlankName,"Name for new blank data file"	Variable BlankNPts 	= gBlankNPts	Prompt BlankNPts,"Number of points"	DoPrompt "Create a blank data file", BlankName, BlankNPts	if (V_Flag)		return -1	endif		gBlankName 	= GetSampleName(BlankName,"","",0,0,1)	gBlankNPts 	= max(1,BlankNPts)		Make /O/D/N=(gBlankNPts) axis, data		AdoptAxisAndDataFromMemory("axis","","","data","","",gBlankName,"",0,0,1)		KillWaves /Z axis, data		wDataSel[numpnts(wDataSel) - 1] = 1	EditSelectedData(wDataList, wDataSel, wDataGroup,1,0)End// ***************************************************************************// **************** 				Copying loaded data to root folder for User Manipulation// ***************************************************************************Function CopyDataToRoot(DataList, DataSel, DataGroup)	Wave DataSel, DataGroup	Wave /T DataList		Variable i	String AxisName, AxisAndFolderName, DataName, DataAndFolderName, FolderStem = "root:SPECTRA:Data:Load"	for (i=0;i<numpnts(DataSel);i+=1)		if (((DataSel[i]&2^0) != 0) || ((DataSel[i]&2^3) != 0))			DataName			= DataList[i]			DataAndFolderName	= FolderStem + num2str(DataGroup[i]) + ":" + DataName			AxisName 			= AxisNameFromDataName(DataName)			AxisAndFolderName	= AxisNameFromDataName(DataAndFolderName)						Duplicate /O/D $(DataAndFolderName), $("root:"+DataName)			Duplicate /O/D $(AxisAndFolderName), $("root:"+AxisName)		endif	endfor	SetDataFolder root:EndFunction DeleteAllDataInRoot()	KillAllWavesInFolder("root:","*")End// ***************************************************************************// **************** 				Swap Data and Axis: Sometimes they get loaded the wrong way round. // ***************************************************************************Function SwapDataAndAxes(DataList, DataSel, DataGroup)	Wave DataSel, DataGroup	Wave /T DataList		Variable i	String ListOfWaves, FolderStem = "root:SPECTRA:Data:Load"	String AxisName, AxisAndFolderName, DataName, DataAndFolderName, TempDataName		for (i=0;i<numpnts(DataSel);i+=1)//		if (DataSel[i] == 1)		if (((DataSel[i]&2^0) != 0) || ((DataSel[i]&2^3) != 0))			DataName				= DataList[i]			DataAndFolderName	= FolderStem + num2str(DataGroup[i]) + ":" + DataName			AxisName 				= AxisNameFromDataName(DataName)			AxisAndFolderName	= AxisNameFromDataName(DataAndFolderName)						TempDataName		= FolderStem + num2str(DataGroup[i]) + ":tempData"						Duplicate /O/D $DataAndFolderName, $TempDataName			Duplicate /O/D $AxisAndFolderName, $DataAndFolderName			Duplicate /O/D $TempDataName, $AxisAndFolderName			KillWaves /Z $TempDataName						// Ensure the new axis runs low to high			ListOfWaves 	= AxisAndFolderName+";"+DataAndFolderName+";"			SortWavesFromList(ListOfWaves,0)		endif	endforEnd//	+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++////						THE FOLLOWING ROUTINES OPERATE ON PLOTTED DATA via Lists of Traces////	+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++// ***************************************************************************// **************** 				Simple Mathematical Operations. // ***************************************************************************Function ApplyMathOpToPlotDataOrAxis(PlotName)	String PlotName		Variable ContinueFlag = 1//	String ListofDataNames= TraceNameList(PlotName, ";", 1)	String ListOfMathOps, ListofDataNames= AxisTraceListBG(PlotName, "left","")		ListofDataNames 	= RemoveSpecialTracesFromList(ListofDataNames,"mask")		ListOfMathOps 	= "Addition;Multiplication;Division;Reciprocal;Log;Inverse Log;Natural Log;Inv. Nat. Log;square root;Convolve Gaussian;2theta to Q (enter lambda, n);Q to 2theta (enter lambda);Q to D;2theta to D (enter lambda);nm to eV;eV to nm;"	ListOfMathOps 	+="Wavenumbers to eV;eV to wavenumbers;Wavenumbers to nm;nm to wavenumbers;Abs to Trans;Trans to Abs;Scaled SQRT error;"	ListOfMathOps 	+="SXF Channel to Energy;Scale & shift;0's to NAN's;Truncate to positive;Kebulca-Munk;Sort Axis Values;E to k;k to E;Data*Axis^n;Data floor;"		String OldDF = getDataFolder(1)	SetDataFolder root:SPECTRA:Plotting		MakeStringIfNeeded("gMathDataName","")		MakeStringIfNeeded("gMathOpName","Addition")		MakeVariableIfNeeded("gMathAxisFlag",1)		MakeVariableIfNeeded("gMathOpFlag",1)		MakeVariableIfNeeded("gMathOpConst",1)		MakeVariableIfNeeded("gMathOpConst2",1)				SVAR gMathDataName = gMathDataName		SVAR gMathOpName 	= gMathOpName		NVAR gMathAxisFlag	= gMathAxisFlag		NVAR gMathOpFlag 	= gMathOpFlag		NVAR gMathOpConst 	= gMathOpConst		NVAR gMathOpConst2 	= gMathOpConst2			String MathDataName = gMathDataName		Prompt MathDataName, "Choose data to modify",popup,"_all_;" + ListofDataNames		Variable MathAxisFlag = gMathAxisFlag		Prompt MathAxisFlag, "Apply mathematical operation to data or axis?", popup, "data;axis;"//		Variable MathOpFlag = gMathOpFlag//		Prompt MathOpFlag, "Select a mathematical operation", popup, ListOfMathOps		String MathOpName = gMathOpName		Prompt MathOpName, "Select a mathematical operation", popup, ListOfMathOps		Variable MathOpConst = gMathOpConst		Prompt MathOpConst, "Enter a constant:"		Variable MathOpConst2 = gMathOpConst2		Prompt MathOpConst2, "Enter 2nd constant:"		DoPrompt "Please enter the math operation parameters", MathDataName, MathAxisFlag, MathOpName, MathOpConst, MathOpConst2		if (V_Flag)			return -1		endif		gMathDataName	= MathDataName		gMathAxisFlag		= MathAxisFlag//		gMathOpFlag 		= MathOpFlag		gMathOpName 		= MathOpName		gMathOpConst		= MathOpConst		gMathOpConst2	= MathOpConst2				Variable MsgFlag = 1		if (cmpstr("_all_",MathDataName) != 0)			ListofDataNames = MathDataName + ";"		endif		//		ApplyMathOpToWindowDataOrAxis(PlotName,ListofDataNames,gMathAxisFlag,gMathOpFlag,gMathOpConst,1)		ApplyMathOpToWindowDataOrAxis(PlotName,ListofDataNames,gMathAxisFlag,gMathOpName,gMathOpConst,gMathOpConst2,1)			SetDataFolder $(OldDF)End// 	The function loops through PLOTTED DATAFunction ApplyMathOpToWindowDataOrAxis(WindowName,ListofDataNames,MathAxisFlag,gMathOpName,MathOpConst,MathOpConst2,MsgFlag)	String WindowName,ListofDataNames, gMathOpName	Variable MathAxisFlag,MathOpConst,MathOpConst2,MsgFlag		String PlotFolderName 	= "root:SPECTRA:Plotting:" + WindowName	NVAR gCsrRangeChoice 	= $(PlotFolderName+":gCsrRangeChoice")		String ListofSampleNames = ReplaceString("_data",ListofDataNames,"")	String TraceName, ListofTraceNames= AxisTraceListBG(WindowName, "left","")	String DataName, ListOfWaves, Msg	Variable i, CsrXA, CsrXB, PromptFlag=1, NumData = ItemsInList(TraceNameList(WindowName, ";", 1))		for (i=0;i<NumData;i+=1)		TraceName				= StringFromList(i,ListofTraceNames)		DataName				= StripSuffixBySeparator(TraceName,"_")				// Only apply Math Op if the trace is in the list of traces to modify. I.e., skip waves such as 'polynomial'		if (WhichListItem(DataName,ListofSampleNames)>-1)						WAVE Axis 	= $GetWavesDataFolder(XWaveRefFromTrace(WindowName,TraceName), 2)			WAVE Data 	= $GetWavesDataFolder(TraceNameToWaveRef(WindowName,TraceName), 2)						if (gCsrRangeChoice == 1)				CsrXA 	= 0				CsrXB 	= numpnts(Data)-1			else				CsrXA 	= GetCursorPositionOrValue(WindowName,"A",0)				CsrXB 	= GetCursorPositionOrValue(WindowName,"B",0)			endif						if (cmpstr(gMathOpName,"Convolve Gaussian") == 0)				ConvolveGauss(Axis, Data,CsrXA,CsrXB,MathOpConst)				Msg = " *** Convolved "+nameofwave(Data)+" with a Gaussian with FWHM of "+num2str(MathOpConst)			else				if (MathAxisFlag == 1)					if (WaveType(Data) == 1)						ApplyMathOpToComplexData(Data, gMathOpName, MathOpConst, MathOpConst2, CsrXA,CsrXB, PromptFlag, MsgFlag)					else						ApplyMathOpToDataAndErrors(Data, gMathOpName, MathOpConst, MathOpConst2, CsrXA,CsrXB, PromptFlag, MsgFlag)					endif				else					ApplyMathOpToDataAndErrors(Axis, gMathOpName, MathOpConst, MathOpConst2, CsrXA,CsrXB, PromptFlag, MsgFlag)				endif							endif						// If User Input has been solicited, turn this off for any subsequent data transformations. 			PromptFlag = 0		endif	endforEnd// this routine could apply to Data-and-Errors or Axis-and-ErrorsFunction ApplyMathOpToDataAndErrors(Data, MathOpName, NumConst1,NumConst2,inMinPt, inMaxPt, PromptFlag,MsgFlag)	Wave Data	String MathOpName	Variable NumConst1,NumConst2, inMinPt, inMaxPt ,PromptFlag, MsgFlag		WAVE Errors 	= $GetWavesDataFolder(Data, 2)+"_sig"		Variable MinPt, MaxPt, SortFlag	MinPt 		= min(inMinPt,inMaxPt)	MaxPt 	= max(inMinPt,inMaxPt)		// ZEROTH, 	if (cmpstr(MathOpName,"Scaled SQRT error")==0)		if (!WaveExists(Errors))//			String ErrorsName 	= NameOfWave(Data) + "_sig"			String ErrorsName 	= GetWavesDataFolder(Data, 2)+"_sig"			Duplicate Data, $ErrorsName		endif		print GetWavesDataFolder(Data, 2)+"_sig"		WAVE Errors 	= $GetWavesDataFolder(Data, 2)+"_sig"		Errors[MinPt,MaxPt] 	= NumConst1 * sqrt(Data[p])		return 1	endif		// FIRST, propagate the data transformation to the errors if they exist. 	if (WaveExists(Errors))		ApplyMathOpToErrors(Data, Errors, MathOpName, NumConst1,NumConst2, MinPt, MaxPt)	endif		// SECOND, apply the Math Operation to the data and note whether the axis values have been reversed. 	// This works, although arguably shouldn't	Variable CmplData = WaveType(Data) & 0x01	if (!CmplData)		SortFlag = ApplyMathOpToData(Data, MathOpName, NumConst1,NumConst2, MinPt, MaxPt, PromptFlag, MsgFlag)	else		SortFlag = ApplyMathOpToComplexData(Data, MathOpName, NumConst1,1,MinPt, MaxPt, PromptFlag,MsgFlag)	endif		// THIRD, apply the data transformation to the fit if it exists. 	// ????? no! this seems to be already taken care of aboee. //	String FitName = AnyNameFromDataName(GetWavesDataFolder(Data, 2),"fit")//	WAVE Fit 	= $FitName//	if (WaveExists(Fit))//		ApplyMathOpToData(Fit, MathOpName, NumConst1,NumConst2, MinPt, MaxPt, 0, 0)//	endif	// For certain ops (e.g., eVtonm), this routine has been given an Axis wave, and the ordering of the values has been reversed.  	if (Sortflag == 1)		String ExistingWaves, ListOfWaves, AxisName, DataName, AxisFolderName, AxisAndFolderName, DataAndFolderName, AxisErrNFolderName, DataErrNFolderName		AxisName 				= NameOfWave(Data)		DataName 				= ReplaceString("_axis",AxisName,"_data")		AxisFolderName 		= GetWavesDataFolder(Data,1)		AxisAndFolderName 	= AxisFolderName + AxisName		DataAndFolderName 	= AxisFolderName + DataName		AxisErrNFolderName 	= AxisFolderName + AxisName + "_sig"		DataErrNFolderName 	= AxisFolderName + DataName + "_sig"				ExistingWaves 	= AxisName+";"+DataName+";"+AxisName + "_sig"+";"+DataName + "_sig"+";"		ListOfWaves 	= AxisAndFolderName+";"+DataAndFolderName+";" + AxisErrNFolderName + ";" + DataErrNFolderName + ";"				String AdditionalWaveList 	= ListOfObjectsInFolder(1,GetWavesDataFolder(Data,1),"", ExistingWaves)		AdditionalWaveList 			= AddPrefixOrSuffixToListItems(AdditionalWaveList,GetWavesDataFolder(Data,1),"")				ListOfWaves = ListOfWaves + AdditionalWaveList				SortWavesFromList(ListOfWaves,0)	endifEnd//				String AdditionalWaveList 	= ListOfObjectsInFolder(1,FolderName,"", "")//				Variable j, NWaves = ItemsInList(AdditionalWaveList)//				for (j=0;j<NWaves;j+=1)//					String AddWaveName = StringFromList(j,AdditionalWaveList)//					if (strlen(ListMatch(AddWaveName,EditList)) == 0)//						EditList 	= EditList + FolderName + AddWaveName + ";"//					endif//				endforFunction ApplyMathOpToErrors(Data,Errors,MathOpName, NumConst1,NumConst2,MinPt,MaxPt)	Wave Data, Errors	String MathOpName	Variable NumConst1,NumConst2,MinPt,MaxPt		if (!WaveExists(Errors))		return 0	endif		Duplicate /O/FREE Data, Data1, Data2	Data1[MinPt,MaxPt] 		= Data[p] - Errors[p]	Data2[MinPt,MaxPt] 		= Data[p] + Errors[p]		ApplyMathOpToData(Data1, MathOpName, NumConst1,NumConst2,MinPt,MaxPt,0,0)	ApplyMathOpToData(Data2, MathOpName, NumConst1,NumConst2,MinPt,MaxPt,0,0)		Errors[MinPt,MaxPt] 	= abs(Data2[p] - Data1[p])/2EndFunction ApplyMathOpToComplexData(Data, MathOpName, NumConst1,NumConst2,MinPt, MaxPt, PromptFlag,MsgFlag)	Wave/C Data	String MathOpName	Variable NumConst1,NumConst2,MinPt,MaxPt ,PromptFlag, MsgFlag		String ListOfWaves, Msg=" *** No valid math operation selected!"	Variable PosMin, Sortflag = 0		strswitch (MathOpName)		case "Addition":						// Currently, just modify the real part				Data[MinPt,MaxPt] = cmplx(real(Data[p]) + NumConst1, imag(Data[p]))							Msg = " *** Added "+num2str(NumConst1)+" to " + nameofwave(Data)			break		case "Multiplication":						// Currently, just modify the real part				Data[MinPt,MaxPt] = cmplx(real(Data[p]) * NumConst1, imag(Data[p]))				//				Data[MinPt,MaxPt] = cmplx(real(Data[p]), imag(Data[p]) * NumConst1)							Msg = " *** Multiplied "+nameofwave(Data)+" by " + num2str(NumConst1)			break		case "Division":				// Currently, just modify the real part				Data[MinPt,MaxPt] = cmplx(real(Data[p]) / NumConst1, imag(Data[p]))							Msg = " *** Divided "+nameofwave(Data)+" by " + num2str(NumConst1)			break		case "Reciprocal":			Data[MinPt,MaxPt] = 1/Data[p]			Msg = " *** Took the reciprocal of  "+nameofwave(Data)			break		case "Log":			Data[MinPt,MaxPt] = log(Data[p])			Msg = " *** Took the log of  "+nameofwave(Data)			break		case "Inverse Log":			Data[MinPt,MaxPt] = 10^Data[p]			Msg = " *** Took the inverse log of  "+nameofwave(Data)			break		case "Natural log":			Data[MinPt,MaxPt] = ln(Data[p])			Msg = " *** Took the natural log of  "+nameofwave(Data)			break		case "Inverse Ln":			Data[MinPt,MaxPt] = exp(Data[p])			Msg = " *** Took the inverse natural log of  "+nameofwave(Data)			break		case "square root":			// Data[MinPt,MaxPt] = sqrt(Data[p])			Data[MinPt,MaxPt] = SignedSqrt(Data[p])			Msg = " *** Took the square root of  "+nameofwave(Data)			break				endswitchEndFunction ApplyMathOpToData(Data, MathOpName, NumConst1,NumConst2,MinPt, MaxPt, PromptFlag,MsgFlag)	Wave Data	String MathOpName	Variable NumConst1,NumConst2,MinPt,MaxPt ,PromptFlag, MsgFlag		String ListOfWaves, Msg=" *** No valid math operation selected!"	Variable PosMin, Sortflag = 0		strswitch (MathOpName)		case "Addition":			Data[MinPt,MaxPt] += NumConst1			Msg = " *** Added "+num2str(NumConst1)+" to " + nameofwave(Data)			break		case "Multiplication":			Data[MinPt,MaxPt] *= NumConst1			Msg = " *** Multiplied "+nameofwave(Data)+" by " + num2str(NumConst1)			break		case "Division":			Data[MinPt,MaxPt] /= NumConst1			Msg = " *** Divided "+nameofwave(Data)+" by " + num2str(NumConst1)			break		case "Reciprocal":			Data[MinPt,MaxPt] = 1/Data[p]			Msg = " *** Took the reciprocal of  "+nameofwave(Data)			break		case "Log":			Data[MinPt,MaxPt] = log(Data[p])			Msg = " *** Took the log of  "+nameofwave(Data)			break		case "Inverse Log":			Data[MinPt,MaxPt] = 10^Data[p]			Msg = " *** Took the inverse log of  "+nameofwave(Data)			break		case "Natural log":			Data[MinPt,MaxPt] = ln(Data[p])			Msg = " *** Took the natural log of  "+nameofwave(Data)			break		case "Inverse Ln":			Data[MinPt,MaxPt] = exp(Data[p])			Msg = " *** Took the inverse natural log of  "+nameofwave(Data)			break		case "square root":			// Data[MinPt,MaxPt] = sqrt(Data[p])			Data[MinPt,MaxPt] = SignedSqrt(Data[p])			Msg = " *** Took the square root of  "+nameofwave(Data)			break		case "2theta to Q (enter lambda, n)":			Data[MinPt,MaxPt] = TwoThetaToQ(NumConst1,Data[p],n=NumConst2)			Msg = " *** Transformed the axis of "+nameofwave(Data)+" from 2-theta to q"			break		case "Q to 2theta (enter lambda)":			Data[MinPt,MaxPt] = QToTwoTheta(NumConst1,Data[p])			Msg = " *** Transformed the axis of "+nameofwave(Data)+" from q to 2-theta"			break		case "Q to D":			Data[MinPt,MaxPt] = 2*pi/Data[p]			Msg = " *** Transformed the axis of "+nameofwave(Data)+" from q to D"			break		case "2theta to D (enter lambda)":			Data[MinPt,MaxPt] = TwoThetaToD(NumConst1,Data[p])			Sortflag = 1			Msg = " *** Transformed the axis of "+nameofwave(Data)+" from 2-theta to d"			break		case "nm to eV":			Data[MinPt,MaxPt] = nmtoeV(Data[p])			Sortflag = 1			Msg = " *** Transformed the axis of "+nameofwave(Data)+" from nm to eV"			break		case "eV to nm":			Data[MinPt,MaxPt] = eVtonm(Data[p])			Sortflag = 1			Msg = " *** Transformed the axis of "+nameofwave(Data)+" from eV to nm"			break		case "Wavenumbers to eV":			Data[MinPt,MaxPt] = WavenumbersToeV(Data[p])			Sortflag = 1			Msg = " *** Transformed the axis of "+nameofwave(Data)+" from wavenumbers to eV"			break		case "eV to wavenumbers":			Data[MinPt,MaxPt] = eVToWavenumbers(Data[p])			Sortflag = 1			Msg = " *** Transformed the axis of "+nameofwave(Data)+" from eV to wavenumbers"			break		case "Wavenumbers to nm":			Data[MinPt,MaxPt] = WavenumbersTonm(Data[p])			Sortflag = 1			Msg = " *** Transformed the axis of "+nameofwave(Data)+" from wavenumbers to nm"			break		case "nm to wavenumbers":			Data[MinPt,MaxPt] = nmToWavenumbers(Data[p])			Sortflag = 1			Msg = " *** Transformed the axis of "+nameofwave(Data)+" from nm to wavenumbers"			break		case "Abs to Trans":			Data[MinPt,MaxPt] = 10^(-1*(Data[p]))			Msg = " *** Converted "+nameofwave(Data)+" from Absorbance to Transmittance"			break		case "Trans to Abs":			Data[MinPt,MaxPt] = -1*log(Data[p])			Msg = " *** Converted "+nameofwave(Data)+" from Transmittance to Absorbance"			break		case "SXF Channel to Energy":			ChannelToeV(Data,PromptFlag)			Sortflag = 1			Msg = " *** Transformed the axis of "+nameofwave(Data)+" from channel number to eV"			break		case "Scale & shift":			ScaleAndShift(Data,PromptFlag)			Sortflag = 1			Msg = " *** Applied scaling and shifting transformation to the axis of "+nameofwave(Data)			break		case "Truncate to positive":			PosMin = PositiveMinimim(Data)			Data[MinPt,MaxPt] = (Data[p] <= 0) ? PosMin : Data[p]			Msg = " *** Replaced nagative values in "+nameofwave(Data)+" with smallest non-negative value = " + num2str(PosMin)			break		case "0's to NAN's":			Data[MinPt,MaxPt] = (Data[p] == 0) ? NAN : Data[p]			Msg = " *** Replaced zeroes in "+nameofwave(Data)+" with NAN's"			break		case "Data floor":			Data[MinPt,MaxPt] = (Data[p] < NumConst1) ? NumConst1 : Data[p]			Msg = " *** Replaced zeroes in "+nameofwave(Data)+" with NAN's"			break//		case "2-value scatter"://			NumConst1,NumConst2//			break		case "Kebulca-Munk":			// Kebulka-Munk function  F(R) = (1-R)^2/2R where R is reflectance (0-1)			Data[MinPt,MaxPt] = (1-Data[p]^2)/(2*Data[p])			Msg = " *** Performed Kebula-Munk transformation on"+nameofwave(Data)			break		case "Sort Axis Values":			SortFlag = 1			Msg = " *** Sorting axis values so that "+nameofwave(Data)+" (and any errors) runs from low to high"			break		case "Data*Axis^n":			WAVE Axis 	= $(ReplaceString("_data",GetWavesDataFolder(Data,2),"_axis"))			if (WaveExists(Axis))				Data[MinPt,MaxPt] = Data[p]*Axis[p]^NumConst1				Msg = " *** Multiplying "+nameofwave(Data)+"by axis to the power"+num2str(NumConst1)			else				Msg = " *** Problem locating axis for "+nameofwave(Data)			endif			break	endswitch		if (MsgFlag == 1)		Print Msg	endif		return SortflagEndFunction SignedSqrt(v)	Variable v		if (v < 0)		return -1*sqrt(abs(v))	else		return sqrt(v)	endifEnd// *** This works fine 2012-11-24Function ConvolveGauss(axis, data,MinPt,MaxPt,FWHM)	Wave axis, data	Variable MinPt,MaxPt, FWHM		Variable ConvArea1, ConvArea2, DataNPts, MinStep, ConvMin, ConvMax, ConvNPts, ConvStep, ConvCenter		// Extract the relevant data range. 	DataNPts 	= Maxpt - MinPt + 1	Make /FREE/D/N=(DataNPts) Axis1, Data1	Axis1[] 	= axis[p+MinPt]	Data1[] 	= data[p+MinPt]		// We need to have a constant axis step, but limit total number of new axis values	ConvMin 		= axis[MinPt]	ConvMax 		= axis[MaxPt]	MinStep 		= abs(CheckConstantStep(axis,0.00000001,0))	ConvNPts 		= min(10000,(ConvMax-ConvMin)/MinStep)	ConvStep 		= (ConvMax-ConvMin)/(ConvNPts-1)		if (ConvNPts <2)		Print " 	... Problem in interpolate - too few points"		return 0	endif		// Make constant-step waves	Make /FREE/D/N=(ConvNPts) ConvAxis, ConvData, ConvPulse	SetScale /P x, ConvMin, ConvStep, ConvData, ConvPulse	ConvAxis 		= ConvMin + p*ConvStep		// Interpolate the data onto a constant-step axis	Interpolate2 /T=1/I=3/X=ConvAxis/Y=ConvData Axis1, Data1	ConvArea1 	= area(ConvData)			// Make a Gaussian pulse at the center of the range ... 	ConvCenter 	= ConvMin + (ConvMax-ConvMin)/2	ConvPulse 		= Gauss(x,ConvCenter,FWHM/sqrt(2))		// Apply the convolution	Convolve /A ConvPulse, ConvData	ConvArea2 	= area(ConvData)		// Renormalize the convolved data. 	ConvData *= (ConvArea1/ConvArea2)		// Interpolate back onto the original axis ... 	Interpolate2 /T=1/I=3/X=Axis1/Y=Data1 ConvAxis, ConvData	// ... and overwrite the original data points. 	 data[MinPt,MaxPt] 	= Data1[p-MinPt]End// ***************************************************************************// **************** 				Mathematical Operations Combining TWO Data Waves// ***************************************************************************Function ApplyMathToTwoDataWaves(Data1,Axis1,Data2,Axis2, Result,ReportFlag,MathOpName)	Wave Data1,Axis1,Data2,Axis2, Result	Variable ReportFlag	String MathOpName		Variable ErrorType = 1	String ReportMsg	String Data1Name 	= ReplaceString("_data",NameOfWave(Data1),"")	String Data2Name 	= ReplaceString("_data",NameOfWave(Data2),"")		strswitch (MathOpName)		case "Addition":						// ADD Data2 to Data1			Result[] = Data1[p] + Data2[BinarySearchInterp(Axis2,Axis1[p])]			ReportMsg = " *** Added "+Data2Name+" from "+Data1Name			break					case "Subtraction":					// SUBTRACT Data2 from Data1			Result[] = Data1[p] - Data2[BinarySearchInterp(Axis2,Axis1[p])]			ReportMsg = " *** Subtracted "+Data2Name+" from "+Data1Name			break				case "Division":						// DIVIDE Data1 by Data2			Result[] = Data1[p] / Data2[BinarySearchInterp(Axis2,Axis1[p])]			ReportMsg = " *** Divided "+Data1Name+" by "+Data2Name			ErrorType = 2			break				case "Division less one":				// DIVIDE Data1 by Data2, and then subtract unity			Result[] = Data1[p] / Data2[BinarySearchInterp(Axis2,Axis1[p])]			Result[] -= 1			ReportMsg = " *** Divided "+Data1Name+" by "+Data2Name+" and subtracted 1"			ErrorType = 2			break				case "Multiplication":					// MULTIPLY Data1 by Data2			Result[] = Data1[p] * Data2[BinarySearchInterp(Axis2,Axis1[p])]			ReportMsg = " *** Multiplied "+Data1Name+" by "+Data2Name			ErrorType = 2			break	endswitch		Note Result ReportMsg		if (ReportFlag)		Print ReportMsg	endif		// Try to combine errors properly if (i) they exist and (ii) the axes are identical. 	WAVE Data1Error 	= $(GetWavesDataFolder(Data1,2)+"_sig")	WAVE Data2Error 	= $(GetWavesDataFolder(Data2,2)+"_sig")	WAVE ResultError 	= $(GetWavesDataFolder(Result,2)+"_sig")		if (WaveExists(Data1Error) && WaveExists(Data2Error) && WaveExists(ResultError) && EqualWaves(Axis1,Axis2,1))		ReportMsg = ReportMsg + "  ...   propagating errors"		if (ErrorType == 1)			ResultError[] 	= sqrt(Data1Error[p]^2 + Data2Error[p]^2)		elseif (ErrorType == 2)			ResultError[] 	= Result[p] * sqrt((Data1Error[p]/Data1[p])^2 + (Data2Error[p]/Data2)^2)		endif	endifEnd// ***************************************************************************// **************** 				Mathematical Operations Combining THREE Data Waves// ***************************************************************************// 2025-09-08 Simple addition ... Function ApplyMathToThreeDataWaves(Data1,Axis1,Data2,Axis2,Data3,Axis3,Result,Data3Scale,ReportFlag,MathOpName)	Wave Data1,Axis1,Data2,Axis2,Data3,Axis3, Result	Variable Data3Scale, ReportFlag	String MathOpName		Variable ErrorType = 1	String ReportMsg	String Data1Name 	= ReplaceString("_data",NameOfWave(Data1),"")	String Data2Name 	= ReplaceString("_data",NameOfWave(Data2),"")	String Data3Name 	= ReplaceString("_data",NameOfWave(Data3),"")		strswitch (MathOpName)		case "Addition":						// ADD Data2 to (Data1 - n x Data3)			Result[] = Data1[p] - Data3Scale*Data3[BinarySearchInterp(Axis3,Axis1[p])] + Data2[BinarySearchInterp(Axis2,Axis1[p])]			ReportMsg = " *** Added "+Data2Name+" to "+Data1Name+" minus "+num2str(Data3Scale)+" × "+Data3Name			break					case "Subtraction":					// SUBTRACT Data2 from (Data1 - n x Data3)			Result[] = Data1[p] - Data3Scale*Data3[BinarySearchInterp(Axis3,Axis1[p])] - Data2[BinarySearchInterp(Axis2,Axis1[p])]			ReportMsg = " *** Subtracted "+Data2Name+" from "+Data1Name+"minus "+num2str(Data3Scale)+" × "+Data3Name			break				case "Division":						// DIVIDE Data1 by (Data1 - n x Data3)			Result[] = (Data1[p] - Data3Scale*Data3[BinarySearchInterp(Axis3,Axis1[p])]) / Data2[BinarySearchInterp(Axis2,Axis1[p])]			ReportMsg = " *** Divided "+Data1Name+" minus "+num2str(Data3Scale)+" × "+Data3Name+" by "+Data2Name			ErrorType = 2			break				case "Division less one":				// DIVIDE Data1 by (Data1 - n x Data3), and then subtract unity			Result[] = (Data1[p] - Data3Scale*Data3[BinarySearchInterp(Axis3,Axis1[p])]) / Data2[BinarySearchInterp(Axis2,Axis1[p])]			Result[] -= 1			ReportMsg = " *** Divided "+Data1Name+" minus "+num2str(Data3Scale)+" × "+Data3Name+" by "+Data2Name+" and subtracted 1"			ErrorType = 2			break				case "Multiplication":					// MULTIPLY Data1 by (Data1 - n x Data3)			Result[] = (Data1[p] - Data3Scale*Data3[BinarySearchInterp(Axis3,Axis1[p])]) * Data2[BinarySearchInterp(Axis2,Axis1[p])]			ReportMsg = " *** Multiplied "+Data1Name+" minus "+num2str(Data3Scale)+" × "+Data3Name+" by "+Data2Name			ErrorType = 2			break	endswitch		Note Result ReportMsg		if (ReportFlag)		Print ReportMsg	endif		// Try to combine errors properly if (i) they exist and (ii) the axes are identical. 	WAVE Data1Error 	= $(GetWavesDataFolder(Data1,2)+"_sig")	WAVE Data2Error 	= $(GetWavesDataFolder(Data2,2)+"_sig")	WAVE ResultError 	= $(GetWavesDataFolder(Result,2)+"_sig")		if (WaveExists(Data1Error) && WaveExists(Data2Error) && WaveExists(ResultError) && EqualWaves(Axis1,Axis2,1))		ReportMsg = ReportMsg + "  ...   propagating errors"		if (ErrorType == 1)			ResultError[] 	= sqrt(Data1Error[p]^2 + Data2Error[p]^2)		elseif (ErrorType == 2)			ResultError[] 	= Result[p] * sqrt((Data1Error[p]/Data1[p])^2 + (Data2Error[p]/Data2)^2)		endif	endifEndFunction ApplyMathToTwoCmplxWaves(Data1,Axis1,Data2,Axis2, Result,ReportFlag,MathOpName)	Wave /C Data1,Axis1,Data2,Axis2, Result	Variable ReportFlag	String MathOpName		Variable ErrorType = 1	String ReportMsg	String Data1Name 	= ReplaceString("_data",NameOfWave(Data1),"")	String Data2Name 	= ReplaceString("_data",NameOfWave(Data2),"")		strswitch (MathOpName)		case "Addition":						// ADD Data2 to Data1			Result[] = Data1[p] + Data2[BinarySearchInterp(Axis2,Axis1[p])]			ReportMsg = " *** Added "+Data2Name+" from "+Data1Name			break					case "Subtraction":					// SUBTRACT Data2 from Data1			Result[] = Data1[p] - Data2[BinarySearchInterp(Axis2,Axis1[p])]			ReportMsg = " *** Subtracted "+Data2Name+" from "+Data1Name			break				case "Division":						// DIVIDE Data1 by Data2			Result[] = Data1[p] / Data2[BinarySearchInterp(Axis2,Axis1[p])]			ReportMsg = " *** Divided "+Data1Name+" by "+Data2Name			ErrorType = 2			break				case "Division less one":				// DIVIDE Data1 by Data2, and then subtract unity			Result[] = Data1[p] / Data2[BinarySearchInterp(Axis2,Axis1[p])]			Result[] -= 1			ReportMsg = " *** Divided "+Data1Name+" by "+Data2Name+" and subtracted 1"			ErrorType = 2			break				case "Multiplication":					// MULTIPLY Data1 by Data2			Result[] = Data1[p] * Data2[BinarySearchInterp(Axis2,Axis1[p])]			ReportMsg = " *** Multiplied "+Data1Name+" by "+Data2Name			ErrorType = 2			break	endswitchEndFunction CombineWaveErrorsADD(ErrorMatrix, Errors)	Wave ErrorMatrix, Errors		Variable i	Variable NScans 	= DimSize(ErrorMatrix,0)	Variable NPnts 	= DimSize(ErrorMatrix,1)		Make /O/D/N=(NScans) root:SAXS:Data:PointErrors /WAVE=PointErrors		for (i=0;i<NPnts;i+=1)		PointErrors[] 	= ErrorMatrix[p][i]				WaveStats /Q PointErrors		Errors[i] 	= V_rms	endforEnd// ***************************************************************************// **************** 				Area or Intensity normalize Selected Data// ***************************************************************************Function NormalizePlottedData(WindowName,NormStyle)	String WindowName	Variable NormStyle		String AxisAndFolderName, DataAndFolderName	Variable i, NPts, NormArea, CsrA, CsrB, CsrAvg, CsrAAxis, CsrBAxis	Variable StartIndex=-1, EndIndex=-1, ValueA, ValueB, Offset, Height	Variable NumTraces=ItemsInList(TraceNameList(WindowName, ";", 1),";")			String OldDF = getDataFolder(1)	SetDataFolder root:SPECTRA:Plotting		CsrAAxis = GetCursorPositionOrValue(WindowName,"A",1)		CsrBAxis = GetCursorPositionOrValue(WindowName,"B",1)			if (NormStyle == 1)			MakeVariableIfNeeded("gTotalArea",100)			MakeVariableIfNeeded("gCursorFlag",1)						NVAR gTotalArea 	= gTotalArea			NVAR gCursorFlag 	= gCursorFlag						Variable TotalArea=gTotalArea			Prompt TotalArea,"Normalization area"			Variable CursorFlag=gCursorFlag			Prompt CursorFlag,"Integration range", popup, "Full range;Between cursors;"			DoPrompt "Please enter the area normalization parameters", TotalArea,CursorFlag					elseif (NormStyle == 2)			MakeVariableIfNeeded("gTotalIntensity",1)			NVAR gTotalIntensity 	= gTotalIntensity			MakeVariableIfNeeded("gIntCrsrAvg",1)			NVAR gIntCrsrAvg 	= gIntCrsrAvg						Variable TotalIntensity=gTotalIntensity			Variable IntCrsrAvg=gIntCrsrAvg			Prompt IntCrsrAvg,"Number of points to average"			Prompt TotalIntensity,"Normalization Intensity"			DoPrompt "** Use BOTH cursors for Intensity Normalization ***", TotalIntensity, IntCrsrAvg					endif				if (V_Flag)			return -1		else			StartIndex	= min(CsrA,CsrB)			EndIndex 	= max(CsrA,CsrB)								if (NormStyle == 1)				gTotalArea	 		= TotalArea				gCursorFlag		= CursorFlag							elseif (NormStyle == 2)				gTotalIntensity 	= TotalIntensity				gIntCrsrAvg 		= IntCrsrAvg				CsrAvg 			= trunc(IntCrsrAvg/2)			endif		endif				for (i=0;i<NumTraces;i+=1)			DataAndFolderName 	= GetWavesDataFolder(WaveRefIndexed(WindowName,i,1), 2)			WAVE Data = $DataAndFolderName						AxisAndFolderName 	= GetWavesDataFolder(WaveRefIndexed(WindowName,i,2), 2)			WAVE Axis = $AxisAndFolderName						if (!TraceIsSpecial(NameOfWave(Data)))				WaveStats /Q/M=1 Axis				if (V_NumNANs > 0)					Print " *** The data ",NameOfWave(Data),"cannot be normalized because the axis contains NANs"				else					CsrA	= AxisValueToPoint(Axis, CsrAAxis)					CsrB	= AxisValueToPoint(Axis, CsrBAxis)					NPts 	= DimSize(Data,0)										if (NormStyle == 1)						// Area normalize every data wave that is plotted on the graph						if (CursorFlag == 2)							NormArea = SumWaveWithNANs(Data,min(CsrA,CsrB),max(CsrA,CsrB))						else							NormArea = SumWaveWithNANs(Data,0,NPts-1)						endif												if ((NormArea != 0) && (numtype(NormArea) == 0))							Data *= (TotalArea/NormArea)						else							Print " *** Problem with integrating the data", NameOfWave(Data)						endif											elseif (NormStyle == 2)						ValueA 		= mean(Data,max(0,CsrA-CsrAvg),min(NPts-1,CsrA+CsrAvg))						ValueB 	= mean(Data,max(0,CsrB-CsrAvg),min(NPts-1,CsrB+CsrAvg))																		if (ValueB > ValueA)							Offset 	= ValueA							Height 	= ValueB						else							Offset 	= ValueB							Height 	= ValueA						endif						Data -= Offset												Data *= (TotalIntensity/Height)												Print " 		Intensity normalized",NameOfWave(Data),". Subtracted an offset",Offset,"and scaled by",(TotalIntensity/Height)					endif				endif			endif		endfor				// This //		RevertOrSavePlottedData(WindowName,"_all_",0)	SetDataFolder $(OldDF)End// ***************************************************************************// **************** 				Differentiate and Integrate Left-Plotted Data// ***************************************************************************Function TransformPlotAxisAndData(PlotName,Selection,TransformFlag)	String PlotName, Selection	Variable TransformFlag		Variable i, NumTraces, TraceIndex		if (cmpstr("_all_",Selection) == 0)		NumTraces = ItemsInList(TraceNameList(PlotName,";",1))		for (i=0;i<NumTraces;i+=1)			WAVE Axis = WaveRefIndexed(PlotName,i,2)			WAVE Data	= WaveRefIndexed(PlotName,i,1)						if (!TraceIsSpecial(NameOfWave(Data)))				ApplyTransformToAxisAndData(Axis,Data,TransformFlag)			endif		endfor			else		// Find the index of the plotted trace based on the selection. 		TraceIndex = WhichListItem(Selection,TraceNameList(PlotName, ";", 1))		WAVE Axis = WaveRefIndexed(PlotName,TraceIndex,2)		WAVE Data	= WaveRefIndexed(PlotName,TraceIndex,1)				ApplyTransformToAxisAndData(Axis,Data,TransformFlag)	endifEndFunction ApplyTransformToAxisAndData(Axis,Data,TransformFlag)	Wave Axis,Data	Variable TransformFlag		if (TransformFlag == 1)		Differentiate Data /X=Axis	else		if ((TransformFlag ==2) || (TransformFlag == 3))			Variable NPts = DimSize(Axis,0)		//		// Make an integration axis with an extra end point//		Variable NPts = DimSize(Axis,0)//		Variable offset = Axis[NPts-1]//		Variable step = Axis[NPts-1] - Axis[NPts-2]//		//		Make/FREE/D/N=(NPts+1) Axis2//		Axis2[NPts] = Axis2[NPts-1] + step									if (TransformFlag == 2)				print "Integration from zero to infinity"				Integrate /METH=1 Data /X=Axis							elseif (TransformFlag == 3)				print "Integration from infinity to zero"								Axis *=-1				Reverse Axis, Data				Variable offset = Axis[0]				Axis -= offset								Integrate /METH=1 Data /X=Axis								Axis *=-1				Reverse Axis, Data//				offset = Axis[0]				Axis -= offset			endif		endif	endifEnd// ***************************************************************************// **************** 				// ***************************************************************************Function Average2DData(DataList, DataSel, DataGroup,AverageAllFlag)	Wave DataSel, DataGroup	Wave /T DataList	Variable AverageAllFlag		Variable i, n=1, first=0, NSel		String DataName, DataFolder, TwoDFolder, DataNote, SampleNote, SampleName	String Averaged="", Skipped=""		// Find the name of the first selected data	NSel 	= (AverageAllFlag) ? FindSelectedData(DataSel) : 0	DataName 				= ReplaceString("_data",DataList[NSel],"")	TwoDFolder 			= "root:SPECTRA:Data:Load" + num2str(DataGroup[i]) + ":TwoD"	WAVE DataMatrix 		= $(ParseFilePath(2,TwoDFolder,":",0,0) + DataName + "_2D")		Variable AvgChoice	Prompt AvgChoice, "Average or stack?", popup, "average;stack;"	String AvgName = DataName + "_avg"	Prompt AvgName, "Name of new data"	DoPrompt "Processing 2D images", AvgChoice, AvgName	if (V_flag)		return 0	endif		if (AvgChoice == 2)		NSel 	= (AverageAllFlag) ? DimSize(DataSel,0) : sum(DataSel)	endif		for (i=0;i<numpnts(DataSel);i+=1)		if (((DataSel[i]&2^0) != 0) || ((DataSel[i]&2^3) != 0) || (AverageAllFlag))					DataName 				= ReplaceString("_data",DataList[i],"")			DataFolder 			= "root:SPECTRA:Data:Load" + num2str(DataGroup[i])			TwoDFolder 			= "root:SPECTRA:Data:Load" + num2str(DataGroup[i]) + ":TwoD"						WAVE DataMatrix 		= $(ParseFilePath(2,TwoDFolder,":",0,0) + DataName + "_2D")			WAVE Axis1 			= $(ParseFilePath(2,DataFolder,":",0,0) + DataName + "_axis")			WAVE Axis2 			= $(ParseFilePath(2,TwoDFolder,":",0,0) + DataName + "_axis2")						if (WaveExists(DataMatrix))				if (first==0)					SampleNote 	= Note(DataMatrix)					SampleName 	= AvgName					Averaged 		= DataName + ";"					Duplicate /D/FREE DataMatrix, AvgMatrix					Duplicate /D/FREE DataMatrix, StackMatrix					if (AvgChoice == 2)						Redimension /D/N=(-1,-1,NSel) StackMatrix					endif					first =1				else					if (EqualWaves(DataMatrix, AvgMatrix,512))						Averaged 	= Averaged + DataName + ";"						if (AvgChoice == 1)							AvgMatrix += DataMatrix						elseif (AvgChoice == 2)							StackMatrix[][][n] = DataMatrix[p][q]						endif						n += 1					else						Skipped	= Skipped + DataName + ";"					endif				endif						endif		endif	endfor		if (n>1)		AvgMatrix /= n		Redimension /N=(-1,-1,n) StackMatrix				if (AvgChoice == 1)			DataNote 	= "An average of "+num2str(n)+" 2D matrices. Averaged data are:\r"+Averaged+"\r"			DataNote 	= DataNote + SampleNote						LoadSingle2DPlot(SampleName,DataNote,AvgMatrix,Axis2,Axis1)		else			Duplicate /O StackMatrix, $("root:"+SampleName)		endif				if (ItemsInList(Skipped) > 0)			Print " 		***  Excluded the following data from the average because of dimension mismatch:  ",Skipped		endif	endifEnd// This is called from the Data Plotting Panel. I don't use it that much, actually. // For simplicity, only allow this for data with identical axes. Function AverageSelectedData(DataList, DataSel, DataGroup, AverageAllFlag)	Wave DataSel, DataGroup	Wave /T DataList	Variable AverageAllFlag		NewDataFolder /O root:SPECTRA:Serial		Variable i, AxisTolerance, ReportFlag=1, NSelected=0	String AvgFolderName = "root:SPECTRA:Serial"	String AxisAndFolderName, DataName, DataAndFolderName, FolderStem = "root:SPECTRA:Data:Load"	String OmittedList="", AvgName		// first check common axes	for (i=0;i<numpnts(DataSel);i+=1)		if (((DataSel[i]&2^0) != 0) || ((DataSel[i]&2^3) != 0) || (AverageAllFlag))			DataName				= DataList[i]			DataAndFolderName	= FolderStem + num2str(DataGroup[i]) + ":" + DataName			AxisAndFolderName	= AnyNameFromDataName(DataAndFolderName,"axis")						NSelected +=1			if (NSelected == 1)								AvgName 	= ReplaceString("_data",DataName,"")+"_AVG"				Prompt AvgName, "Name of first data in selection"				Prompt ReportFlag, "List averaged waves?", popup, "no;yes;"				Prompt AxisTolerance, "Axis values precision"				DoPrompt "Please enter the name for the averaged data", AvgName,ReportFlag, AxisTolerance				if (V_Flag)					return -1				endif								Duplicate /O $AxisAndFolderName, $("root:SPECTRA:Serial:AvgAxis")				Duplicate /O $DataAndFolderName, $("root:SPECTRA:Serial:AvgData")								WAVE AvgAxis 	= $("root:SPECTRA:Serial:AvgAxis")				WAVE AvgData 	= $("root:SPECTRA:Serial:AvgData")			else				WAVE Axis 		= $AxisAndFolderName				WAVE Data 		= $DataAndFolderName								if (!EqualWaves(AvgAxis,Axis,1,AxisTolerance))					OmittedList 	= OmittedList + DataName + ";"					NSelected -=1				else					if (ReportFlag ==2)						Print " 		...  including",ReplaceString("_data",DataName,""),"in average."					endif					AvgData += Data				endif			endif		endif	endfor		if (NSelected < 2)		Print " 	*** No data selected for averaging"	else		AvgData /= NSelected		AdoptAxisAndDataFromMemory("AvgAxis","null",AvgFolderName,"AvgData","null",AvgFolderName,AvgName,"",0,0,1)				if (ItemsInList(OmittedList) > 0)			Print " 		***  Excluded the following data from the average because of axis mismatch relative to",ReplaceString("_data",AvgName,""),":  ",OmittedList		endif	endifEnd// ***************************************************************************// **************** 				Average Left-Plotted Data// ***************************************************************************Function AverageLeftPlottedData(WindowName)	String WindowName	//	String PlotFolderName 	= "root:SPECTRA:Plotting:" + WindowName	String AvgFolderName	= "root:SPECTRA:Plotting:Averaging"	SVAR gLeftPlottedList 	= $(PlotFolderName+":gLeftPlottedList")	SVAR gSelection1 			= $(PlotFolderName+":gSelection1")			String AxesInfo, AxisName, AxisAndFolderName, DataName, DataAndFolderName, DataNameList	Variable i, LogFlag, SameAxes, AxisMin, AxisMax, AxisStep, AxisPts	Variable NumAvgd, SumChoice, NumTraces=ItemsInList(TraceNameList(WindowName, ";", 1),";")		if (NumTraces<2)		DoAlert 0, "Need to plot more than 1 trace to average them!"		return 0	endif		AxesInfo 	= PlotAxesInfo(WindowName)	LogFlag 	= NumberByKey("log(x)", AxisInfo(WindowName,"bottom"),"=")	SameAxes	= NumberByKey("SameAxes",AxesInfo,"=",";")	AxisMin	= NumberByKey("AxisMin",AxesInfo,"=",";")	AxisMax	= NumberByKey("AxisMax",AxesInfo,"=",";")	AxisStep	= NumberByKey("AxisStep",AxesInfo,"=",";")		String DfSelectAxis	= gSelection1	String DfAvgName 	= gSelection1	if ((cmpstr("_all_",gSelection1) == 0) || (cmpstr("_none_",gSelection1) == 0))		DfSelectAxis	= "automatic"		DfAvgName		= StringFromList(0,gLeftPlottedList)	endif		String AvgName=ReplaceString("_AVG",ReplaceString("_data",DfAvgName,""),"")+"_AVG"	Prompt AvgName,"Averaged name"	Prompt SumChoice, "Sum or average?", popup, "average;sum;"	String SelectAxis = DfSelectAxis	Prompt SelectAxis, "Choose the axis for interpolation", popup, "automatic;" + gLeftPlottedList	if (SameAxes == 1)		SelectAxis	=  StringFromList(0,gLeftPlottedList)		DoPrompt "Please enter the name for the averaged data", AvgName,SumChoice	else		DoPrompt "Please enter averaging parameters", AvgName,SumChoice,SelectAxis	endif	if (V_Flag)		return -1	endif	String OldDF = getDataFolder(1)	SetDataFolder root:SPECTRA:Plotting	NewDataFolder /O/S root:SPECTRA:Plotting:Averaging		KillWaves /Z/A		if ((SameAxes == 0) && (cmpstr("automatic",SelectAxis) == 0))			// AUTOMATIC GENERATION OF THE COMMON AXIS			if (LogFlag == 0)				AxisPts = abs(AxisMax-AxisMin)/AxisStep + 2			else				AxisPts = abs(log(AxisMax)-log(AxisMin))/AxisStep + 2			endif						if ((AxisPts > 10000) && (LogFlag == 0))				DoAlert 1,"Automatical interpolation will require >10,000 data points. See Command Window. Proceed? "				if (V_flag == 2)					if (AxisMin > 0)						Print " *** The axis step size may be constant on a logarithmic scale. Try plotting with a log x-axis and try again."					else						Print " *** The axes contain negative values, so they cannot be spaced logarithmically"					endif					SetDataFolder root:					return 0				endif			elseif (AxisPts < 10)				DoAlert 1,"Less than 10 data points. Proceed?"				if (V_flag == 2)					SetDataFolder root:					return 0				endif			endif						if (LogFlag == 0)				Print " *** Averaging data onto a new axis ranging from",AxisMin,"to",AxisMax,"with",AxisPts,"points and a step",AxisStep			else				Print " *** Averaging data onto a new logarithmically spaced axis ranging from",AxisMin,"to",AxisMax,"with",AxisPts,"points and a step 10^",AxisStep			endif			Make /O/D/N=(AxisPts) $(AvgName+"_data"), $(AvgName+"_axis")			WAVE AvgAxis	= $(AvgName+"_axis")						if (LogFlag == 0)				AvgAxis[] = AxisMin + AxisStep*x			else				AvgAxis[] = log(AxisMin) + AxisStep*x				AvgAxis[] = 10^AvgAxis[p]			endif		else			// USER SELECTS A COMMON AXIS			Print " *** Averaging data using the axis from",ReplaceString("_data",SelectAxis,"")			Duplicate /O/D XWaveRefFromTrace(WindowName, SelectAxis), $(AvgName+"_data"), $(AvgName+"_axis")		endif				WAVE AvgAxis	= $(AvgFolderName+":"+AvgName+"_axis")		WAVE AvgData	= $(AvgFolderName+":"+AvgName+"_data")				AvgData = 0		Sort AvgAxis, AvgAxis		Duplicate /O/D AvgData, $(AvgName+"_data_sig"), $(AvgName+"_axis_sig")		WAVE AvgDataErrors	= $(AvgName+"_data_sig")					PlotDataTo2DMatrix(WindowName,AvgName+"_axis",AxisMin, AxisMax, AxisStep)		WAVE PlotDataMatrix	= PlotDataMatrix				Make /O/D/N=(NumTraces) PtAvg				AxisPts = numpnts(AvgAxis)				for (i=0; i<AxisPts;i+=1)			PtAvg[0,NumTraces-1] = PlotDataMatrix[i][p]			WaveStats /Q PtAvg			if (SumChoice == 2)				AvgData[i] = V_avg * V_npnts				AvgDataErrors[i] = V_sem * V_npnts			else				AvgData[i] = V_avg				AvgDataErrors[i] = V_sem			endif		endfor				DataNameList 	= TraceNameList(WindowName,",",1)				NumAvgd		= ItemsInList(DataNameList,",")		Note /K AvgData, "An average of the following "+num2str(NumAvgd)+" data:\r"		for (i=0;i<=NumAvgd;i+=1)			if (mod(5,i) == 0)				Note AvgData, StringFromList(i,DataNameList,",")			else				Note /NOCR AvgData, StringFromList(i,DataNameList,",")			endif		endfor				AdoptAxisAndDataFromMemory(AvgName+"_axis",AvgName+"_axis_sig",AvgFolderName,AvgName+"_data",AvgName+"_data_sig",AvgFolderName,AvgName,"",0,0,1)		KillWaves /Z/A 		SetDataFolder $(OldDF)End// ***************************************************************************// **************** 				Interpolate Left-Plotted Data// ***************************************************************************Function InterpolateLeftPlottedData(WindowName)	String WindowName		String PlotFolderName 	= "root:SPECTRA:Plotting:" + WindowName	String AvgFolderName	= "root:SPECTRA:Plotting:Averaging"	SVAR gLeftPlottedList 	= $(PlotFolderName+":gLeftPlottedList")	SVAR gSelection1 			= $(PlotFolderName+":gSelection1")		String AxesInfo, InterpAxisChoice, AxisAndFolderName, DataName, DataAndFolderName, DataNameList	Variable i, LogFlag, SameAxes, AxisMin, AxisMax, AxisStep, AxisPts, NTraces, NewWaveFlag=1		AxesInfo 	= PlotAxesInfo(WindowName)	LogFlag 	= NumberByKey("log(x)", AxisInfo(WindowName,"bottom"),"=")	SameAxes	= NumberByKey("SameAxes",AxesInfo,"=",";")	AxisMin	= NumberByKey("AxisMin",AxesInfo,"=",";")	AxisMax	= NumberByKey("AxisMax",AxesInfo,"=",";")	AxisStep	= NumberByKey("AxisStep",AxesInfo,"=",";")	NTraces 	=ItemsInList(TraceNameList(WindowName, ";", 1),";")		Variable InterpStepOrPoints, ReportFlag=1		if (NTraces == 1)		InterpAxisChoice 	= "new axis"		Prompt InterpAxisChoice, "Must create a new axis", popup, "new axis;"	else		InterpAxisChoice 	= gSelection1		Prompt InterpAxisChoice, "Select axis source", popup, "new axis;"+gLeftPlottedList	endif		if (LogFlag == 0)		// New linear axes will be created with a constant step		InterpStepOrPoints 	= AxisStep		Prompt InterpStepOrPoints, "Axis step"	else		// New linear axes will be created with a constant scale factor to achieve desired number of points		InterpStepOrPoints 	= 128		Prompt InterpStepOrPoints, "# points"	endif		String InterpChoice="linear"	Prompt InterpChoice, "Choose interp style",popup,"linear;cubic;smoothing;"		Variable InterpAxisMin 	= AxisMin	Prompt InterpAxisMin, "Min axis value"	Variable InterpAxisMax 	= AxisMax	Prompt InterpAxisMax, "Max axis value"	DoPrompt "Interpolate the plotted data", InterpAxisChoice, InterpAxisMin, InterpAxisMax, InterpStepOrPoints,InterpChoice	if (V_flag)		return 0	endif		if (cmpstr(InterpAxisChoice,"new axis") == 0)		Make /FREE/D/N=128 NewAxis, NewData		if (LogFlag)			MakeNewLogAxis(NewAxis,1, InterpAxisMin, InterpAxisMax, InterpStepOrPoints,ReportFlag)		else			MakeNewLinearAxis(NewAxis,InterpAxisMin, InterpAxisMax, InterpStepOrPoints,ReportFlag)		endif		ReDimension /N=(numpnts(NewAxis)) NewAxis, NewData	else		// Select an axis for interpolation onto		Print " *** Interpolating plotted data using the axis from",ReplaceString("_data",InterpAxisChoice,"")		Duplicate /FREE/D XWaveRefFromTrace(WindowName, InterpAxisChoice) NewAxis, NewData		if (!CheckMonotonic(NewAxis))			DoAlert 0, "The axis of the selected wave is not monotonic. \rPlease choose another axis, or create a new one."			return 0		endif	endif		// Now interpolate all the plotted traces. 	for (i=0;i<NTraces;i+=1)		DataAndFolderName 	= GetWavesDataFolder(WaveRefIndexed(WindowName,i,1), 2)		WAVE Data = $DataAndFolderName				AxisAndFolderName 	= GetWavesDataFolder(WaveRefIndexed(WindowName,i,2), 2)		WAVE Axis = $AxisAndFolderName				if (!TraceIsSpecial(NameOfWave(Data)))			// First ensure there are no NANs in the input waves			Duplicate /FREE/D Axis, tempAxis			Duplicate /FREE/D Data, tempData			StripNANsFromWaveAxisPair(tempData,tempAxis)						if (cmpstr(InterpChoice,"linear") == 0)				Interpolate2/T=1/I=3/Y=NewData/X=NewAxis tempAxis, tempData			elseif (cmpstr(InterpChoice,"cubic") == 0)			elseif (cmpstr(InterpChoice,"smoothing") == 0)				Interpolate2/T=3/I=3/F=0/Y=NewData/X=NewAxis tempAxis, tempData//				Interpolate2/T=3/I=3/F=1/S=2e-5/Y=NewData/X=NewAxis tempAxis, tempData			endif						ReDimension /N=(numpnts(NewAxis)) Axis, Data			Axis 	= NewAxis			Data 	= NewData		endif	endforEndInterpolate2/T=3/N=500/F=1/S=1e-05/Y=s10CV_CV01_int_data_SS s10CV_CV01_int_axis, s10CV_CV01_int_dataFunction MakeNewLinearAxis(NewAxis,AxisMin, AxisMax, AxisStep,ReportFlag)	Wave NewAxis	Variable AxisMin, AxisMax, AxisStep, ReportFlag		Variable AxisPts		AxisPts = abs(AxisMax-AxisMin)/AxisStep + 2		if (AxisPts > 10000)		DoAlert 1,"Create axis with "+num2str(AxisPts)+" data points?"		if (V_flag == 2)			return 0		endif	endif		Redimension /N=(AxisPts) NewAxis		NewAxis = AxisMin + AxisStep*p		if (ReportFlag == 1)		Print " *** Creating a new axis ranging from",AxisMin,"to",AxisMax,"with",AxisPts,"points and a step",AxisStep	endif		return 1End// 	*** Notes about creating logarithmically spaced axes. // 		Don't want to TRANSFORM the axis so that we actually take the log of the axis values// 		Do want to simply space the actual values so that they are evenly distributed when plotted on a log scale////		The fundamental relationship is: // 				x_n 	= C * x_n-1// To find the log axis value scale factor given the AxisMin, AxisMax and total number of pointsFunction FindLogAxisScaleFactor1(AxisMin, AxisMax,AxisNPts)	Variable AxisMin, AxisMax,AxisNPts		return 10^(log(AxisMax/AxisMin)/(AxisNPts-1))End// To find the log axis value scale factor given the number of points per decadeFunction FindLogAxisScaleFactor2(PtsPerDecade)	Variable PtsPerDecade		return 10^(1/(PtsPerDecade-1))End// To find the number of points in a log axis the axis range and the scale factorFunction FindLogAxisNumPoints(AxisMin, AxisMax,AxisScale)	Variable AxisMin, AxisMax,AxisScale		return 1 + (log(AxisMax/AxisMin)/log(AxisScale))EndFunction MakeNewLogAxis(NewAxis,AxisChoice, AxisMin, AxisMax, AxisPoints,ReportFlag)	Wave NewAxis	Variable AxisChoice, AxisMin, AxisMax, AxisPoints, ReportFlag		Variable AxisPts, AxisScale		if ((AxisMin < 0) || (AxisMax < 0))		if (ReportFlag == 1)			Print " *** The axes contain negative values, so they cannot be spaced logarithmically"		endif		return 0	endif		if (AxisChoice == 1)		// Create axis based on min, max and total number of points		AxisScale 	= FindLogAxisScaleFactor1(AxisMin, AxisMax,AxisPoints)		AxisPts 	= AxisPoints			elseif (AxisChoice == 2)		// Create axis based on min, max and number of points per decade		AxisScale = FindLogAxisScaleFactor2(AxisPoints)		AxisPts 	= FindLogAxisNumPoints(AxisMin, AxisMax,AxisScale)	endif		Redimension /N=(AxisPts) NewAxis		NewAxis[] = (AxisScale^p) * AxisMin		if (ReportFlag == 1)		Print " *** Creating a new logarithmically spaced axis ranging from",AxisMin,"to",AxisMax,"with",AxisPts,"points"	endif		return 1End//	+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++////						THE FOLLOWING ROUTINES HAVE NOT BEEN MODIFIED FOR NEW SPECTRA MACROS////	+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++// ***************************************************************************// **************** 				INTERPOLATION// ***************************************************************************// This function OVERWRITES the original data and axis. Proc InterpolateDataOntoOneAxis(Data1Name,Data2Name,cAxisChoice,AxisCreateFlag)	String Data1Name	Prompt Data1Name, "Choose the first data curve", popup, WaveList("*_data",";","")	String Data2Name	Prompt Data2Name, "Choose the second data curve", popup, WaveList("*_data",";","")	String cAxisChoice	Prompt cAxisChoice, "Select the common axis", popup, "Auto create;First axis;Second axis;" + WaveList("*_axis",";","")	Variable AxisCreateFlag	Prompt AxisCreateFlag, "Check automatic axis creation?", popup, "no;yes;"	PauseUpdate; Silent 1		String Axis1Name, Axis2Name, Axis1SaveName, Axis2SaveName, Data1SaveName, Data2SaveName	Variable NumPts		// Ideally I would save the original data into some data folder. 		// The first data set. 	Data1SaveName = Data1Name + "_save"	Duplicate /O $Data1Name, $Data1SaveName	Axis1Name = ReplaceTextInString(Data1Name,"_data","_axis")	Axis1SaveName = Axis1Name + "_save"	Duplicate /O $Axis1Name, $Axis1SaveName		//The second data set	Data2SaveName = Data2Name + "_save"	Duplicate /O $Data2Name, $Data2SaveName	Axis2Name = ReplaceTextInString(Data2Name,"_data","_axis")	Axis2SaveName = Axis2Name + "_save"	Duplicate /O $Axis2Name, $Axis2SaveName		// Make the correct common axis	if (cmpstr("First axis",cAxisChoice) == 0)		Duplicate /O $Axis1Name, cAxis	else		if (cmpstr("Second axis",cAxisChoice) == 0)			Duplicate /O $Axis2Name, cAxis		else			if (cmpstr("Auto create",cAxisChoice) == 0)				AutoMakeCommonAxis($Axis1Name, $Axis2Name, "cAxis",AxisCreateFlag-1)			else				Duplicate /O $cAxisChoice, cAxis			endif		endif	endif		InterpolateDataOnCommonAxis($Data1SaveName,$Axis1SaveName,$Data2SaveName,$Axis2SaveName,cAxis, Data1Name,Data2Name)		Duplicate /O cAxis, $Axis1Name, $Axis2Name	KillWaves /Z cAxisEnd	// ***************************************************************************// **************** 				Commonly used string routines// ***************************************************************************Function /T ReturnDataLoadFolder(DataNum)	Variable DataNum		WAVE wDataGroup	= root:SPECTRA:wDataGroup	return "root:SPECTRA:Data:Load" + num2str(wDataGroup[DataNum])EndFunction /T DataFolderNameFromDataName(DataName)	String DataName		WAVE /T wDataList 	= root:SPECTRA:wDataList		String DataList		= ReplaceString("_data",TextWaveToList(wDataList,0,"",""),"")	Variable DataNum 	= WhichListItem(ReplaceString("_data",DataName,""),DataList)		return ReturnDataLoadFolder(DataNum)EndFunction /T AnyNameFromDataName(DataName,AnySuffix)	String DataName, AnySuffix		String Suffix 			= ReturnLastSuffix(DataName,"_")//	String ResidsName 	= ReplaceString("_"+Suffix,DataName,"_"+AnySuffix)	String ResidsName 	= ReplaceString("_"+Suffix,DataName,"")	ResidsName 	= ResidsName + "_" + AnySuffix	return ResidsNameEndFunction /T SampleNameFromDataName(DataName)	String DataName		String Suffix 		= ReturnLastSuffix(DataName,"_")	String SampleName 	= ReplaceString("_"+Suffix,DataName,"")	return SampleNameEndFunction /T AxisNameFromDataName(DataName)	String DataName		return AnyNameFromDataName(DataName,"axis")EndFunction /T FitNameFromDataName(DataName)	String DataName		return AnyNameFromDataName(DataName,"fit")EndFunction /T ResidsNameFromDataName(DataName)	String DataName		return AnyNameFromDataName(DataName,"res")End