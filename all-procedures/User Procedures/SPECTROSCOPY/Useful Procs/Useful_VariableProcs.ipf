#pragma rtGlobals=1		// Use modern global access method.Function MonthNameToNumber(month)	String month		Variable number		if (stringmatch(month,"Jan*") == 1)		number = 1	elseif (stringmatch(month,"Feb*") == 1)		number = 2	elseif (stringmatch(month,"Mar*") == 1)		number = 3	elseif (stringmatch(month,"Apr*") == 1)		number = 4	elseif (stringmatch(month,"May*") == 1)		number = 5	elseif (stringmatch(month,"Jun*") == 1)		number = 6	elseif (stringmatch(month,"Jul*") == 1)		number = 7	elseif (stringmatch(month,"Aug*") == 1)		number = 8	elseif (stringmatch(month,"Sep*") == 1)		number = 9	elseif (stringmatch(month,"Oct*") == 1)		number = 10	elseif (stringmatch(month,"Nov*") == 1)		number = 11	elseif (stringmatch(month,"Dec*") == 1)		number = 12	endif		return numberEnd// 	input:    hrs:mins:secsFunction TimeStr2Secs(TimeStr)	String TimeStr		Variable hrs, mins, secs		hrs 	= str2num(StringFromList(0,TimeStr,":"))	mins 	= str2num(StringFromList(1,TimeStr,":"))	secs 	= str2num(StringFromList(2,TimeStr,":"))		return (60*60*hrs) + (60*mins) + secsEnd// input: 06:27:13 PM (not 24-hour clock)// Return the number of second since midnight: 12:00:00 AMFunction Time2Secs(hrs,mins,secs,AMPM)	Variable hrs,mins,secs	String AMPM		// This sets the hour from 12:00 to 12:59 AM or PM to 00:00 to 00:59 	hrs 	= mod(hrs,12)		// This converts to a 24-hour clock, and takes care of 1:00 PM to 11:59 PM	if (cmpstr(AMPM,"PM") == 0)		hrs += 12	endif		return (60*60*hrs) + (60*mins) + secsEnd// 	input:    year-month-dayFunction DateStr2Secs(DateStr)	String DateStr		Variable year, month, day		year 	= str2num(StringFromList(0,DateStr,"-"))	month 	= str2num(StringFromList(1,DateStr,"-"))	day 	= str2num(StringFromList(2,DateStr,"-"))		return date2secs(year,month,day)End// If VarName includes an existing data folder, it will workFunction MakeVariableIfNeededDF(FolderRef,VarName,DefaultVal)	DFRef FolderRef	String VarName	Variable DefaultVal		NVAR Var = FolderRef:$VarName	if (NVAR_exists(Var) == 0)		Variable /G FolderRef:$VarName=DefaultVal	elseif (numtype(Var) != 0)		Var=DefaultVal	endifEnd// If VarName includes an existing data folder, it will workFunction MakeVariableIfNeeded(VarName,DefaultVal)	String VarName	Variable DefaultVal		NVAR Var = $VarName	if (NVAR_exists(Var) == 0)		Variable /G $VarName=DefaultVal	elseif (numtype(Var) != 0)		Var=DefaultVal	endifEndFunction MakeStringIfNeeded(StrName,DefaultStr)	String StrName, DefaultStr		if (exists(StrName) == 0)		String /G $StrName=DefaultStr	endifEndFunction DuplicateVar(Var1Str,Var2Str)	String  Var1Str, Var2Str		NVAR Var1 = $Var1Str	if (NVAR_Exists(Var1))		MakeVariableIfNeeded(Var2Str,0)		NVAR Var2 	= $Var2Str		Var2 = Var1	endifEnd// ***************************************************************************// **************** 			Creating, Sorting, Merging, Compressing lists// ***************************************************************************// PossiblyQuoteList(list, separator)//	Input is a list of names that may contain liberal names.//	The input list is expected to be a standard separated list, like "wave0;wave1;wave2;".//	Returns the list with liberal names quoted.//	Example://		Input:		"wave0;wave 1;"//		Output:		"wave0;'wave 1';"Function/S PossiblyQuoteList(list, separator)		// Added in version 1.1 of this file.	String list	String separator		String item, outputList = ""	Variable i= 0	Variable items= ItemsInList(list, separator)	do		if (i >= items)			// no more items?			break		endif		item= StringFromList(i, list, separator)		outputList += PossiblyQuoteName(item) + separator		i += 1	while(1)	return outputListEndFunction /T ListFromLine(SPECLine, ColSpace)	String SPECLine, ColSpace	String LineAsList, lastChar		// Remove any line termination characters	LineAsList 	= ReplaceString("\r",SPECLine,"")	LineAsList 	= ReplaceString("\n",LineAsList,"")		// Change the column separators into list separators	LineAsList 	= ReplaceString(ColSpace,LineAsList,";")		// Ensure the last list item is terminated	Variable nChars = strlen(LineAsList)	lastChar = LineAsList[nChars-1]	if (cmpstr(lastChar,";") != 0)		LineAsList = LineAsList + ";"	endif	//	LineAsList 	= StripTrailingChars(LineAsList,";")		return LineAsListEnd// Remove duplicated list items. Function /T CompressList(List,SortFlag)	String List	Variable SortFlag		String ListItem, NewList = ""	Variable i, n = ItemsInList(List)		if (n == 0)		return ""	else				for (i=0;i<n;i+=1)			ListItem = StringFromList(i,List)			if (WhichListItem(ListItem,NewList) == -1)				if (strlen(ListItem) > 0)					NewList += ListItem + ";"				endif			endif		endfor				if (SortFlag == 1)			NewList = SortList(NewList,";",2)		endif				return NewList	endifEndFunction /T MergeTwoLists(List1,List2)	String List1,List2		String List2Item	Variable i, StrItems = ItemsInList(List2)		for (i=0;i<StrItems;i+=1)		List2Item = StringFromList(i,List2)		if (WhichListItem(List2Item,List1) == -1)			List1 += List2Item + ";"		endif	endfor	return List1EndFunction /T TruncateList(List,Char,NewNItems)	String List, Char	Variable NewNItems		Variable i, NItems=ItemsInList(List,Char)		for (i=(NItems-1);i>(NewNItems-1);i-=1)		List 	= RemoveListItem(i, List, Char)	endfor		return ListEndFunction /T SortListByKey(DataList, GroupList)	String DataList, GroupList		Variable NItems = ItemsInList(DataList)		Make /O/T/N=(NItems) tListWave	Make /O/N=(NItems) tKeyWave		tListWave[]	= StringFromList(p,DataList)	tKeyWave[] 	= str2num(StringFromList(p,GroupList))		Sort tKeyWave, tKeyWave, tListWave		String SortedList = TextWaveToList(tListWave,0,"","")		KillWaves /Z tListWave, tKeyWave		return SortedListEndFunction CountItemsInList(List,Item,Char)	String List,Item,Char		String ListItem	Variable i, nItems=0, n=ItemsInList(List,Char)		for (i=0;i<n;i+=1)		ListItem = StringFromList(i,List,Char)		if (cmpstr(Item,ListItem) == 0)			nItems += 1		endif	endfor		return nItemsEndFunction ExtremumValueInList(List,MaxFlag)	String List	Variable MaxFlag		Variable i, NItems, ExtremeVal, NewVal		NItems = ItemsinList(List)	i=-1	do						// Find the first number in the list		i+=1		if (i == NItems)			return NAN	// No numbers in the list		endif		ExtremeVal = str2num(StringFromList(i,List))	while(numtype(ExtremeVal) != 0)			do		i+=1		NewVal = str2num(StringFromList(i,List))		if (numtype(NewVal) == 0)			if (MaxFlag == 1)					// Look for maximum value				if (NewVal > ExtremeVal)					ExtremeVal = NewVal				endif			else									// Look for minimum value				if (NewVal < ExtremeVal)					ExtremeVal = NewVal				endif			endif		endif	while(i<NItems)		return ExtremeValEnd// ***************************************************************************// **************** 			Finding strings in lists// ***************************************************************************// Find the first list item with a match to a search stringFunction WhichMatchListItem(List,MatchStr,Char)	String List,MatchStr,Char		String ListItem, MatchList = InclusiveWaveList(List,MatchStr,Char)		if (ItemsInList(MatchList) == 0)		return -1	elseif (strlen(MatchStr) == 0)		return -1	else	// Return only the first in case of several matches		ListItem = StringFromList(0,MatchList,Char)				return WhichListItem(ListItem,List,Char)	endifEndFunction WhichMatchListItemSuffix(List,Suffix,SfxSepStr)	String List,Suffix,SfxSepStr	Variable n, i	String ListItem, ItemSuffix		n= ItemsInList(List)		for (i=0;i<n;i+=1)			ListItem = StringFromList(i,List)		if (StrSearch(ListItem,SfxSepStr,0) > -1)			ItemSuffix =  ParseFilePath(0, ListItem, SfxSepStr, 1, 0)			if (cmpstr(Suffix,ItemSuffix) == 0)				return i			endif		endif	endforEnd// Removes items from a wavelist that DO contain a certain string. Function /T ExclusiveWaveList(InputList,ExcludeStr,Char)	String InputList,ExcludeStr, Char		if (strlen(ExcludeStr) == 0)		return InputList	else		return GrepList(InputList,"(?i)"+ReplaceString("*",ExcludeStr,""),1,Char)	endifEnd// Removes items from a wavelist that DO NOT contain a certain string. Function /T InclusiveWaveList(InputList,IncludeStr,Char)	String InputList,IncludeStr, Char		return GrepList(InputList,"(?i)"+ReplaceString("*",IncludeStr,""),0,Char)End// Useful: Accepts a list of strings to remove from another input stringFunction /T StripStringItemsFromText(ItemList,Text)	String ItemList, Text		String Item	Variable i, Num=ItemsInList(ItemList)		for (i=0;i<Num;i+=1)		Item	= StringFromList(i,ItemList)		Text 	= ReplaceString(Item,Text,"")	endfor	return TextEnd// ***************************************************************************// **************** 			Test a String for a list of KeyWords// ***************************************************************************// 	Returns TRUE if any keywords are matched. Function CheckKeyWordsinString(Str,KeyWordList)	String Str,KeyWordList		String matchStr	Variable i, NKeyWords=ItemsInList(KeyWordList)		if (NKeyWords == 0)		return 1	endif		// First, return a NEGATIVE MATCH if any unwanted strings are present	for (i=0;i<NKeyWords;i+=1)		matchStr 	= StringFromList(i,KeyWordList)				if (StrSearch(matchStr,"!",0) > -1)			if (StringMatch(Str,matchStr) == 0)				return 0				break			endif		endif	endfor		// Now return a POSITIVE MATCH if any match-strings are present. 	for (i=0;i<NKeyWords;i+=1)		matchStr 	= StringFromList(i,KeyWordList)				if (StrSearch(matchStr,"!",0) == -1)			if (StringMatch(Str,matchStr) == 1)				return 1				break			endif		endif	endfor		return 0End// ***************************************************************************// **************** 			Some routines that act on all items in a list. // ***************************************************************************Function /T StripLeadingCharsFromList(InputList,Char)	String InputList,Char	Variable n, i	String ListItem, OutputList=""		n= ItemsInList(InputList)	for (i=0;i<n;i+=1)		ListItem = StringfromList(i,InputList,";")		OutputList += StripLeadingChars(ListItem,Char)		OutputList += ";"	endfor		return OutputListEndFunction /T StripTrailingCharsFromList(InputList,Char)	String InputList,Char	Variable n, i	String ListItem, OutputList=""		n= ItemsInList(InputList)	for (i=0;i<n;i+=1)		ListItem = StringfromList(i,InputList,";")		OutputList += StripTrailingChars(ListItem,Char)		OutputList += ";"	endfor		return OutputListEndFunction /T StripCharsFromList(List,Char)	String List,Char		return ReplaceString(Char, List, "")End// ***************************************************************************// **************** 			Suffix routines// ***************************************************************************Function /T AddPrefixOrSuffixToListItems(InputList,Prefix,Suffix)	String InputList,Prefix,Suffix		Variable n, i	String ListItem, OutputList=""		n= ItemsInList(InputList)	for (i=0;i<n;i+=1)		ListItem = Prefix + StringfromList(i,InputList,";") + Suffix		OutputList += ListItem		OutputList += ";"	endfor		return OutputListEnd// * Updated Jan 09. ParseFilePath is not useful here. // Separator can be one or more chars. // In case of several Separators, on the last is removed. Function /T StripSuffixBySeparator(NameString,Separator)	String NameString,Separator		// Searching backwards from end unti we match the one or more chars in Separator	Variable Index = StrSearch(NameString,Separator,Inf,1)		if (Index == -1)		// The suffix does not appear		return NameString	else		// The suffix does appear, so strip it. 		return NameString[0,Index-1] 	endifEnd// * Created Jan 09. // Only remove matching text at the end of the string. Function /T StripSuffixBySuffix(NameString,Suffix)	String NameString,Suffix		Variable SuffixLen 	= strlen(Suffix)	Variable NameLen	 	= strlen(NameString)		String NameSuffix 	= NameString[NameLen-SuffixLen,NameLen-1]		if (cmpstr(NameSuffix,Suffix) == 0)		return NameString[0,NameLen-SuffixLen-1]	else		return NameString	endifEndFunction /T ReturnLastSuffix(NameString,SfxSepStr)	String NameString,SfxSepStr		if (StrSearch(NameString,SfxSepStr,0) > -1)		return ParseFilePath(0, NameString, SfxSepStr, 1, 0)	else		return ""	endifEndFunction /T StripSpacesAndSuffix(NameString,Separator)	String NameString, Separator		return StripSuffixBySeparator(ReplaceString(" ",NameString,""),Separator)End// Is this still used? I think it can be replaced by StripSuffixBySeparatorFunction /T ReturnTextBeforeLastCharacter(LongString,Char)	String LongString,Char		Variable NumChars = CountCharsInText(LongString,Char)		if (NumChars > 0)		return ReturnTextBeforeNthChar(LongString,Char,NumChars)	else		// NOTE THIS DEFAULT BEHAVIOR!!		return LongString	endifEnd// ***************************************************************************// **************** 			Characters in Strings// ***************************************************************************Function /T StripRepeatedChars(LongString,Char)	String LongString,Char		String strChar, OutputString=""	Variable i, j, FoundChar=0, length= strlen(LongString)		for (i=0;i<length;i+=1)		strChar = LongString[i,i]				if (!FoundChar)			// The last character did not match, so always add the new character to the output string. 			OutputString = OutputString + strChar							if (cmpstr(strChar,Char) == 0)				// Note whether we have matched a character. 				FoundChar = 1			endif		else			// Skip repeated matching characters ... 			if (cmpstr(strChar,Char) != 0)				OutputString = OutputString + strChar				FoundChar = 0			endif		endif	endfor		return OutputStringEndFunction /T StripLeadingChars(LongString,Char)	String LongString,Char		Variable i=-1, match=0, len=strlen(LongString)		do		i+=1		if (cmpstr(LongString[i,i],Char) == 0)			match = 1		else			match = 0		endif			while((i<len) && (match == 1))		return LongString[i,len-1]EndFunction /T StripTrailingChars(LongString,Char)	String LongString,Char		Variable match=0, i=strlen(LongString)	//	if (strlen(LongString) < 400)//		return ParseFilePath(2,LongString,Char,0,0) //	endif		do		i-=1		if (cmpstr(LongString[i,i],Char) == 0)			match = 1		else			match = 0		endif			while((i>=0) && (match == 1))		return LongString[0,i]End// *!*! ParseFilePath Cannot handle very long strings. // 	i.e., ParseFilePath(1, LongString, Char, 0, Nth) is not for long strings. Function /T ReturnTextBeforeNthChar(LongString,Char,Nth)	String LongString, Char	Variable Nth		String ShortString=""	Variable i, j, Mth=-1, clen, length		clen 	= strlen(Char)	length 	= strlen(LongString)		j=0	i=-1	do		i+=1		if (i==length)			return LongString		endif		if (cmpstr(LongString[i,i+clen-1],Char) == 0)			Mth = i			j+=1		endif	while(j<Nth)		return LongString[0,Mth-1]EndFunction /T ReturnTextAfterNthChar(LongString,Char,Nth)	String LongString, Char	Variable Nth		String ShortString=""	Variable i, j, Mth=-1, length=strlen(LongString)		j=0	i=length	do		i-=1		if (i==(0))				// We've reach the end of the string ... 			return LongString[Mth+1,length-1]		endif		if (cmpstr(LongString[i,i],Char) == 0)			Mth = i			j+=1		endif	while(j<Nth)		return LongString[Mth+1,length-1]EndFunction /T AppendDelimiter(LongString,Char)	String LongString,Char		Variable last=strlen(LongString)-1		if (cmpstr(Char,LongString[last,last]) != 0)		LongString = LongString+Char	endif		return LongStringEndFunction /T MakeStringOfChars(Numchars,Char)	Variable Numchars	String Char	Variable i	String temp=""		if (numtype(Numchars) == 0)		for (i=0;i<Numchars;i+=1)			temp += Char		endfor	endif	return tempEndFunction CountCharsInText(LongString,Char)	String LongString, Char		Variable NChars=0	Variable i, clen, length		clen 	= strlen(Char)	length	= strlen(LongString)		for (i=0;i<length;i+=1)		if (cmpstr(LongString[i,i+clen-1],Char) == 0)			NChars +=1		endif	endfor	return NCharsEnd// ***************************************************************************// **************** 			Padding Numbers in Strings// ***************************************************************************Function /T FrontPadString(NumStr,Char,Width)	String NumStr, Char	Variable Width		String NewNumStr=""	Variable i=0, OldLen		OldLen = strlen(NumStr)	if (OldLen > (Width-1))		return NumStr	else		do			NewNumStr+= Char			i+=1		while(i<(Width-OldLen))		NewNumStr += NumStr		return NewNumStr	endifEndFunction /T FrontPadVariable(Num,Char,Width)	Variable Num	String Char	Variable Width		return FrontPadString(num2str(Num),Char,Width)End//	PadString(str, finalLength, padValue )Function /S ReturnPaddedValueStr(ValueStr,PadStr)	String ValueStr,PadStr		Variable TotNChars, PadStrLen	String PaddedValue		PadStrLen = strlen(PadStr)	TotNChars = str2num(PadStr[1,PadStrLen-1])	 	// Let's hope that strlen(ValueStr) is always less than Padding. 	if (strlen(ValueStr) < TotNChars)		if (cmpstr("L",PadStr[0,0])==0)			return ValueStr + MakeStringOfChars(TotNChars - strlen(ValueStr)," ")		else			return MakeStringOfChars(TotNChars - strlen(ValueStr)," ")+ ValueStr		endif	else		return ValueStr	endifEnd// ***************************************************************************// **************** 			Handling numerical values in brackets// ***************************************************************************Function /T StripValuesInBrackets(Line,K1,K2)	String Line,K1,K2		Variable b1, b2, start=0	String bString, fStr, rStr		do		b1 = StrSearch(Line,K1,0)		if (b1 > -1)			b2 = StrSearch(Line,K2,b1)			if (b2 > -1)				fStr = Line[0,b1-1]				rStr = Line[b2+1,strlen(Line)-1]				Line = fStr+rStr			endif		endif			while(b1 > -1)		return LineEndFunction ReturnValueInBrackets(Line,K1,K2)	String Line,K1,K2		return str2num(ReturnStringInBrackets(Line,K1,K2))EndFunction /T ReturnStringInBrackets(Line,K1,K2)	String Line,K1,K2		Variable b1, b2, start=0	String ValStr=""		b1 = StrSearch(Line,K1,0)	if (b1 > -1)		b2 = StrSearch(Line,K2,b1)		if (b2 > -1)			ValStr 	= Line[b1+1,b2-1]		endif	endif		return ValStrEnd// ***************************************************************************// **************** 			Handling Numbers in Strings// ***************************************************************************// 	*!*! Note: Incorrectly flags "5." as a decimal numbner - more likely to be file_5.datFunction CountNumbersInString(Str,DecimalFlag)	String Str	Variable DecimalFlag		String Char	Variable i, i1, i2, isNum, isDot, NumStr=0, nNums=0, nDecs=0	Variable len=strlen(Str)		for (i=0;i<len;i+=1)		Char = Str[i,i]		isNum 	= (numtype(str2num(Char)) == 0) ? 1 : 0		isDot 	= (char2num(Char) == 46) ? 1 : 0				if (NumStr == 1)			if (isNum || isDot)			else				NumStr = 0				nNums += 1				i2 = i				if (SubStrIsDecimal(Str,i1,i2))					nDecs += 1				endif			endif		elseif (isNum)			i1 = i			NumStr = 1		endif	endfor		// The string ends in a number. 	if (NumStr)		nNums += 1		if (SubStrIsDecimal(Str,i1,strlen(Str)-1))			nDecs += 1		endif	endif		if (DecimalFlag)		return nDecs	else		return nNums	endifEndsscanf// This is a modified version of CountNumbersInString// Does not distinguish between integer or decimal. // 2021-12 (!!) Updated so that it returns negative numbers!! Function ReturnNthNumber(Str,N)	String Str	Variable N		String Char	Variable i, i1, i2, isNum, isDot, isNeg, NumStr=0, nNums=0	Variable len=strlen(Str), len2, outputNum		for (i=0;i<len;i+=1)		Char = Str[i,i]		isNum 	= (numtype(str2num(Char)) == 0) ? 1 : 0		isDot 	= (char2num(Char) == 46) ? 1 : 0		isNeg 	= (char2num(Char) == 45) ? 1 : 0				if (NumStr == 1)			if (isNum || isDot)			else				NumStr = 0				nNums += 1				i2 = i				if (nNums == N)					return str2num(Str[i1,i2])				endif			endif		elseif (isNum)			i1 = i			NumStr = 1		elseif (isNeg)			Char 	= Str[i+1,i+1]			isNum = (numtype(str2num(Char)) == 0) ? 1 : 0			if (isNum)				i1 = i				NumStr = 1			endif		endif	endfor		// The string ends in a number. 	if (NumStr)		nNums += 1		if (nNums == N)			outputNum=str2num(Str[i1,len-1])			return str2num(Str[i1,len-1])		endif	endif		return nanEndFunction SubStrIsDecimal(Str,i1,i2)	String Str	Variable i1, i2		String Number = Str[i1,i2]		if (strsearch(Number,".",0) > -1)		return 1	else		return 0	endifEnd// Counting from the ENDFunction ReturnLastNumber(LongString)	String LongString		String Char	Variable length=strlen(LongString)	Variable i=length, Nstart, Nstop		do		i-=1				// Find the last digit of the last number		if (i==(-1))			return NAN	// There are no numbers		endif	while(numtype(str2num(LongString[i,i])) != 0)	Nstop=i		do						// Find the first digit of the last number		i-=1		Char = LongString[i,i]		if (i==(-1))			return str2num(LongString[0,Nstop])	// There is no text before this number		endif	while((numtype(str2num(Char)) == 0) || (cmpstr(Char,".")==0))	Nstart=i+1		return str2num(LongString[Nstart,Nstop])EndFunction /T ReturnTextBeforeNumber(LongString)	String LongString		String ShortString=""	Variable i=0, length=strlen(LongString)		if (length>0)		do			if (numtype(str2num(LongString[i,i])) == 0)				break			endif			ShortString += LongString[i,i]			i+=1		while(i<length)				if (strlen(ShortString) > 0)			return ShortString		else			// Return the full text if there is no number			return LongString		endif	else		return ""	endifEnd// ***************************************************************************// **************** 			Math Functions// ***************************************************************************Function ClipValue(Value,MinThresh,MaxThresh)	Variable Value,MinThresh,MaxThresh		return max(min(Value,MaxThresh),MinThresh)EndFunction CheckIntegerVariable(Var)	Variable Var		if (abs(Var - floor(Var)) > 0.00001)		return 0	else		return 1	endifEndFunction CheckEvenVariable(Var)	Variable Var		if (mod(Var,2) != 0)		return 0	else		return 1	endifEndFunction FindNonNANValue(Num1,Num2)	Variable Num1,Num2		if ((numtype(Num1) == 2) && (numtype(Num2) == 2))		return NAN	else		if (numtype(Num1) == 0)			return Num1		else			return Num2		endif	endifEndFunction MaxWithNANs(Num1,Num2)	Variable Num1,Num2		if ((numtype(Num1) == 0) && (numtype(Num2) == 0))		return max(Num1,Num2)	else		return FindNonNANValue(Num1,Num2)	endifEndFunction MinWithNANs(Num1,Num2)	Variable Num1,Num2		if ((numtype(Num1) == 0) && (numtype(Num2) == 0))		return min(Num1,Num2)	else		return FindNonNANValue(Num1,Num2)	endifEndFunction CheckAsciiNumber(Code)	Variable Code		if (Code == 46)	// Decimal point/period		return 1	elseif (Code<48)		return 0	elseif (Code>57)		return 0	else		return 1	endifEnd// ********************************************************// ******     			TABLE PROCEDURES// ********************************************************Function KillPlotsPanelsAndTables(WindowName,WindowType)	String WindowName, WindowType		String optionsStr	Variable i=0, NWins		strswitch (WindowType)		case "plots":			optionsStr = "WIN:1"			break		case "tables":			optionsStr = "WIN:2"			break		case "panels":			optionsStr = "WIN:64"			break		default:			optionsStr = "WIN:67"	endswitch		String SingleName, WindowList =WinList(WindowName,";",optionsStr)		NWins = ItemsInList(WindowList)	for (i=0;i<NWins;i+=1)		SingleName = StringFromList(i,WindowList)		DoWindow /K $SingleName	endfor		return ItemsInList(WindowList)EndFunction KillNamedNotebook(NoteBookName)	String NoteBookName	String NotebookList = WinList(NoteBookName,";","WIN:16")		if (ItemsInList(NotebookList) > 0)		DoWindow /K NoteBookName	endifEnd// ********************************************************// ******     			Bit Manipulation// ********************************************************// USE THESE!!!Function BitClear(vIn,bit)	Variable vIn, bit		return vIn & ~(2^bit)EndFunction BitSet(vIn,bit)	Variable vIn, bit		return vIn | (2^bit)EndFunction BitTest(vIn,bit)	Variable vIn, bit		if ((vIn & 2^bit) != 0)		return 1	else		return 0	endifEndFunction SetBit(ValIn, BitNo)	Variable ValIn, BitNo		ValIn = trunc(ValIn)				// Makes sense with integers only		Variable ValOut		if ((ValIn & 2^BitNo) != 0)		// Test if bit "BitNo" is set//		Print "Bit 3 is set"		return ValIn	else//		Print "Bit 3 is cleared"		ValOut = ValIn | (2^BitNo)		// Set bit "BitNo"		return ValOut	endifEndFunction ClearBit(ValIn, BitNo)	Variable ValIn, BitNo		ValIn = trunc(ValIn)				// Makes sense with integers only		Variable ValOut		if ((ValIn & 2^BitNo) != 0)		// Test if bit "BitNo" is set//		Print "Bit 3 is set"		ValOut = ValIn & ~(2^BitNo)		// Clear bit "BitNo"		return ValOut	else//		Print "Bit 3 is cleared"		return ValIn	endifEndFunction DemoBitManipulation(vIn)	Variable vIn	vIn = trunc(vIn)				// Makes sense with integers only	Printf "Original value: %d\r", vIn	Variable vOut	if ((vIn & 2^3) != 0)		// Test if bit 3 is set		Print "Bit 1 is set"	else		Print "Bit 1 is cleared"	endif	vOut = vIn | (2^3)			// Set bit 3	Printf "Set bit 3: %d\r", vOut	vOut = vIn & ~(2^3)			// Clear bit 3	Printf "Clear bit 3: %d\r", vOut	vOut = vIn * (2^3)			// Shift three bits left	Printf "Shift three bits left: %d\r", vOut	vOut = vIn / (2^3)			// Shift three bits right	Printf "Shift three bits right: %d\r", vOutEnd//Function /T ListFromColumnTitles(TitleStr,Char)//	String TitleStr, Char//	//	String TitleList=""//	Variable i, SpaceStart=0, n=strlen(TitleStr)//	//	TitleStr 	= ReplaceString("\r",TitleStr,"")//	//	for (i=0;i<n;i+=1)//		if (cmpstr(TitleStr[i,i]," " ) != 0)//			TitleList += TitleStr[i,i]//			SpaceStart = 0//		elseif (SpaceStart == 0)//			TitleList += Char//			SpaceStart = 1//		endif//	endfor//	//	return TitleList//End// Obselete: Please use CleanUp//Function /T CheckFirstLetter(StructureName)//	String StructureName////	if (numtype(str2num(StructureName[0,0])) == 0)//		return "x" + StructureName//	else//		return StructureName//	endif//End