#pragma rtGlobals=1		// Use modern global access method.Constant MaxNameLen=21CleanUpNameCheckNameUniqueName// ***************************************************************************// ********* 			Filenaming 	- 	User interactive procedures. // ***************************************************************************Function /T GetSampleName(DataName,OptSuffix,CopySuffix,StripPrefixFlag,UserNameFlag,Truncation)	String DataName, OptSuffix, CopySuffix	Variable StripPrefixFlag, UserNameFlag, Truncation		WAVE /T wDataList 		= root:SPECTRA:wDataList	Variable NUScores	String UserName, DelNumStr, SampleName = DataName		if (StripPrefixFlag == 1)		SampleName = StripSpacesAndSuffix(DataName,".")	endif	SampleName = CleanUpDataName(SampleName) +  OptSuffix		// 	Okaay ... the problem with this line is that it always adds '_r' onto names during renaming. 	// Let's try putting it in the UserNameFlag != 1 condition below. //	SampleName = AvoidDataNameConflicts(SampleName,CopySuffix,wDataList)	// hmm .. if I remove this from here, I can give spectra idential names when loading. Argh! 		if (UserNameFlag == 1)		UserName = PromptForUserStrInput(SampleName,"Please edit the data name. LESS THAN 28 CHARS!","User Text Input")				if (cmpstr(UserName,SampleName) == 0)			// Use did not change anything ... but there may still be problems with the name. 			SampleName = AvoidDataNameConflicts(SampleName,CopySuffix,wDataList)			if (strlen(SampleName) < MaxNameLen)				return SampleName			endif		elseif (cmpstr("_quit!_",UserName) == 0)			return UserName		endif				SampleName = CleanUpDataName(UserName)		SampleName = AvoidDataNameConflicts(SampleName,CopySuffix,wDataList)	else		SampleName = AvoidDataNameConflicts(SampleName,CopySuffix,wDataList)	endif	if (strlen(SampleName) == 0)		return "_quit!_"			elseif (strlen(SampleName) > MaxNameLen)		if (UserNameFlag)			DelNumStr = num2str(strlen(SampleName)-MaxNameLen)			SampleName = PromptForUserStrInput(SampleName,"Please shorten the sample name by "+DelNumStr+" chars","The sample name is too long!")			if (cmpstr("_quit!_",SampleName) == 0)				return ""			endif		endif				if (strlen(SampleName) > MaxNameLen)			NUScores 		= CountCharsInText(SampleName,"_")			if (NUScores > 0)				Print " 		 ... Removed",NUScores,"underscores from the name",SampleName				SampleName 	= ReplaceString("_",SampleName,"")			endif		endif		//		if ((strlen(SampleName) > MaxNameLen) && Truncation)		if ((strlen(SampleName) > MaxNameLen) && 1)			SampleName 	= SampleName[0,MaxNameLen-1]			SampleName 	= CleanUpName(SampleName,0)			Print " 		 ... The plotting routines can't handle the name",SampleName," as it has",strlen(SampleName)-MaxNameLen+1,"too many characters. Truncating!"		endif	endif	SampleName = AvoidDataNameConflicts(SampleName,CopySuffix,wDataList)			return SampleNameEnd// 	Make sure the data name is legal with some moderately understandable character substitutions. // 	Do not worry about name length at this point. Function /T CleanUpDataName(DataName)	String DataName		String SampleName	SampleName = ReplaceString("_data",ReplaceString("_axis",DataName,""),"")	SampleName = ReplaceString(" ",SampleName,"")	SampleName = ReplaceString("-",SampleName,"m")	SampleName = ReplaceString("+",SampleName,"p")	SampleName = ReplaceString("=",SampleName,"eq")	SampleName = ReplaceString(",",SampleName,"_")	SampleName = ReplaceString(".",SampleName,"p")	SampleName = ReplaceString("#",SampleName,"")		// Ensure the filename starts with a letter	Variable CharNum = char2num(SampleName)	if ((CharNum < 65) || (char2num(SampleName) > 122))		SampleName	= "s"+SampleName	elseif ((CharNum > 90) && (CharNum < 97))		SampleName	= "s"+SampleName	endif		SampleName 	= StripTrailingChars(SampleName,"_")		return SampleNameEndFunction /T AvoidDataNameConflicts(DataName,CopySuffix,DataListWave)	String DataName, CopySuffix	Wave /T DataListWave		String DataListStr = TextWaveToList(DataListWave,0,"","")		DataName 	= AvoidNameConflict(DataName,CopySuffix,DataListStr)		return DataNameEnd// This can now handle the case in which adding the numerical suffix makes the filename too long. Function /T AvoidNameConflict(DataName,CopySuffix,DataListStr)	String DataName,CopySuffix,DataListStr	String suffix, DataStem	Variable SuffLen, MatchIdx=0, RptNum=1		DataListStr = ReplaceString("_data",DataListStr,"")		if (strlen(CopySuffix) == 0)		CopySuffix = "r"	elseif (cmpstr("_",CopySuffix[0,0]) == 0)		CopySuffix = CopySuffix[1,strlen(CopySuffix)-1]	else		CopySuffix = CopySuffix	endif		SuffLen 	= 1+strlen(CopySuffix)		MatchIdx = FindListItem(DataName,DataListStr)	if (MatchIdx == -1)		return DataName	endif		DataStem 	= StripSpacesAndSuffix(DataName,"_"+CopySuffix)	DataName 	= DataStem + "_" + CopySuffix	if (strlen(DataName) > MaxNameLen)		DataName 	= DataStem[0,MaxNameLen-1-SuffLen] + "_" + CopySuffix 	endif		MatchIdx = FindListItem(DataName,DataListStr)	if (MatchIdx == -1)		return DataName	endif		do		suffix 		= CopySuffix + num2str(RptNum)		SuffLen 	= 1+strlen(suffix)		DataName 	= DataStem + "_" + suffix 			if (strlen(DataName) > MaxNameLen)			DataName 	= DataStem[0,MaxNameLen-1-SuffLen] + "_" + suffix 		endif			MatchIdx = FindListItem(DataName,DataListStr)		if (MatchIdx == -1)			return DataName		endif				RptNum += 1	while(1)End// ***************************************************************************// ********* 			Some routines to handle reserved file and data names// ***************************************************************************Function /T DataNameFromFileName(FileName)	String FileName		NVAR gStripPrefixFlag	= root:SPECTRA:GLOBALS:gStripPrefixFlag	SVAR gStripText			= root:SPECTRA:GLOBALS:gStripText	SVAR gReplaceText		= root:SPECTRA:GLOBALS:gReplaceText		Variable i	String NewFileName = FileName		// This allows me to handle the Coefficient File names here	String tempName = StripStringItemsFromText("_Legend;.ibw;fs_;fc_;fl_;",FileName)		if (gStripPrefixFlag == 1)		for (i=0;i<ItemsInList(gStripText);i+=1)			NewFileName 	= ReplaceString(StringFromList(i,gStripText),NewFileName,StringFromList(i,gReplaceText),0,1)		endfor		return NewFileName//		return ReplaceString(gStripText, tempName, gReplaceText)	else		return tempName	endifEndFunction /T RemoveSpecialTracesFromList(ListofDataNames,SpecialTrace)	String ListofDataNames, SpecialTrace		if (WhichListItem(SpecialTrace,ListofDataNames) > -1)		ListofDataNames 	= RemoveFromList(SpecialTrace,ListofDataNames)	endif		return ListofDataNamesEndFunction TraceIsSpecial(TraceName)	String TraceName		Variable special = 0		strswitch (TraceName)	case "mask":		special =1		break	case "invmask":		special =1		break	case "Bar1Height":		special =1		break	case "Bar2Height":		special =1		break	case "Bar3Height":		special =1		break	case "Bar4Height":		special =1		break	case "HBar1Height":		special =1		break	case "HBar2Height":		special =1		break	case "HBar3Height":		special =1		break	case "HBar4Height":		special =1		break	default:		break	endswitch		return specialEnd// ***************************************************************************// **************** 			Multidimensional Wave Functions// ***************************************************************************// 2D Matrices must be N1 x M and N2 x M. // Matrix 1 is appended to Matrix 2// NOTE: This should be done using "concatenate"!Function Append2DWave(Matrix1,Matrix2)	Wave Matrix1,Matrix2	Variable KillFlag	Variable NRows1, NRows2, NCols1, NCols2, i		NRows1 	= DimSize(Matrix1,0)	NRows2 	= DimSize(Matrix2,0)		NCols1 		= DimSize(Matrix1,1)	NCols2 		= DimSize(Matrix2,1)		Redimension /N=((NRows1+NRows2),NCols2) Matrix2		for (i=0;i<NRows1;i+=1)		if (NCols2 > NCols1)			Matrix2[NRows2+i][0,NCols1-1] 	= Matrix1[i][q]			// Copy missing values from the previous row			Matrix2[NRows2+i][NCols1]		= Matrix2[NRows2+i-1][q]					else			Matrix2[NRows2+i][] = Matrix1[i][q]		endif	endforEndFunction ColumnMean(Array,ColNum)	Wave Array	Variable ColNum		Variable NumRows = DimSize(Array,0)	Make /O/D/N=(NumRows) temp	temp[] = Array[p][ColNum]	Variable ColMean = mean(temp)	KillWaves /Z temp	return ColMeanEnd// ***************************************************************************// **************** 			Make 2D Matrix from individual waves// ***************************************************************************// 	The main goal of this function was to permit spectra to be averaged and other statistical operations to be performed. // 	Also aim to permit a 2D plot to be made from the results. Function PlotDataTo2DMatrix(WindowName,cAxisName,AxisMin, AxisMax, AxisStep)	String cAxisName, WindowName	Variable AxisMin, AxisMax, AxisStep		Variable i, j, m, n, NTraces=0, AxisPts, BIG=2e9	Variable NumTraces=ItemsInList(TraceNameList(WindowName, ";", 1),";")		WAVE cAxis = $cAxisName	AxisPts = numpnts(cAxis)		Duplicate /O/D cAxis, cData	Make /O/D/N=(AxisPts,NumTraces) PlotDataMatrix=NAN		for (i=0;i<NumTraces;i+=1)		// Copy the plotted data into the current datafolder .. this is for debugging//		Duplicate /O/D WaveRefIndexed(WindowName,i,1), $("wave"+num2str(i)+"d")//		Duplicate /O/D WaveRefIndexed(WindowName,i,2), $("wave"+num2str(i)+"a")//		WAVE Ax1 = $("wave"+num2str(i)+"a")//		WAVE Da1 = $("wave"+num2str(i)+"d")//		Sort Ax1, Ax1, Da1		WAVE Data 	= WaveRefIndexed(WindowName,i,1)				if (!TraceIsSpecial(NameOfWave(Data)))			NTraces += 1			Duplicate /O/D WaveRefIndexed(WindowName,i,1), SglData			Duplicate /O/D WaveRefIndexed(WindowName,i,2), SglAxis			Sort SglAxis, SglAxis, SglData						// Interpolate the data onto the common axis. 			Interpolate2/T=1/N=200/I=3/Y=cData/X=$cAxisName SglAxis, SglData						m=0			n=AxisPts-1			// Read the values into the 2D Matrix - but only within the valid data ranges			if (SglAxis[0] > cAxis[0])				do					m+=1				while(SglAxis[0] > cAxis[m])			endif			if (SglAxis[BIG] < cAxis[AxisPts-1])				do					n-=1				while(SglAxis[BIG] < cAxis[n])			endif						PlotDataMatrix[m-1,n+1][i] = cData[p]		endif				Redimension /N=(AxisPts,NTraces) cData	endfor		Killwaves /Z cDataEnd// ***************************************************************************// **************** 			Making and Duplicating Waves// ***************************************************************************Function MakeWaveIfNeeded(NameStr,NumPts,[NCols])	String NameStr	Variable NumPts, NCols		if( ParamIsDefault(NCols) == 1)	// 1D wave 		if (exists(NameStr) == 0)			Make /O/D/N=(NumPts) $NameStr			return 1		elseif ((NumPts > 0) && (numpnts($NameStr) != NumPts))			ReDimension /N=(NumPts) $NameStr			return 2		endif		return 0	else		if (exists(NameStr) == 0)			Make /O/D/N=(NumPts,NCols) $NameStr			return 1		elseif ((DimSize($NameStr,0) != NumPts) || (DimSize($NameStr,1) != NCols))			ReDimension /N=(NumPts,NCols) $NameStr			return 2		endif		return 0	endifEndFunction DuplicateWaveIfNeeded(DataName,DupName)	String DataName,DupName		if (exists(DupName) == 0)		Duplicate /O/D $DataName, $DupName	elseif (numpnts($DataName) != numpnts($DupName))		Duplicate /O/D $DataName, $DupName	endifEndFunction MakeTextWaveIfNeeded(NameStr,NumPts)	String NameStr	Variable NumPts		if (exists(NameStr) == 0)		Make /O/T/N=(NumPts) $NameStr	elseif (numpnts($NameStr) != NumPts)		ReDimension /N=(NumPts) $NameStr	endifEnd// ***************************************************************************// **************** 			Sorting Axis and Data Waves// ***************************************************************************// E.g., one axis wave and n data and fit waves. All are sorted relative to axis. Function SortWavesFromList(ListOfWaves,SortKey)	String ListOfWaves	Variable SortKey		String SortCmd, KeyName, ListName	Variable i=0, KeyNmPts, WaveNmPts, n = ItemsInList(ListOfWaves)		if (SortKey < n)		KeyName	= StringfromList(SortKey,ListOfWaves)		WAVE KeyWave	= $(KeyName)		KeyNmPts	= numpnts(KeyWave)				SortCmd	= "Sort " + KeyName		do			ListName=StringfromList(i,ListOfWaves)			WAVE ListWave	= $(ListName)						if (WaveExists(ListWave))				WaveNmPts	= numpnts(ListWave)				if (KeyNmPts == WaveNmPts)					SortCmd += " ," + ListName				else					Print " *** Wave or column skipped during Sort!",ListName,"does not have the same number of points as sort key",KeyName				endif			endif			i+=1		while(i<n)		//		if (strlen(SortCmd) > 400) // Not sure where this limit came from		if (strlen(SortCmd) > 2500)			Print " *** Too many columns to sort!"			Print SortCmd		else			Execute SortCmd		endif	endifEnd// ***************************************************************************// **************** 			Converting between lists and waves// ***************************************************************************Function /S ListFromTextMatrix(TextMatrix,CRType,CRNum)	Wave /T TextMatrix	String CRType	Variable CRNum	String CRList = ""	Variable i, NRows=DimSize(TextMatrix,0), NCols=DimSize(TextMatrix,1)		if (cmpstr(CRType,"row")==0)		for (i=0;i<NRows;i+=1)			CRList = CRList + ";" + TextMatrix[i][CRNum]		endfor	else		for (i=0;i<NCols;i+=1)			CRList = CRList + ";" + TextMatrix[CRNum][i]		endfor	endif	return CRListEndFunction ListValuesToWave(Values,List,delimiter,Start)	Wave Values	String List, delimiter	Variable Start		Variable i		for (i=0;i<numpnts(Values);i+=1)		Values[i] 	= str2num(StringFromList(i+Start,List,delimiter))	endforEndFunction /T VarWaveToList(WaveOfVars,ListLength,[Char])	Wave WaveOfVars	Variable ListLength	String Char		String Ch=";", VarList=""	Variable n, i=0, WaveLength = numpnts(WaveOfVars)		if( ParamIsDefault(Char) == 0) 		Ch = Char	endif 		n = (ListLength < 1) ? WaveLength : min(WaveLength,ListLength)		for (i=0;i<n;i+=1)		VarList += num2str(WaveOfVars[i])+ Ch	endfor		return VarListEndFunction /T TextWaveToList(ListOfStrs,ListLength,prefix,suffix)	Wave /T ListOfStrs	Variable ListLength	String prefix,suffix		String NameList=""	Variable n, i=0, WaveLength = numpnts(ListOfStrs)		n = (ListLength < 1) ? WaveLength : min(WaveLength,ListLength)		for (i=0;i<n;i+=1)		if (strlen(ListOfStrs[i]) > 0)			NameList += prefix + ListOfStrs[i] + suffix + ","		endif	endfor		return NameListEndFunction FindStringInTextWave(MatchStr, TxtWave)	String MatchStr	Wave /T TxtWave		String TxtList = TextWaveToList(TxtWave,0,"","")	return WhichListItem(MatchStr,TxtList,";",0)EndFunction /T LookForCommonPrefix(ListOfWaves)	String ListOfWaves		Variable i, j=0, EndFlag	String ListName, Prefix, NewCommonPrefix, CommonPrefix = ""		do		ListName = StringfromList(0,ListOfWaves)		NewCommonPrefix = ListName[0,j]				for (i=0;i<ItemsInList(ListOfWaves);i+=1)			ListName 	= StringfromList(i,ListOfWaves)			EndFlag		= j == strlen(ListName) ? 1 : 0			Prefix 		= ListName[0,j]						if (cmpstr(Prefix,NewCommonPrefix) != 0)				return CommonPrefix			endif		endfor				CommonPrefix = NewCommonPrefix		j+=1	while(!EndFlag)		return CommonPrefixEnd// ***************************************************************************// **************** 			Deleting Waves// ***************************************************************************Function KillNNamedWaves(name,n)	String name	Variable n	Variable i	String KillWave	for (i=0;i<(n+1);i+=1)		KillWave=name+num2str(i)		KillWaves /Z $KillWave	endforEndFunction KillWavesFromTextWave(TextWave,DisplayedFlag)	Wave /T TextWave	Variable DisplayedFlag		String ListOfWaves = TextWaveToList(TextWave,0,"","")	KillWavesFromList(ListOfWaves,DisplayedFlag)EndFunction KillWavesFromList(ListOfWaves,DisplayedFlag)	String ListOfWaves	Variable DisplayedFlag			Variable i, NumWaves = ItemsInList(ListOfWaves)	String KillWave	for(i=0;i<NumWaves;i+=1)		KillWave=StringfromList(i,ListOfWaves)		if (DisplayedFlag)			RemoveDataFromAllWindows(KillWave)		endif		if (WaveExists($KillWave))			KillWaves /Z $KillWave		endif	endforEnd	Function KillSampleWavesNotInList(SampleName,ListOfWavesToSave)	String SampleName, ListOfWavesToSave		String ListOfAllWaves, KillWave	ListOfAllWaves = ExclusiveWaveList(WaveList(SampleName+"*",";",""),"_axis",";")	Variable i, NumWaves = ItemsInList(ListOfAllWaves)		if (NumWaves>0)		for(i=0;i<NumWaves;i+=1)			KillWave=StringfromList(i,ListOfAllWaves)			if (WhichListItem(KillWave,ListOfWavesToSave) == -1)				RemoveDataFromAllWindows(KillWave)				KillWaves /Z $KillWave			endif		endfor	endifEnd	// Might be a problem if more than one instance of a plotted trace? Function RemoveDataFromAllWindows(YData)	String YData		String PlotList, PlotName, Info	String WindowName, WindowList =WinList("*",";","WIN:67")	Variable i, j, TwoDFlag, NumWins = ItemsInList(WindowList)		TwoDFlag 	= (DimSize($YData,1) > 0) ? 1 : 0		if (NumWins>0)		for (i=0;i<NumWins;i+=1)			WindowName = StringFromList(i,WindowList)			switch (WinType(WindowName))				case 1: 					do						CheckDisplayed /W=$WindowName $YData						if (V_flag == 1)							RemoveFromGraph /Z/W=$WindowName $YData							break						endif					while(V_flag == 1)					break									case 2:					CheckDisplayed /W=$WindowName $YData					if (V_flag == 1)						RemoveFromTable /Z/W=$WindowName $YData					endif					break								case 7:					// A Panel. 					// If we are trying to delete a 2D wave, we will simply see if it is displayed as an image. 					// If so, we will kill the entire panel. 					if (TwoDFlag)						PlotList = ChildWindowList(WindowName)						for (j=0;j<ItemsInList(PlotList);j+=1)							PlotName 	= WindowName+"#"+StringFromList(j,PlotList)							DoWindow $WindowName //<-- the main panel might have been killed already! 							if (V_flag)								Info 		= ImageInfo(PlotName,YData,0)								if (strlen(Info) > 0)									DoWindow /K $WindowName								endif							endif						endfor					endif			endswitch		endfor	endifEnd//					for (j=0;j<ItemsInList(PlotList);j+=1)//						PlotName = WindowName+"#"+StringFromList(j,PlotList)//						do//							CheckDisplayed /W=$PlotName $YData//							if (V_flag == 1)//								if (TwoDFlag)//									RemoveImage /Z/W=$PlotName $YData//									if (WhichListItem(YData,ContourNameList(PlotName,";")) > -1)//										RemoveContour /W=$PlotName $YData//									endif//								else//									RemoveFromGraph /Z/W=$PlotName $YData//								endif//							endif//						while(V_flag == 1)//					endfor// ***************************************************************************// **************** 			Inspecting and Creating Axes// ***************************************************************************Function MakeLogAxis(axis,x0,PtsPerDecade)	Wave axis	Variable x0, PtsPerDecade		axis[] 	= 10^(log(x0)+p/PtsPerDecade )EndFunction CheckMonotonic(Axis)	Wave Axis		Variable i, IncFlag=1, NPnts=numpnts(Axis)		// First check whether axis starts by increasing or decreasing. 	if (Axis[1] < Axis[0])		IncFlag = 0	endif		for (i=1;i<NPnts;i+=1)		if (Axis[i] == Axis[i-1])			// Check for identical axis values			return -1		elseif (IncFlag)			if (Axis[i] < Axis[i-1])				return 0			endif		else			if (Axis[i] > Axis[i-1])				return 0			endif		endif	endfor			return 1EndFunction CheckConstantStep(Axis,Tolerance,LogFlag)	Wave Axis	Variable Tolerance,LogFlag		Variable NPts, Variance, MinStep, AvgStep		WaveStats /M=1/Q Axis	if ((V_min<0) && (LogFlag == 1))		return NAN	endif		NPts = numpnts(Axis)	Make /O/D/N=(NPts-1) AbsoluteStep	if (LogFlag == 1)		AbsoluteStep[] = abs(log(Axis[p])-log(Axis[p+1]))	else		AbsoluteStep[] = abs(Axis[p]-Axis[p+1])	endif		WaveStats /Q AbsoluteStep	Variance 	= (V_sdev)^2	AvgStep 	= V_avg	MinStep 	= V_min	KillWaves /Z AbsoluteStep		if ((Variance == 0) || (Variance<Tolerance^2))		// Constant step within tolerance, so return the AVERAGE step as a positive value ....		return AvgStep	else		// ... else return the MINIMUM step size as a negative value. 		return -1*MinStep	endifEndFunction MakeConstantStepAxisData(Data,Axis,AxisStep)	Wave /D Data,Axis	Variable AxisStep		Variable NPts, BIG=2e9	Variable AxMin = Axis[0]	Variable AxMax = Axis[BIG]	NPts = trunc(abs((AxMax - AxMin)/AxisStep)) + 1		AxisStep = sign(AxisStep)*abs(AxisStep)	Make /O/N=(NPts) constAxis, constData	SetScale/P x AxMin, AxisStep, constData	constAxis[] = AxMin + x*AxisStep	constData 	= interp(x, Axis, Data)		ReDimension /N=(NPts) Axis, Data 	Axis = constAxis	Data = constData		KillWaves /Z constAxis, constData	return NPtsEnd// ***************************************************************************// **************** 			Switching between x-y and waveform representations// ***************************************************************************Function XYToWave1(xWave, yWave, wWaveName, numPoints) 	Wave/D xWave		// X wave in the XY pair 	Wave/D yWave 		// Y wave in the XY pair 	String wWaveName 	// Name to use for new waveform wave 	Variable numPoints 	// Number of points for waveform 		Make/O/N=(numPoints) $wWaveName 	// Make waveform. 	Wave wWave= $wWaveName 		WaveStats /M=1/Q xWave 				// Find range of x coords. 	SetScale/I x V_min, V_max, wWave		// Set X scaling for wave. 	wWave = interp(x, xWave, yWave) 		// Do the interpolation. EndFunction Wave1ToXY(xyWave, wWaveName) 	Wave/D xyWave		// X wave in the XY pair 	String wWaveName 	// Name to use for new waveform wave 		wWaveName = ReplaceString("_data",wWaveName,"")	Variable numPoints = numpnts(xyWave)		Make/O/N=(numPoints) $(wWaveName+"_axis"), $(wWaveName+"_data")	Wave xWave= $(wWaveName+"_axis")	Wave yWave= $(wWaveName+"_data")		xWave[] 	= xyWave[p]	yWave[]	= pnt2x(xyWave,p)EndFunction ReturnCommonDivisor(numbers)	Wave numbers		Variable i,j,MaxDiv,ComDiv,Num = numpnts(numbers)		WaveStats /Q/M=0 numbers	MaxDiv = V_max		for (i=0;i<Num;i+=1)		for (j=i+1;j<Num;j+=1)			ComDiv = gcd(numbers[i],numbers[j])			if (ComDiv < MaxDiv)				MaxDiv = ComDiv			endif 		endfor	endfor		return MaxDivEnd// ***************************************************************************// **************** 			Handling Annoyingly small values// ***************************************************************************Function NoZeroRoundingError1D(Data,small)	Wave Data	Variable small		Data[] = (abs(Data[p]) <  small) ? 0 : Data[p]EndFunction NoZeroRoundingError2D(Data,small)	Wave Data	Variable small		Data[][] = (abs(Data[p][q]) <  small) ? 0 : Data[p][q]EndFunction PositiveMinimim(Data)	Wave Data		Variable i, v, n=numpnts(Data), minv=wavemax(Data)		for(i=0;i<n;i+=1)		v = Data[i]		minv = (v>0 && v<minv) ? v : minv	endfor		return minvEnd// ***************************************************************************// **************** 			Handling Lists of Waves. Assume: Axis;Data;Assocd Waves. // ***************************************************************************Function WaveList_StripOrReplaceNaNs(DataWavesList,ReplaceFlag,ReplaceValue)	String DataWavesList	Variable ReplaceFlag,ReplaceValue		Variable i, j, NumWaves=ItemsInList(DataWavesList)		WAVE Data 	= $StringFromList(1,DataWavesList)	WaveStats /Q/M=0 Data		if (V_numNaNs == 0)		return 0	endif		for (i=0;i<numpnts(Data);i+=1)		if (numtype(Data[i])==2)			for (j=0;j<NumWaves;j+=1)				WAVE DelWave 	= $StringFromList(j,DataWavesList)				if (ReplaceFlag == 1)					DelWave[i] 	= ReplaceValue				else					DeletePoints i, 1, DelWave				endif			endfor			i-=1		endif	endfor		return V_numNaNsEndFunction WaveList_Truncate(DataWavesList,AxisMin,AxisMax)	String DataWavesList	Variable AxisMin,AxisMax		Variable i, j, NumWaves=ItemsInList(DataWavesList)		WAVE Axis 	= $StringFromList(0,DataWavesList)	WAVE Data 	= $StringFromList(1,DataWavesList)		Variable NDel, NPts 		= DimSize(Axis,0)	Variable XMin 	= AxisValueToPoint(Axis, AxisMin)	Variable XMax 	= AxisValueToPoint(Axis, AxisMax)		// Delete points at start	if (XMin > 0)		for (j=0;j<NumWaves;j+=1)			WAVE DelWave 	= $StringFromList(j,DataWavesList)			DeletePoints 0, XMin-1, DelWave		endfor	endif		// Delete points at end	if (XMax < NPts)		NDel = (NPts-XMax)-1		for (j=0;j<NumWaves;j+=1)			WAVE DelWave 	= $StringFromList(j,DataWavesList)			DeletePoints XMax+1, NDel, DelWave		endfor	endifEndFunction WaveList_Decimate(DataWavesList,Decimate)	String DataWavesList	Variable Decimate		Variable i, NumWaves=ItemsInList(DataWavesList)		if (numtype(Decimate) == 0)		for (i=0;i<NumWaves;i+=1)			WAVE ResWave 	= $StringFromList(i,DataWavesList)			Resample/UP=1/DOWN=(Decimate)/WINF=None ResWave		endfor	endifEndFunction WaveList_Sort(DataWavesList)	String DataWavesList		String CmdStr	CmdStr="Sort {"+StringFromList(0,DataWavesList)+"}, "+ ReplaceString(";",DataWavesList,",")		print CmdStr		Execute CmdStrEnd// ***************************************************************************// **************** 			Handling NANs// ***************************************************************************Function CountNANs(Data)	Wave Data		WaveStats /Q/M=1 Data	 return V_numNANsEndFunction CleanUpDataAxisPair(Data,Axis,MinCutOffValue,MinValue,MinValueFlag)	Wave Data,Axis	Variable MinCutOffValue,MinValue,MinValueFlag		switch(MinValueFlag)		case 2:			// First replace low values with a NAN ...			Data[] = ReplaceThresholdValue(Data[p],MinCutOffValue,1,Data[p],NAN)			// ... then remove the affected points			StripNANsFromWaveAxisPair(Data,Axis)			break		case 3:			// Replace low values with a different value			Data[] = ReplaceThresholdValue(Data[p],MinCutOffValue,1,Data[p],MinValue)			break		case 4:			// Replace low values with a NAN			Data[] = ReplaceThresholdValue(Data[p],MinCutOffValue,1,Data[p],NAN)			break	endswitchEnd// *** OPERATES ON ENTIRE WAVEFunction StripNANsFromWaveAxisPair(Data,Axis)	Wave Data,Axis		Variable i=0	for (i=0;i<numpnts(Data);i+=1)		if (numtype(Data[i])==2)			DeletePoints i, 1, Data, Axis			i-=1		endif	endforEnd// Look for NaNs in the first named waveFunction StripNANsFromDataWavesInList(DataWavesList)	String DataWavesList		Variable i, j, NumWaves=ItemsInList(DataWavesList)		WAVE Data 	= $StringFromList(0,DataWavesList)	WaveStats /Q/M=0 Data		if (V_numNaNs == 0)		return 0	endif		for (i=0;i<numpnts(Data);i+=1)		if (numtype(Data[i])==2)			DeletePoints i, 1, Data			for (j=1;j<NumWaves;j+=1)				WAVE Other 	= $StringFromList(j,DataWavesList)				DeletePoints i, 1, Other			endfor			i-=1		endif	endfor		return V_numNaNsEndFunction StripNANsFromAxisDataErrors(Axis,AxisErrors,Data,DataErrors)	Wave Axis,AxisErrors,Data,DataErrors		Variable i=0, ErrorsFlag = (WaveExists(AxisErrors)*WaveExists(DataErrors))		for (i=0;i<numpnts(Data);i+=1)		if (numtype(Data[i])==2)			DeletePoints i, 1, Axis,Data			if (WaveExists(AxisErrors))				DeletePoints i, 1,AxisErrors			endif			if (WaveExists(DataErrors))				DeletePoints i, 1,DataErrors			endif			i-=1		endif	endforEnd// *** OPERATES ON ENTIRE WAVEFunction ReplaceZerosWithValue(Data,value)	Wave Data	Variable value		Data = Data[p] == 0 ? value : Data[p]End// *** OPERATES ON ENTIRE WAVEFunction ReplaceNANsWithValue(Data,value)	Wave Data	Variable value		if (DimSize(Data,1) == 0)		// 1D wave		Data = numtype(Data[p]) == 2 ? value : Data[p]	else								// 2D wave		Data = numtype(Data[p][q]) == 2 ? value : Data[p][q]	endifEnd// *** OPERATES ON SINGLE VALUE - Use Igor wave indexing for entire wave. Function ReplaceThresholdValue(Datum,Threshold,NegFlag,DefaultVal,Replacement)	Variable Datum, Threshold,NegFlag,DefaultVal,Replacement		Variable ProblemPoint=0		if (NegFlag == 1)		Datum = (Datum < Threshold) ? Replacement : DefaultVal	else		Datum = (Datum > Threshold) ? Replacement : DefaultVal	endif	return DatumEnd// The Axis MUST be the first wave in the list. Function TrimWavesInList(ListOfWaves,MinRangeFlag,MinRange,MaxRangeFlag,MaxRange)	String ListOfWaves	Variable MinRangeFlag,MinRange,MaxRangeFlag,MaxRange		String AxisName, DataName	Variable i, NumAxisPts, NStartDeletePts, NEndDeletePts		AxisName = StringFromList(0,ListOfWaves)	WAVE Axis = $AxisName		NumAxisPts 	= numpnts(Axis)	NStartDeletePts	= BinarySearch(Axis, MinRange)	NEndDeletePts 	= (NumAxisPts - 1) - BinarySearch(Axis, MaxRange)		for (i=0;i<ItemsInList(ListOfWaves);i+=1)		DataName = StringFromList(i,ListOfWaves)		WAVE Data = $DataName					// Trim the start of the data		if ((MinRangeFlag>1) && (NStartDeletePts>0)) 			RemovePointsFromStartOfWave(Data,NStartDeletePts)		endif			// Trim the end of the data		if ((MaxRangeFlag>1) && (NEndDeletePts>0))			RemovePointsFromEndOfWave(Data,NEndDeletePts)		endif	endforEndFunction AddPointToStartOfWave(Data,PointValue)	Wave Data	Variable PointValue		InsertPoints -1, 1, Data	Data[0]=PointValueEndFunction RemovePointsFromStartOfWave(Data,NDeletePts)	Wave Data	Variable NDeletePts		if (WaveExists(Data))		DeletePoints 0, NDeletePts, Data	endifEndFunction RemovePointsFromEndOfWave(Data,NDeletePts)	Wave Data	Variable NDeletePts		Variable LastPt=numpnts(Data)-NDeletePts	DeletePoints LastPt, NDeletePts, DataEnd// This does not work on Text WavesFunction ReverseWaveOrder(Data)	Wave Data		if (waveexists(Data)==1)		Reverse Data	endifEndFunction ReverseTextWaveOrder(DataWave)	Wave /T DataWave		Variable Npts	if (waveexists(DataWave)==1)		Npts = numpnts(DataWave)		Duplicate /O/D/T DataWave, tempwave		DataWave[] = tempwave[Npts-p-1]		KillWaves /Z tempwave	endifEndFunction CountValuesInWave(data,value,tol)	Wave data	Variable value, tol		Variable i, diff, NumValues=0, NumPts = numpnts(data)		for (i=0;i<NumPts;i+=1)		diff = abs(data[i] - value)		if (diff < tol)			NumValues+=1		endif	endfor		return NumValuesEndFunction ExtremumValueInWave(DataWave,ChoiceFlag)	Wave DataWave	Variable ChoiceFlag		if (numpnts(DataWave) == 0)		return 0	else		WaveStats /Q DataWave		if (ChoiceFlag == 1)			return V_min		elseif (ChoiceFlag == 2)			return V_max		elseif (ChoiceFlag ==3)			return max(abs(V_min),abs(V_max))		endif	endifEnd