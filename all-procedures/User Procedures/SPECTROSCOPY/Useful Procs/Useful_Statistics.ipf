#pragma rtGlobals=1		// Use modern global access method.Menu "Analysis"	"Test Random Distribution"End// ********************************************************// ***	Numerical Integration: The product of a function and a probability distn// ********************************************************// General approach for integrating a function f(r1,u2, ... ,un) over a distribution, n(r1,r2, ... ,rn)// in order to find an expectation value. // It is important that the axis of the distribution is the first coefficient of f(). Function ProbDistFuncInt(Nr, Fn, fAxis, fFunction, fTempFn, fCoeffs, rAxis, rCoeffs)	FUNCREF UnityFunction Nr		// The probability distribution function, PDF(r,a1,a2, ... ,an)	FUNCREF UnityFunction Fn		// The function, f(r1,u2, ... ,un)	Wave fAxis, fFunction, fTempFn, fCoeffs, rAxis, rCoeffs		Variable i, prob, delta, meanR, NrPts = numpnts(rAxis)		// Save the distribution parameter, which we will integrate over	meanR		= fCoeffs[0]		fFunction 	= 0	for (i=0;i<NrPts;i+=1)				// *&*&*&*&*&*&		fCoeffs[0]	= rAxis[i]		// <--- The distribution parameter is the FIRST of the function coefficients		// *&*&*&*&*&*&				// Evaluate the function at axis[i]		prob		= Nr(rCoeffs,fCoeffs[0])		fTempFn[]	= prob*Fn(fCoeffs,fAxis[p])				fCoeffs[0]	= rAxis[i+1]				// Evaluate the function at axis[i+1]		prob		= Nr(rCoeffs,fCoeffs[0])		fTempFn[]	+= prob*Fn(fCoeffs,fAxis[p])				// Need to consider non-constant step size. Use trapzoidal rule		delta = (rAxis[i+1] - rAxis[i])/2				fFunction[] += delta * fTempFn[p]	endfor		// Recall the distribution parameter	fCoeffs[0]	= meanREndSTATSPoissonCDFFunction AvgFnWithGaussianNoise(Fn, fAxis, fFunction, fCoeffs, sigma, nAvgs)	FUNCREF UnityFunction Fn		// The function, f(r1,u2, ... ,un)	Wave fAxis, fFunction, fCoeffs	Variable sigma, nAvgs		Variable i, Rmean		Rmean = fCoeffs[0]		fFunction 	= 0	for (i=0;i<nAvgs;i+=1)				// Add random noise to the actual input value		fCoeffs[0]	= Rmean + gnoise(Rmean*sigma)				fFunction[] += Fn(fCoeffs,fAxis[p])	endfor	fFunction /= nAvgs		fCoeffs[0]	= RmeanEnd// ********************************************************// ***	Numerical Integration: A function// ********************************************************// REPLACE WITH Integrate1D, although this can skip NANsFunction IntegrateFunction(pdf,cw,xstart,xstop, [nxsteps])	FUNCREF UnityFunction pdf	Wave cw	Variable xstart,xstop,nxsteps	//	nxsteps = (ParamIsDefault(nxsteps)) ? nxsteps : 100		if (ParamIsDefault(nxsteps) == 1)		nxsteps = 100	endif		Variable i, int, temp=0, NumPts = numpnts(Data)	Variable x1=xstart, x2, xstep, y1, y2, delta, base1, base2, tanAlpha		xstep = abs(xstop - xstart)/(nxsteps)		for (i=0;i<nxsteps;i+=1)		x2 		= x1+xstep		delta	= abs(x2-x1)				y1 = pdf(cw,x1)		y2 = pdf(cw,x2)				if ((numtype(y1) != 0) || (numtype(y2) != 0))			// Just skip NAN or Inf points ... is this right?		else			if (sign(y1*y2) == -1)				// We're crossing y=0, and must split the area into two triangles. 				tanAlpha	= (abs(y1) + abs(y2))/delta				base1	= abs(y1)/tanAlpha				base2	= abs(y2)/tanAlpha								int = 0.5*y1*base1 + 0.5*y2*base2			else				// y1 and y2 are either both positive or both negative				int = 0.5 * sign(y1) * abs(y2 + y1) * delta			endif						temp += int		endif					x1 = x2	endfor		return tempEnd// ********************************************************// ***	Numerical Integration: A wave// ********************************************************// REPLACE WITH faverage (perhaps this is needed, tho' for NANs)Function IntegrateWave(Axis,Data,StartIndex,EndIndex)	Wave Axis, Data	Variable StartIndex,EndIndex		Variable i, int, temp=0, NumPts = numpnts(Data)	Variable x1, x2, y1, y2, delta, base1, base2, tanAlpha			if (NumPts != numpnts(Axis))		Print " *** The data and axes have different numbers of points!"		return NAN	else		for (i=StartIndex;i<EndIndex;i+=1)			y1 = Data[i]			y2 = Data[i+1]						if ((numtype(y1) != 0) || (numtype(y2) != 0))				// Just skip NAN or Inf points ... is this right?				// Assume the Axis is well-behaved. 			else				x1 = Axis[i]				x2 = Axis[i+1]								// This works even in we're crossing x=0				delta = abs(x2 - x1)								if (sign(y1*y2) == -1)					// We're crossing y=0, and must split the area into two triangles. 					tanAlpha	= (abs(y1) + abs(y2))/delta					base1	= abs(y1)/tanAlpha					base2	= abs(y2)/tanAlpha										int = 0.5*y1*base1 + 0.5*y2*base2				else					// y1 and y2 are either both positive or both negative					int = 0.5 * sign(y1) * abs(y2 + y1) * delta				endif								temp += int			endif		endfor	endif		return tempEnd// ********************************************************// ***		Automatically Determine the best axis for a probability distribution// ********************************************************Function EvenlySpaceDistributionAxis(cdf,cw,axis,rstart,logFlag)	FUNCREF UnityFunction cdf	Wave cw, axis	Variable rstart, logFlag		Variable i=0, j=1, k, r, rstep, rpoint, prob, tail=0.0025	Variable minX, maxX, range, scale, step	Variable NAPts 	= numpnts(axis)	Variable NPrePts = 2		rstep	= cw[0]/1000	rpoint = rstart		do		// First axis point		rpoint += rstep		prob = cdf(cw,rpoint)	while(prob<tail)		// Enforce positive, non-zero second point	minX = max(rstep/2,rpoint-NPrePts*rstep)		rstep *= 10	do		// Last axis point		rpoint += rstep		prob = cdf(cw,rpoint)	while(prob<(1-tail))	maxX = rpoint		range 		= maxX-minX		step = range/(NAPts-trunc(NAPts/3))		axis[1] 			= minX	axis[2,NAPts-1] 	= axis[1] + step*(x-1)		// Enforce positive definite smaller first point	axis[0] 			= max(rstep/10,axis[1] - step)EndFunction LogSpacedDistributionAxis(cdf,cw,axis,rstart,logFlag)	FUNCREF UnityFunction cdf	Wave cw, axis	Variable rstart, logFlag		Variable i=0, j=1, k, r, rstep, rpoint, prob	Variable minX, maxX, range, scale, step	Variable NAPts 	= numpnts(axis)	Variable NPrePts = 2		rstep	= cw[0]/1000	rpoint = rstart		do		// First axis point		rpoint *= 1.1		prob = cdf(cw,rpoint)	while(prob<0.0025)		// Enforce positive, non-zero second point	Variable min1 = rstep/2	Variable min2 = rpoint-NPrePts*rstep	minX = max(rstep/2,rpoint-NPrePts*rstep)		rstep *= 10	do		// Last axis point		rpoint *= 1.1		prob = cdf(cw,rpoint)	while(prob<0.95)	maxX = rpoint		range 		= maxX-minX		// This scale seems good by trial and error	scale = 10^(log(1 + range)/(NApts-5))		axis[1] 			= 1	axis[2,NAPts-2] 	= scale*axis[p-1]	axis[0] 			= axis[1]/(5*scale)	axis[NAPts-1] 	= axis[NAPts-2] + (axis[2]-axis[1])	axis += (minX - 1)End// ********************************************************// ***							Random Number Routines// ********************************************************Proc TestRndStats()	PauseUpdate; Silent 1		Variable i=0	Make /D/O/N=1000 StatsWave	do		StatsWave[i] = RandomInteger(0,8,-1)		i+=1	while(i<1000)EndFunction RandomInteger(MinInt,MaxInt,NOTNum)	Variable MinInt,MaxInt,NOTNum	Variable Integer, Range = (1 + MaxInt - MinInt)/2		do		Integer = trunc(Range + MinInt + enoise(Range))	while(Integer == NOTNum)		return IntegerEndFunction RandomizeWaveValues(ValueWave,RndValueWave)	Wave ValueWave, RndValueWave		Variable i, index, n=numpnts(ValueWave)	//	Make /O/D/N=(n) RndValueWave=nan	RndValueWave=nan		for (i=0;i<n;i+=1)		do			index = RandomInteger(0,(n-1),-1)		while(numtype(RndValueWave[index]) == 0)				RndValueWave[index] = ValueWave[i]	endfor	//	ValueWave = RndValueWave	//	KillWaves /Z RndValueWaveEnd// What is this for? Function MeanRandomExtremes()		Variable minR=20, maxR=-20, i=0, Rnd	do		Rnd = 0.5 + enoise(0.5)				minR = min(minR,Rnd)		maxR = max(maxR,Rnd)		i+=1	while(i<10000)		Print "Max is", maxR,"and min is",minR		return 1End// ********************************************************// ***		Testing and Plotting Values Taken Randomly from Distribution Fns// ********************************************************Function TestRandomDistribution()		String OldDF = GetDataFolder(1)	NewDataFolder /O/S root:Statistics			String /G gDistribution		Variable /G gNTries, gMeanR, gVarR				Variable NTries = gNTries		Prompt NTries,"How many tries?"		String Distribution=gDistribution		Prompt Distribution,"Select distribution",popup,"normal;lognormal;schultz;"		Variable MeanR=gMeanR		Prompt MeanR,"Mean"		Variable VarR = gVarR		Prompt VarR, "Sigma"				DoPrompt "Probability distribution Parameters", NTries, Distribution, MeanR, VarR		if (V_flag)			return 0		endif				gNTries	= NTries		gMeanR 	= MeanR		gVarR 		= VarR		gDistribution		= Distribution				String CDF = Distribution + "CDFCoeff"		String PDF = Distribution + "PDFCoeff"		Variable i=0, NumBins, BinWidth = 0.1				Make /O/D/N=(NTries) RndSizeWave		Make /O/D/N=1 RndSizeDist		Make /O/D Tcw				Tcw[0] 	= MeanR		Tcw[1]	= MeanR * VarR				Print " *** Randomly sampling",Distribution,"distribution"				do			RndSizeWave[i] = RandomValueFromDistribution($CDF,Tcw)							i+=1		while(i<NTries)				WaveStats /Q RndSizeWave		if (V_sdev > 0)			BinWidth	= 0.25			NumBins	= (V_max - V_min)/BinWidth			Histogram /B={V_min,BinWidth,NumBins} RndSizeWave, RndSizeDist					Make /O/N=(NumBins) xAxis, DistFn			xAxis = V_min + x*BinWidth						DistFn[] = ProbabilityDistributionFn($PDF,xAxis[p],Tcw)						String GraphName = WinList("RndDist",";","WIN:1")			if (strlen(GraphName)==0)				DistributionFunctionPlot(xAxis,DistFn,"x","Frequency")				DoWindow /C RndDist								AppendToGraph/R RndSizeDist vs xAxis				ModifyGraph mode(RndSizeDist)=5,rgb(DistFn)=(0,0,65535)				Label right PDF			endif		endif				KillWaves /Z Tcw			SetDataFolder $(OldDF)EndFunction RandomValueFromDistribution(cdf,cw)	FUNCREF UnityFunction cdf	Wave cw		// A random number between 0 - 1	Variable Root, Rnd = 0.5 + enoise(0.5)		FindRoots /Q/Z=(Rnd) cdf, cw		// Note that this value may be negative!!	return V_rootEndFunction RandomSizeFromDistribution(SizeDistType,Radius,Sigma)	Variable SizeDistType,Radius,Sigma		Variable RndSize, MinRadius=Radius/20		Make /D/O/N=2 Tcw	Tcw[0] = Radius//	Tcw[1] = Sigma	Tcw[1] = Sigma*Radius		if (SizeDistType == 1)		RndSize =  Radius	// Monodisperse	elseif (SizeDistType == 2)		RndSize = RandomValueFromDistribution(NormalCDFCoeff,Tcw)	elseif (SizeDistType == 3)		RndSize = RandomValueFromDistribution(LogNormalCDFCoeff,Tcw)	elseif (SizeDistType == 4)		RndSize = RandomValueFromDistribution(SchultzCDFCoeff,Tcw)	endif		KillWaves /Z Tcw		// This is necessary to prevent the occasional zero or negative radius!	return max(RndSize,MinRadius)EndFunction ProbabilityDistributionFn(cdf,x,cw)	FUNCREF UnityFunction cdf	Variable x	Wave cw		return cdf(cw,x)EndFunction /T ProbDistNameFromType(SizeDistType)	Variable SizeDistType		if (SizeDistType == 1)		return "monodisperse"	elseif (SizeDistType == 2)		return "NormalPDFCoeff"	elseif (SizeDistType == 3)		return "LogNormalPDFCoeff"	elseif (SizeDistType == 4)		return "SchultzPDFCoeff"	endifEnd// ********************************************************// ***			Plotting Probability Distribution Functions// ********************************************************Function PlotDistributionFunctions(cw,x0,x1)	Wave cw	Variable x0,x1		Variable xStep = (x1-x0)/101		String OldDF = GetDataFolder(1)	NewDataFolder /O/S root:Statistics				Make /O/N=101 xAxis, P_Normal, P_LogNormal, P_Schultz		xAxis = x*xStep				P_Schultz[] 		= SchultzPDFCoeff(cw,xAxis[p])		P_Normal[] 		= NormalPDFCoeff(cw,xAxis[p])		P_LogNormal[] 	= LogNormalPDFCoeff(cw,xAxis[p])				Make /O/N=101 C_Normal, C_LogNormal, C_Schultz				C_Schultz[] 		= SchultzCDFCoeff(cw,xAxis[p])		C_Normal[] 		= NormalCDFCoeff(cw,xAxis[p])		C_LogNormal[] 	= LogNormalCDFCoeff(cw,xAxis[p])				String GraphName = WinList("DistFns",";","WIN:1")		if (strlen(GraphName)==0)			DistributionFunctionPlot(xAxis,P_Schultz,"x","N(x)")			DoWindow /C DistFns				AppendToGraph /W=DistFns P_Normal vs xAxis			AppendToGraph /W=DistFns P_LogNormal vs xAxis			AppendToGraph /R/W=DistFns C_Schultz vs xAxis			AppendToGraph /R/W=DistFns C_Normal vs xAxis			AppendToGraph /R/W=DistFns C_LogNormal vs xAxis			ColorTraces("")			AddLegend()		endif			SetDataFolder $(OldDF)EndFunction DistributionFunctionPlot(Axis,Prob,xLabel,yLabel)	Wave Axis, Prob	String xLabel,yLabel		Display /K=1/W=(937,179,1312,499) Prob vs Axis as "Distribution Functions"	CheckWindowPosition("",937,179,1312,499)		ModifyGraph mirror(bottom)=2	Label left yLabel	Label bottom xLabelEndFunction UnityFunction(cw,x)	Wave cw	Variable x		return 1End// ********************************************************// ***							SCHULTZ DISTRIBUTION// ********************************************************//	See: 	Kotlarchyk, M.; Chen, S.-H. J. Chem. Phys. 1983, 79, 2461//			D. Pontoni, T. Narayanan,and A. R. Rennie, Langmuir 2002, 18, 56-59Function SchultzPDF(r,rAvg,var)	Variable r,rAvg,var		Variable ZPlus1, Z, Exponent, Expon1, Expon2, Expon3, Expon4  	ZPlus1 	= (rAvg/Var)^2	Z = ZPlus1 - 1	  	Expon1	= Z*ln(r)	Expon2	= (ZPlus1)*ln(ZPlus1/rAvg)	Expon3	= ZPlus1*(r/rAvg)	Expon4	= gammln(ZPlus1,10e-10) 		Exponent = Expon1 + Expon2 - Expon3 - Expon4		if (Exponent < -730)		return 0	else		return exp(Exponent)	endifEndFunction SchultzPDFCoeff(cw,x)	Wave cw	Variable x		Variable SchultzCDF = SchultzPDF(x,cw[0],cw[1])		return SchultzCDFendFunction SchultzCDF(r,rAvg,var)	Variable r,rAvg,var		Make /O/D/N=2 SchultzCW	SchultzCW[0] = rAvg	SchultzCW[1] = var		Variable SchultzCDF = SchultzCDFCoeff(SchultzCW,r)		KillWaves /Z SchultzCW		return SchultzCDFendFunction SchultzCDFCoeff(cw,x)	Wave cw	Variable x		Variable xstart=0, xstop=x		Variable SchultzCDF = IntegrateFunction(SchultzPDFCoeff,cw,xstart,xstop, nxsteps=100)		return SchultzCDFEnd// ********************************************************//							NORMAL (Gaussian) DISTRIBUTION//		Now a built in Igor Function: StatsNormalPDF(x,u,s) and StatsNormalCDF(x,u,s)// 		Also see: http://en.wikipedia.org/wiki/Gaussian_distribution// ********************************************************Function NormalPDFCoeff(cw,x)	Wave cw	Variable x		return StatsNormalPDF(x,cw[0],cw[1])EndFunction NormalCDFCoeff(cw,x)	Wave cw	Variable x		return StatsNormalCDF(x,cw[0],cw[1])End//Function LogNormalPDFCoeff(cw,x)//	Wave cw//	Variable x//	//	Variable nm = StatsNormalPDF(ln(x),cw[0],cw[1])//	//	return nm/x//End////Function LogNormalCDFCoeff(cw,x)//	Wave cw//	Variable x//	//	Variable nm = StatsNormalCDF(ln(x),cw[0],cw[1])//	//	return nm/x//End// ********************************************************//							LOG-NORMAL DISTRIBUTION//		Now a built in Igor Function: StatsLogNormalPDF(x, sigma [, theta, mu ]) and StatsLogNormalCDF(x, s [, theta, mu ])//		However, a slightly different expression than given at:// 					http://en.wikipedia.org/wiki/Log-normal_distribution//		And there is yet another definition used in the SAXSFit Manual. // ********************************************************//		The routines were tested to agree with the Normal dist Aug 07// ********************************************************// For a STABLE CDF expresion, set theta to be a small non-zero number. // To acheive comparable Normal and LogNormal distributions for the same params ...// ... divide the µ value by the sigma value. //// 2011-04 Hmmm ... // 	cw[0] is the location parameter, = theta. // cw[1] is sigma, the width parameter 0 < sigma < 1Function LogNormalPDFCoeff(cw,x)	Wave cw	Variable x		Variable sigma = cw[1]/cw[0]	return StatsLogNormalPDF(x,sigma,0,cw[0])	//	Variable r = x-cw[0]//	return StatsLogNormalPDF(x,cw[1],cw[0]-cw[0]*cw[1],cw[0])End// 	Uses StatsLogNormalCDF(x,sigma,[theta,mu])Function LogNormalCDFCoeff(cw,x)	Wave cw	Variable x		Variable sigma = cw[1]/cw[0]	//	return StatsLogNormalCDF(x,sigma,0,100)	return StatsLogNormalCDF(x,sigma,0,cw[0])//	return StatsLogNormalCDF(x,sigma,0.001,cw[0])	//	Variable r = x-cw[0]//	return StatsLogNormalCDF(x,cw[1],cw[0]-cw[0]*cw[1],cw[0])End	// ********************************************************//							Interrogating Statistical Distributions// ********************************************************Function Stats_Mean(x, Px, Ix1, Ix2)	Wave x, Px	Variable Ix1, Ix2		Duplicate /O/D x, temp	temp[] = x[p] * Px[p]		// Calculate the MEAN:	Variable Mu =  areaXY(x,temp,Ix1,Ix2)/areaXY(x,Px,Ix1,Ix2)//	Variable Mu = sum(temp,Ix1,Ix2)		KillWaves /Z temp	return MuEndFunction Stats_NthMoment(x, Px, n, Ix1, Ix2)	Wave x, Px				// n=1 is zero by definition	Variable n, Ix1, Ix2		// n=2 is the variance, take the square root to find FWHM		// Calculate the MEAN:	Variable Mu = Stats_Mean(x, Px, Ix1, Ix2)		Duplicate /O/D x, temp	temp[] = (x[p] - Mu)^n * Px[p]		Variable Mom = areaXY(x,temp,Ix1,Ix2)/areaXY(x,Px,Ix1,Ix2)//	Variable Mom = sum(temp,Ix1,Ix2)		KillWaves /Z temp	return Momend// A very useful function that is NOT built in to Igor. Function Stats_DistLimits(x, Px, AreaFactor, Ix1, Ix2)	Wave x, Px	Variable AreaFactor, Ix1, Ix2		// Calculate the MEAN:	Variable Mu = Stats_Mean(x, Px, Ix1, Ix2)		// Find the total area	Variable Atot = areaXY(x,Px,Ix1,Ix2)//	Print " The area under the distribution is", Atot		// Find the value of the distribution at the mean x	Variable Xm = BinarySearchInterp(x, Mu)//	Print " The x-position of the mean is", x[Xm]	Variable Pm = Px[Xm]//	Print " The distribution value at the mean x is", Pm		Variable Int, j, k=0, w1, w2, Acent	Variable NumPts = numpnts(x)		Int = Pm	do//		Print " Int = ", Int		// Look for the negative intercept		j = Xm		do			j-=0.25						if (j<0)				j=0				break			endif		while(Px[j]>Int)		w1 = j				// Look for positive intercept		j = Xm		do			j+=0.25						if (j>NumPts)				j=NumPts-1				break			endif		while(Px[j]>Int)		w2 = j				Acent = areaXY(x,Px,w1,w2)//		Print " Acent = ", Acent				if (Acent/Atot>AreaFactor)			break		endif				k+=1		if (k>10000)			Print " *** Problem finding the distribution limits!!"			break		endif				Int *= 0.75	while(1)		NVAR xmax=xmax	NVAR xmin=xmin		if (NVAR_Exists(xmax) == 1)		xmax = max(x[w1],x[w2])		xmin = min(x[w1],x[w2])	else		Variable /C limits	endifend	// ********************************************************//					OBSOLETE// ********************************************************//Integrate//AreaXY// This is not a proper integration if the x-axis doesn't have a constant step. Function SumWaveWithNANs(Data,StartIndex,EndIndex)	Wave Data	Variable StartIndex,EndIndex		Variable i, y1, summ=0, NumPts = numpnts(Data)		for (i=StartIndex;i<EndIndex;i+=1)		y1 = Data[i]				if (numtype(y1) != 0)			// Just skip NAN or Inf points ... 		else			summ += y1		endif	endfor		return summEnd