#pragma rtGlobals=1		// Use modern global access method.// ********************************************************// ******     				**BETTER** PROMPTING FOR USER INPUT// ********************************************************Function PromptForUserYesNoInput(Msg,DefaultFlag)	String Msg	Variable DefaultFlag		Variable Flag = DefaultFlag	Prompt Flag, Msg, popup, "yes;no"	DoPrompt Msg, Flag		if (V_flag)		return -1	else		return Flag	endifEndFunction PromptForUserVarInput(DefaultVar,VarDescription,Msg)	Variable DefaultVar	String VarDescription, Msg		Variable InputVar=DefaultVar	Prompt InputVar, VarDescription		DoPrompt Msg, InputVar		if (V_flag)		return NAN	else		return InputVar	endifEndFunction /T PromptForUserStrInput(DefaultStr,VarDescription,Msg)	String DefaultStr, VarDescription, Msg		String InputStr=DefaultStr	Prompt InputStr, VarDescription		DoPrompt Msg, InputStr		if (V_flag)		return "_quit!_"	else		return InputStr	endifEnd// ********************************************************// ******     		SAVING DATA IN FORMATTED NOTEBOOK FORM// ********************************************************Function OutputFixedStepAxisFile(AxisName,DataName,DataFolder,MinAxisValue,MaxAxisValue,Tolerance,FormatList,FileName)	String AxisName, DataName	String DataFolder, FormatList,FileName	Variable MinAxisValue,MaxAxisValue,Tolerance		WAVE Axis = $AxisName	WAVE Data = $DataName		Variable AxisStep, AxisMinPt, AxisMaxPt, NumAxisPts	AxisMinPt = BinarySearch($AxisName, MinAxisValue)	AxisMaxPt = BinarySearch($AxisName, MaxAxisValue)		// Make a temporary axis for output to enforce constant step size. 	AxisStep = CheckConstantStep(Axis,Tolerance,0)	NumAxisPts = trunc(abs(Axis[AxisMaxPt] - Axis[AxisMinPt])/abs(AxisStep)) + 1	Make /O/D/N=(NumAxisPts) SaveAxisWave, SaveDataWave	SaveAxisWave[] = min(Axis[AxisMinPt],Axis[AxisMaxPt]) + abs(AxisStep) * x		// do we have to extrapolate onto the output axis?	if (NumAxisPts == numpnts(Data))		SaveDataWave[] = Data[AxisMinPt+p]	else		Interpolate2/N=(NumAxisPts) /X=SaveAxisWave /Y=SaveDataWave $AxisName, $DataName 	endif	WaveStats /Q SaveDataWave	if (V_min < 0)		SaveDataWave += abs(V_min)	endif	SaveDataWave *= 1e6/V_max		String HeaderLineList="",ColumnList,PaddingList	String LeftDelimiter="  ",Delimiter="    "	Variable AppendFlag = 0, LinePadLen = 60		ColumnList = NameOfWave(SaveAxisWave) + ";" + NameOfWave(SaveDataWave)+";"//	FormatList = "%5.3f;%d;"	PaddingList = "0;0;"				UltimateSavePadDelColumnFile("_new_",0,1,AppendFlag,HeaderLineList,"",ColumnList,FormatList,PaddingList,LeftDelimiter,Delimiter,80,1,0,NumAxisPts,FileName,"")End//	/M=termStr	Specifies the terminator character or characters to use at the end of each line of text. //	The default is /M="\r", which uses a carriage return character. This is the Macintosh convention. //	To use the Windows convention, carriage return plus linefeed, specify /M="\r\n". //	To use the Unix convention, just a linefeed, specify /M="\n".Function /T ReturnEOLCharacter(EOLFlag,MsgFlag)	Variable EOLFlag, MsgFlag		String EOLChar, msg		if (EOLFlag == 0)		// Automatically handles end-of-line character		if (cmpstr("Macintosh",IgorInfo(2)) == 0)			EOLFlag = 1		elseif (cmpstr("Windows",IgorInfo(2)) == 0)			EOLFlag = 2		else			EOLFlag = 3		endif	endif		if (EOLFlag == 1)		msg 		= " *** Text file saved with CARRIAGE RETURN only at end-of-line (Macintosh  convention)"		EOLChar 	= "\r"	elseif (EOLFlag == 2)		// *!*!*! Debug - this is not wrking//		msg 		= " *** Text file saved with CARRIAGE RETURN only at end-of-line (Macintosh  convention)"//		EOLChar 	= "\r"		msg 		= " *** Text file saved with CARRIAGE RETURN and a LINEFEED at end-of-line (Windows  convention)"		EOLChar 	= "\r\n"	elseif (EOLFlag == 3)		msg 		= " *** Text file saved with LINEFEED only at end-of-line (Unix  convention)"		EOLChar 	= "\n"	endif		if (MsgFlag == 1)		Print msg	endif		return EOLCharEnd// Note: The data column waves are given as names in a list. Thus, they must be present in the same data folder, or given as a full datafolder nameFunction UltimateSavePadDelColumnFile(UserNoteBookName,EOLFlag,MsgFlag,AppendFlag,HeaderLineList,FooterLineList,ColumnList,FormatList,PaddingList,LeftDelimiter,Delimiter,TotPadLine,NDataPts,SaveFlag,ShowChoice,FileName,PathName)	String UserNoteBookName,HeaderLineList,FooterLineList, ColumnList, FormatList, PaddingList, LeftDelimiter, Delimiter,FileName,PathName	Variable AppendFlag,EOLFlag,MsgFlag,TotPadLine, NDataPts,SaveFlag,ShowChoice		Variable NumHeaderLines, NumColumns, NumPoints, i, j, k	String NoteBookName="", HeaderStr, HeaderSeparator=";", ColName, FormatStr, PadStr, TextStr, ValueStr, Padding		String EOLChar = ReturnEOLCharacter(EOLFlag,MsgFlag)		// Check the existence or creation of the NoteBook for the columns	if ((cmpstr("_new_",UserNoteBookName)==0) || (AppendFlag == 0))		// Ensure we can start from scratch		AppendFlag = 0		NoteBookName = "ColumnBook"		DoWindow /K $NoteBookName		NewNotebook /V=0/F=0/N=$NoteBookName	else		// Check that the named notebook exists		NoteBookName = StringFromList(0,WinList(UserNoteBookName,";","WIN:16"))		if (strlen(NoteBookName) == 0)			AppendFlag = 0			// ... if not we must create it			NoteBookName = UserNoteBookName			NewNotebook /V=0/F=0/N=$NoteBookName		endif	endif		NumColumns = ItemsInList(ColumnList,";")		// Allow FOOTER lines to be written for both new and appended files. //	if (AppendFlag == 0)	if (cmpstr("_none_",HeaderLineList) != 0)		NumHeaderLines = ItemsInList(HeaderLineList,HeaderSeparator)				for (j=0;j<NumHeaderLines;j+=1)			HeaderStr = StringfromList(j,HeaderLineList,HeaderSeparator)			SVAR Header	= $HeaderStr						if (SVAR_Exists(Header) == 1)				// Either pass the header as a global string ... 				Padding = MakeStringOfChars(TotPadLine - strlen(Header)," ")				TextStr = Header + Padding			else				// ... or as a list item. 				Padding = MakeStringOfChars(TotPadLine - strlen(HeaderStr)," ")				TextStr = HeaderStr + Padding			endif							Notebook $NoteBookName, selection={endOfFile,endOfFile}, text=TextStr + EOLChar		endfor	endif//	endif	// Write the data into the new notebook	for (i=0;i<NDataPts;i+=1)		TextStr = LeftDelimiter				// The initial columns		for (j=0;j<NumColumns-1;j+=1)			FormatStr 	= StringfromList(j,FormatList,";")			ColName 		= StringfromList(j,ColumnList,";")						if (cmpstr("%s",FormatStr[0,1])==0)				WAVE /T TextColumn = $ColName				sprintf ValueStr, FormatStr, TextColumn[i]			else				WAVE Column = $ColName				sprintf ValueStr, FormatStr, Column[i]			endif						PadStr = StringfromList(j,PaddingList,";")			TextStr += ReturnPaddedValueStr(ValueStr,PadStr) + Delimiter		endfor				// The last column		j = NumColumns-1		FormatStr = StringfromList(j,FormatList,";")		ColName 	= StringfromList(j,ColumnList,";")					if (cmpstr("%s",FormatStr[0,1])==0)			WAVE /T TextColumn = $ColName			sprintf ValueStr, FormatStr, TextColumn[i]		else			WAVE Column = $ColName			sprintf ValueStr, FormatStr, Column[i]		endif				PadStr = StringfromList(j,PaddingList,";")		TextStr += ReturnPaddedValueStr(ValueStr,PadStr)					if (TotPadLine > 0)			Padding = MakeStringOfChars(TotPadLine - strlen(TextStr)," ")			TextStr += Padding		endif				Notebook $NoteBookName, selection={endOfFile,endOfFile}, text=TextStr + EOLChar	endfor		// 	Allow FOOTER lines to be written for both new and appended files. 	// 	Only pass the footer as a list item. 	NumHeaderLines = ItemsInList(FooterLineList,HeaderSeparator)	for (j=0;j<NumHeaderLines;j+=1)		HeaderStr = StringfromList(j,FooterLineList,HeaderSeparator)		TextStr = PadString(HeaderStr,TotPadLine,0x20)		Notebook $NoteBookName, selection={endOfFile,endOfFile}, text=TextStr + EOLChar	endfor	if (SaveFlag)		if (CheckValidPathName(PathName)==0)			if (strlen(PathName) == 0)				PathName = "ExportPath"			endif			NewPath /M="Location for export"/O/Q $PathName		endif		if (V_flag == 0)			SaveNotebook /P=$PathName $NoteBookName as FileName			Print " *** File saved to location",S_path		endif	endif		if (ShowChoice == 0)		DoWindow /K $NoteBookName	elseif (ShowChoice == 1)		// Leave open but hidden	elseif (ShowChoice == 2)		DoWindow /F $NoteBookName	endif		return 1EndFunction CheckValidPathName(PathName)	String PathName		PathInfo $PathName	if (V_flag == 0)		return 0	else		GetFileFolderInfo /Q/Z=1/P=$PathName		if (V_flag == 0)			return 1		else			return 0		endif	endifEnd	// ********************************************************// ******     SUBSIDIARY DATA SAVING AND LOADING FUNCTIONS// ********************************************************// Returns the entire line  containing the keyword or "" if it is not present in the file. Function /T LookforKeyWordInFile(pathName,FileName,keyword)	String pathName, FileName, keyword		String KeywordLine	Variable KeyLineNum, refNum = 0		Open/R/P=$pathName refNum as fileName	if (refNum == 0)		return ""	// User canceled	endif		KeywordLine 	= ReturnKeyWordLineInOpenfile(refNum,keyword,KeyLineNum,0)		Close refNum		return KeywordLineEndFunction IsIgorTextFile(pathName, fileName)	String pathName		// Igor symbolic path name or ""	String fileName		// File name or full path to file		String KeyLine = LookforKeyWordInFile(pathName,fileName,"IGOR")		if (strlen(KeyLine) > 0)		return 1	else 		return 0	endifEndFunction /T ReturnKeyWordLineInOpenfile(refNum,keyword,keyLineNum,CloseFlag)	Variable refNum, &keyLineNum, CloseFlag	String keyword		String text		FStatus refNum		if (V_flag == 0)		Print " *** Invalid file reference number."		return ""	else		keyLineNum = 0		do			FReadLine refNum, text			keyLineNum += 1				if (strlen(text) == 0)				break	// No more lines to be read			endif						// Search forward, ignore case. 			if (strsearch(text,keyword,0) > -1)				if (CloseFlag)					Close refNum				endif				return text			endif		while(1)	endif		if (CloseFlag)		Close refNum	endif		return ""End//sscanf// Counting from the BEGINNING, first number is ONE not ZEROFunction ReturnNumberFromText(index,textStr)	Variable index	String textStr		String Char, numStr	Variable i, textLen, numStart, numEnd, numNum, EndOfTextFlag	textLen = strlen(textStr)		if (index < 1)		return NAN	endif		EndOfTextFlag = 0	numNum = 0	i=-1	do		// Look for the start of the nth number		do			i+=1			if (i>textLen)				if (numNum==0)					Print " *** There are no numbers in this text!"				else					Print " *** There are no further numbers in this text! Index is",index,". Text is:", textStr				endif				return NAN			endif			Char = textStr[i,i]		while(numtype(str2num(Char)) != 0)		numStart = i				// Determine whether the number is negative		Char = textStr[i-1,i-1]		if (cmpstr("-",Char) == 0)			numStart = i-1		endif				// Look for the end of the nth number		do			i+=1			if (i==textLen-1)				break			endif			Char = textStr[i,i]		while((numtype(str2num(Char)) == 0) || (cmpstr(Char,".")==0))		numEnd=i				numNum+=1				if (numNum==index)			numStr = textStr[numStart,numEnd]			return str2num(numStr)		endif	while(1)End// ********************************************************// ******     Try to control how much information is spewed out// ********************************************************// 	1: No reporting//	2: FAIL statements//	3: Control structure//	4. EverythingFunction ReportingEngine(FolderName,Msg,BlankAbove,BlankBelow)	String FolderName, Msg	Variable BlankAbove,BlankBelow		NVAR	gReportFlag		= $(CheckFolderColon(FolderName)+"gReportFlag")		if (NVAR_Exists(gReportFlag) == 1)		if (gReportFlag == 1)			return 1		elseif (gReportFlag == 4)			PrintNoteBookMsg(Msg,BlankAbove,BlankBelow)			return 1		endif				if ((gReportFlag == 3) && (StrSearch(Msg,"CONTROL",0)>-1))			PrintNoteBookMsg(Msg,BlankAbove,BlankBelow)		endif				if ((gReportFlag > 1) && (StrSearch(Msg,"FAIL",0)>-1))			PrintNoteBookMsg(Msg,BlankAbove,BlankBelow)		endif	endifEndFunction PrintNoteBookMsg(TextStr,BlankAbove,BlankBelow)	String TextStr	Variable BlankAbove,BlankBelow		if (BlankAbove == 1)		Notebook HistoryNoteBook, selection={endOfFile,endOfFile}, text="\r"	endif	Notebook HistoryNoteBook, selection={endOfFile,endOfFile}, text=TextStr	Notebook HistoryNoteBook, selection={endOfFile,endOfFile}, text="\r"	if (BlankBelow == 1)		Notebook HistoryNoteBook, selection={endOfFile,endOfFile}, text="\r"	endifEndFunction PrintCommandMsg(Msg,BlankAbove,BlankBelow)	String Msg	Variable BlankAbove,BlankBelow		if (BlankAbove == 1)		Print ""	endif	Print Msg	if (BlankBelow == 1)		Print ""	endifEnd