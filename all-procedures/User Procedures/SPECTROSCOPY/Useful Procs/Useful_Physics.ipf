#pragma rtGlobals=1		// Use modern global access method.Constant cLightSpeed 		= 299792458 		// m/sConstant chbar 			= 1.054571e-34		// JsConstant cE 				= 1.602176e-19		// CConstant cEMass 			= 9.109381e-31		// kgConstant cAvogadro 		= 6.022141e23		// /moleConstant cFaraday 		= 96485.3365		// Coulombs/moleConstant cR 				= 8.3144621			// J / mol KConstant cR_cal 		= 1.987			// cal / mol KConstant cBoltzmann 		= 1.380650e-23		// J/KConstant cElectron 		= 1.602176e-19		// CConstant cCoulomb 		= 6.24151e+18		// electronsConstant cJ2eV 			= 1.602176e-19		// Constant cPermittivity 	= 8.854187e-12 	// F/m//Constant cm2nm 			= 1e-7 	!*Constant cAMU 			= 1.660538e-27 	// kgConstant cDebye			= 3.1623e-25		// (Jám3)(1/2)// ***************************************************************************// **************** 			Xray Conversion Functions// ***************************************************************************// Calculate the energy uncertainty of ultrafast pulse. // 	Heisenberg: 	dt x df = 1	(t=time; f=frequency)// 	Use 1 Hz = 4.1357 x 10-15 eV// 		from  http://heasarc.nasa.gov/cgi-bin/Tools/energyconv/energyConv.pl// Input in fsFunction TransformLimitedResolution(dt)	Variable dt	return (4.1357)/(dt * 2 * pi)EndFunction Deg2Rad(deg)	Variable deg		return deg * ((2*pi)/360)EndFunction Rad2Deg(rad)	Variable rad	return rad * (360/(2*pi))End// Input: 2-Theta in degrees. // Ouput: Q in reciprocal Œngstroms. Function TwoThetaToQ(lam,tth, [n])	Variable lam, tth, n		// n is an optional refractive index		Variable rIndex	if (ParamIsDefault(n))		rIndex = 1	else		rIndex = n	endif		// Statement include asin of 1/2 of the scattering angle. 	return ((4*pi*rIndex)/lam)*sin((pi/360)*tth)End// Input: Q in reciprocal Œngstroms. // Output: 2-Theta in degreesFunction QToTwoTheta(lam,q)	Variable lam, q		// Statement include asin of 1/2 of the scattering angle. 	return (360/pi)*asin((q*lam)/(4*pi))End// Input: 2-Theta in degrees. // Ouput: d in Œngstroms. Function TwoThetaTod(lam,tth)	Variable lam, tth		return lam/(2*sin((pi/360)*tth))End// Input: d in Œngstroms. // Output: 2-Theta in degrees. Function dToTwoTheta(lam,d)	Variable lam, d		return lam/(2*sin((pi/360)*d))End// --------------------------------------------------------// Transforming from wavelength to eV// 	E.g., 1000 cm-1 = 10,000 nm = 0.1240 eV//		... or .... 1000 cm-1 = 1/8 eV// 		... or .... 8000 cm-1 = 1eV// Input: Wavelength in nm// Ouput: Energy in eVFunction nmtoeV(nm)	Variable nm		return 1239.8/nmEnd// Input: Wavelength in nm// Ouput: Energy in eVFunction eVtonm(eV)	Variable eV		return 1239.8/eVEnd// --------------------------------------------------------// Input: Wavelength in microns// Ouput: Energy in wavenumbersFunction umToWavenumbers(microns)	Variable microns		return 10000/micronsEndFunction WavenumbersToum(cm)	Variable cm		return 10000/cmEndFunction nmToWavenumbers(lambda)	Variable lambda		return (10000*1000)/lambdaEndFunction WavenumbersTonm(cm)	Variable cm		return (10000*1000)/cmEnd// Converts between wavenumbers (cm-1) and eVFunction WavenumbersToeV(cm)	Variable cm		return cm/8065endFunction eVToWavenumbers(eV)	Variable eV		return eV/0.0001239end// ---------------------------------------------------Function InchTomm(Inch)	Variable Inch		return Inch*25.4End// Input: Energy in wavenumbers// Output: Energy in eV//Function cmtoeV(cm)//	Variable cm//	//	return 0.0001239 * cm//End// Input: Energy in eV// Output: Energy in wavenumbers//Function eVtocm(eV)//	Variable eV//	//	return eV/0.0001239//End// Input: SXF 2D detector channel number// Ouput: 1D eV axis Function ChannelToeV(channel,PromptFlag)	Wave channel	Variable PromptFlag		NewDataFolder /O root:SPECTRA		Variable /G gP1Energy, gP2Energy, gP1Channel, gP2Channel		Variable P1Energy	= gP1Energy	Prompt P1Energy, "Energy (eV) of low-energy peak"	Variable P1Channel	= gP1Channel	Prompt P1Channel, "Channel number"	Variable P2Energy	= gP2Energy	Prompt P2Energy, "Energy (eV) of high-energy peak"	Variable P2Channel	= gP2Channel	Prompt P2Channel, "Channel number"	DoPrompt "SXF Energy Calibration", P1Energy, P1Channel, P2Energy, P2Channel	if (V_flag)		return 0	endif		gP1Energy 	= P1Energy	gP2Energy 	= P2Energy	gP1Channel	= P1Channel	gP2Channel	= P2Channel		Variable P1Wavelength = eVtonm(P1Energy)	Variable P2Wavelength = eVtonm(P2Energy)		Variable m	= (P2Wavelength - P1Wavelength)/(P2Channel - P1Channel)		Variable c	= P1Wavelength - m*P1Channel		Duplicate /O channel, wavelength		wavelength[]	 = m*channel[p] + c		channel[]		= nmtoeV(wavelength[p])End// ********************************************************// ******     FOURIER TRANSFORM PROCS // ********************************************************// return the smallest power of 2 not smaller than xFunction/D NextPwr2(x)	variable/D x		return 2^(ceil(benlog2(x)))end// return log base 2Function/D benlog2(x)	variable/D x		return   1.442695040888963*ln(x)end// *** Wavemetrics Procedure, now a function// FFTCmplxToMagPhase converts a complex wave, presumed to be the result of an FFT, to _Mag and _Phase waves.Function FFTCmplexToMgPhs(FFT_Result)	String FFT_Result	PauseUpdate; Silent 1		String FFT_Result_Mag=FFT_Result+"_Mag"	String FFT_Result_Phase=FFT_Result+"_Phase"	Wave /C w=$FFT_Result	Wave /C destw=$FFT_Result_Mag	Wave phasew=$FFT_Result_Phase		Variable n= numpnts(w)	// Pre-transform data length	Variable preFFTn= (n-1) * 2		destw= r2polar(destw)		// Convert to real, discarding imaginary part ...	Redimension/R phasew	// ... and then take only the imaginary part from the FT	phasew= imag(destw)		// Try to avoid glitch at dc	phasew[0]= phasew[1]	// Unwrap into radians	UnWrap 2*Pi,phasew	phasew[0]= 0		Redimension/R destw	Variable FFTfactor= preFFTn/2	destw /= FFTfactor	// was /= n/2 before version 1.1		// Note! is this SetScale statement appropriate? 	SetScale y,0,0,"",destwend// ********************************************************// ******     			Effective Mass Approximation for Nanoparticle Energies// ******					J. M. Ferreyra and C. R. Proetto, PRB 60, 10 672, 1999. // ********************************************************Macro EMA_Predictions(dMax, Eg, Evb, EMin, EMout, EVout, HMin, HMout, HVout, epsilon)	String /G gMaterialName	Variable /G gdMax, gEg, gEvb, gEMin, gEMout, gEVout, gHMin, gHMout, gHVout, gepsilon	Variable dMax=gdMax	Prompt dMax, "Maximum particle diameter (nm)"	Variable Eg=gEg	Prompt Eg, "The band gap (eV)"	Variable Evb=gEvb	Prompt Evb, "The VB energy (eV) on AVS"	Variable EMin=gEMin	Prompt EMin, "Electron effective mass inside"	Variable EMout=gEMout	Prompt EMout, "Electron effective mass outside"	Variable EVout=gEVout	Prompt EVout, "The electron confining potential (eV)"	Variable HMin=gHMin	Prompt HMin, "Hole effective mass inside"	Variable HMout=gHMout	Prompt HMout, "Hole effective mass outside"	Variable HVout=gHVout	Prompt HVout, "The Hole confining potential (eV)"	Variable epsilon=gepsilon	Prompt epsilon, "Dielectric constant"	PauseUpdate; Silent 1		gdMax=dMax	gEg=Eg	gEvb=Evb	gEMin=EMin	gEMout=EMout	gEVout=EVout	gHMin=HMin	gHMout=HMout	gHVout=HVout	gepsilon=epsilon		gMaterialName = PromptForUserStrInput(gMaterialName,"Material Name","Please enter the name of the material")		String VBName, VBAxisName, CBName, CBAxisName, CoulName, EGName	CBName = gMaterialName+"_cb"	CBAxisName = CBName+"_axis"	if ((exists(CBName) == 1) && (exists(CBAxisName)==1))		Duplicate /D/O $CBName, LastCB		Duplicate /D/O $CBAxisName, LastCBAxis	endif		VBName = gMaterialName+"_vb"	VBAxisName = VBName+"_axis"	if ((exists(VBName) == 1) && (exists(VBAxisName)==1))		Duplicate /D/O $VBName, LastVB		Duplicate /D/O $VBAxisName, LastVBAxis	endif	EMA_VB_Predictions(gMaterialName, dMax, Eg, Evb, HMin, HMout, HVout)	EMA_CB_Predictions(gMaterialName, dMax, Eg, Evb, EMin, EMout, EVout)		CoulName = gMaterialName + "_Coulomb"	Duplicate /D/O $CBName, $CoulName	$CoulName = EMA_CoulombTerm(epsilon,Evb,Eg,EVout,EMin,EMout,HVout,HMin,HMout,$CBAxisName[p])		EGName = gMaterialName + "_Eg"	if (exists(EGName)==1)		Duplicate /D/O $EGName, LastEg		Duplicate /D/O $VBAxisName, LastEgAxis	endif		Duplicate /D/O $CBName, $EGName	$EGName = $CBName - $VBName - $CoulName	KillWaves /Z $CoulName			DoWindow /K EMAPlot	EMAPredictionPlot(gMaterialName)	DoWindow /C EMAPlot		DoWindow /K EgPlot	EMABandGapPlot(EGName, CBAxisName)	DoWindow /C EgPlot			String PlotName=WinList("EMAPlot",";","WIN:1")	if (strlen(PlotName)==0)		EMAPredictionPlot(CBName,CBAxisName)		DoWindow /C EMAPlot	else		DoWindow /F EMAPlot	endifEndProc EMA_CB_Predictions(MaterialName, dMax, Eg, Evb, EMin, EMout, EVout)	String /G gMaterialName	Variable /G gdMax, gEg, gEvb, gEMin, gEMout, gEVout	String MaterialName=gMaterialName	Prompt MaterialName, "Material Name"	Variable dMax=gdMax	Prompt dMax, "Maximum particle diameter (nm)"	Variable Eg=gEg	Prompt Eg, "The band gap (eV)"	Variable Evb=gEvb	Prompt Evb, "The VB energy (eV) on AVS"	Variable EMin=gEMin	Prompt EMin, "Electron effective mass inside"	Variable EMout=gEMout	Prompt EMout, "Electron effective mass outside"	Variable EVout=gEVout	Prompt EVout, "The electron confining potential (eV)"	PauseUpdate; Silent 1		gMaterialName=MaterialName	gdMax=dMax	gEg=Eg	gEvb=Evb	gEMin=EMin	gEMout=EMout	gEVout=EVout		String CBName, CBAxisName		CBName = MaterialName+"_cb"	CBAxisName = CBName+"_axis"		Make /D/O/N=(1001) $CBName, $CBAxisName	$CBAxisName = x * (dMax/1000)		$CBName[] = EMA_ConductionBand(Evb,Eg,EVout,EMin,EMout,$CBAxisName[p])EndProc EMA_VB_Predictions(MaterialName, dMax, Eg, Evb, HMin, HMout, HVout)	String /G gMaterialName	Variable /G gdMax, gEg, gEvb, gHMin, gHMout, gHVout	String MaterialName=gMaterialName	Prompt MaterialName, "Material Name"	Variable dMax=gdMax	Prompt dMax, "The maximum particle diameter (nm)"	Variable Eg=gEg	Prompt Eg, "The band gap"	Variable Evb=gEvb	Prompt Evb, "The VB energy (eV) on AVS"	Variable HMin=gHMin	Prompt HMin, "Hole effective mass inside"	Variable HMout=gHMout	Prompt HMout, "Hole effective mass outside"	Variable HVout=gHVout	Prompt HVout, "The Hole confining potential"	PauseUpdate; Silent 1		gMaterialName=MaterialName	gdMax=dMax	gEg=Eg	gEvb=Evb	gHMin=HMin	gHMout=HMout	gHVout=HVout		String VBName, VBAxisName	VBName = MaterialName+"_vb"	VBAxisName = VBName+"_axis"		Make /D/O/N=(1001) $VBName, $VBAxisName	$VBAxisName = x * (dMax/1000)		$VBName[] = EMA_ValenceBand(Evb,HVout,HMin,HMout,$VBAxisName[p])End// We take the valence band maximum to be the zero energy level. // Then Ecb = Evb + Eg// Confining potential for holes in VB = V. // Confining potential for electrons in CB = V - Eg// Assume that holes cannot exist outside the particle, so Vout = inf. // For particles in a vacuum the electron effective mass = 1 outside. // Input: //		Bulk valence band maximum energy position, Evb, in eV//		Nanoparticle DIAMETER, d, in nm// 		ELECTRON internal effective mass, m_in, is dimensionless//		ELECTRON external effective massm_out. //		Confining potential, Vout, in eV// HOLES in the Valence BandFunction EMA_ValenceBand(Evb,Vout,m_in,m_out,d)	Variable Evb,Vout,m_in,m_out,d		Variable hbar = 1.054571e-34		// Js	Variable e = 1.602176e-19		// C	Variable me = 9.109381e-31		// kg	Variable Ang = 1e-10	Variable nm = 1e-9		// The infinite potential value	Variable Shift_Evb = (2 * hbar^2 * pi^2)/(d^2 * nm^2 * m_in * me)		// The finite potential correction	Variable delta = ((2 * hbar)/(d * nm * m_in * me)) * sqrt((2 * m_out)/(Vout * e))		Variable Evb_d = Evb - (1/e) * Shift_Evb*(1-delta)		return Evb_dEnd// Input: //		Bulk valence band maximum energy position, Evb, in eV//		Bulk band gap, Eg//		Nanoparticle DIAMETER, d, in nm// 		HOLE internal effective mass, m_in, is dimensionless//		HOLE external effective mass, m_out. //		Confining potential, Vout, in eV// ELECTRONS in the Conduction BandFunction EMA_ConductionBand(Evb,Eg,Vout,m_in,m_out,d)	Variable Evb,Eg,Vout,m_in,m_out,d		Variable hbar = 1.054571e-34		// Js	Variable e = 1.602176e-19		// C	Variable me = 9.109381e-31		// kg	Variable Ang = 1e-10				// m	Variable nm = 1e-9					// m		Variable Ecb = Evb + Eg		// What happens if the V is less than the band gap?	Variable Potential = Vout-Eg		Variable delta = ((2 * hbar)/(d*nm * m_in * me)) * sqrt((2 * (m_out*me))/(Potential*e))		// The infinite potential value	Variable Shift_Ecb = (2 * hbar^2 * pi^2)/((d*nm)^2 * (m_in*me))		Variable Ecb_d = Ecb+ (1/e) * Shift_Ecb*(1-delta)		return Ecb_dEndFunction EMA_CoulombTerm(epsilon,Evb,Eg,EVout,me_in,me_out,HVout,mh_in,mh_out,d)	Variable epsilon, Evb,Eg,EVout,me_in,me_out,HVout, mh_in,mh_out,d		Variable hbar	= 1.054571e-34		// Js	Variable e 		= 1.602176e-19		// C	Variable eps0 	= 8.854187e-12		// C	Variable me 	= 9.109381e-31		// kg	Variable Ang 	= 1e-10				// m	Variable nm 	= 1e-9				// m		Variable Ecb = Evb + Eg		// Electron Contribution	Variable Potential = EVout-Eg	Variable delta_e = ((2 * hbar)/(d*nm * me_in * me)) * sqrt((2 * (me_out*me))/(Potential*e))		// Hole Contribution	Variable delta_h = ((2 * hbar)/(d*nm * mh_in * me)) * sqrt((2 * mh_out)/(HVout))	//	Variable PreFactor = ((3.6 * e^2)/(epsilon*d))	Variable PreFactor = ((3.6 * e^2)/(epsilon*eps0*d*nm))		Print " PreFactor is",PreFactor/(1.6e-19)		Variable Coulomb = PreFactor * (1 - (delta_e + delta_h)/4)		return CoulombEndWindow EMAPredictionPlot(MaterialName) : Graph	String MaterialName	PauseUpdate; Silent 1		// building window...	String CBName, CBAxisName, VBName, VBAxisName, NHENAme, NHEAxisName	CBName = MaterialName+"_cb"	CBAxisName = CBName+"_axis"		VBName = MaterialName+"_vb"	VBAxisName = CBName+"_axis"		if (exists(CBName)==1)		Display /W=(272,167,612,557) $CBName vs $CBAxisName		ModifyGraph rgb($CBName)=(65535,32764,16385)		ModifyGraph lSize($CBName)=2				NHENAme = CBName + "_NHE"		NHEAxisName = CBAxisName		Duplicate /D/O $CBName, $NHENAme		$NHENAme = -1 * $CBName - 4.5				if (exists(VBName)==1)			AppendToGraph $VBName vs $VBAxisName			ModifyGraph lSize($VBName)=2		endif	else		Display /W=(272,167,612,557) $VBName vs $VBAxisName		ModifyGraph lSize($VBName)=2				NHENAme = VBName + "_NHE"		NHEAxisName = VBAxisName		Duplicate /D/O $VBName, $NHENAme		$NHENAme = -1 * $VBName - 4.5	endif		AppendToGraph/R $NHENAme vs $NHEAxisName	ModifyGraph lSize($NHENAme)=0	ModifyGraph mirror(bottom)=2	ModifyGraph axThick=2		ModifyGraph fSize=14	Label left "\\Z16Energy relative to AVS (eV)"	Label bottom "\\Z16Nanoparticle diameter (nm)"	Label right "\\Z16Energy relative to NHE (V)"	SetAxis left -9,-2	SetAxis bottom, 1, $NHEAxisName(Inf)	SetAxis/R right 4.5,-2.5		if ((exists("LastCB")==1) && (exists("LastCBAxis")==1))		AppendToGraph LastCB vs LastCBAxis		ModifyGraph rgb(LastCB)=(1,4,52428)	endif	if ((exists("LastVB")==1) && (exists("LastVBAxis")==1))		AppendToGraph LastVB vs LastVBAxis		ModifyGraph rgb(LastVB)=(1,4,52428)	endifEndWindow EMABandGapPlot(EGName, EGAxisName) : Graph	String EGName, EGAxisName		Display /W=(613,167,953,557) $EGName vs $EGAxisName		SetAxis bottom, 0.5, $EGAxisName(Inf)	SetAxis left, 0, $EGName(BinarySearchInterp($EGAxisName, 0.5 ))		ModifyGraph fSize=14	Label left "\\Z16Band Gap (eV)"	Label bottom "\\Z16Nanoparticle diameter (nm)"	ModifyGraph mirror=2	ModifyGraph axThick=2	ModifyGraph lSize=2		if ((exists("LastEg")==1) && (exists("LastEgAxis")==1))		AppendToGraph LastEg vs LastEgAxis		ModifyGraph rgb(LastEg)=(1,4,52428)	endifEnd