#pragma rtGlobals=1		// Use modern global access method.// Default is the first 3 characters which works for many e.g. Anatase, Dolomite ... Function /S IMAMineralAbbreviation(MineralName)	String MineralName		String AbbName		strswitch (MineralName)		case "Calcite":			AbbName = "Cc"			break		case "Chamosite":			AbbName = "Chm"			break		case "Goethite":			AbbName = "Gt"			break		case "Hematite":			AbbName = "Hmt"			break		case "Montmorillonite":			AbbName = "Mmt"			break		case "Muscovite":			AbbName = "Mus"			break		case "Pyrite":			AbbName = "Py"			break		case "Quartz":			AbbName = "Qtz"			break		case "Titanomaghemite":			AbbName = "Tmh"			break		case "Hydromag":			AbbName = "Hmg"			break					default :			AbbName = MineralName[0,2]				endswitch 		return AbbNameEnd//Global parameters and GOALs//****************************//QQuartz=0.4750+-0.0037Function /S ParseProfexLSTFile(PathAndFileName)	String PathAndFileName		Variable refNum, MinFlag=0	String FileLine, MineralName, MineralList = ""	Open/R refNum as PathAndFileName	if (refNum == 0)		return ""	endif	do		FReadLine refNum, FileLine		if (strlen(FileLine) == 0)			Close refNum			return MineralList					elseif (StrSearch(FileLine,"Global parameters and GOALs",0) > -1)			FReadLine refNum, FileLine 		// Read in the next line of ****			FReadLine refNum, FileLine		// Read in the next line that should be a QMineral name			MinFlag 	= 1		endif				if (MinFlag == 1)				if (cmpstr(FileLine[0,0],"Q") == 0)					MineralName 	= ReturnTextBeforeNthChar(FileLine,"=",1)					MineralName 	= MineralName[1,inf]					MineralName 	= IMAMineralAbbreviation(MineralName)					MineralList = MineralList + MineralName + ";"				else					Close refNum					return MineralList				endif		endif 			while(1)End// Single data, fit, residuals, background and mineral components// Loads a .xy file exported from Profex// Prompts user for a second ".lst" file to look up mineral phase namesFunction /T LoadProfexDataFit(FileName,SampleName,AssocDataList)	String FileName, SampleName, &AssocDataList	SVAR gPath2Data 			= root:SPECTRA:GLOBALS:gPath2Data		// Load the selected Profex ".xy" file	LoadWave /A/O/Q/D/J/E=0/K=0/V={"\t, "," $",0,0} /P=LoadDataPath FileName	if (V_flag == 0)		return ""	endif		String PathAndFileName, ListOfLSTFiles, LSTFileName, MineralAbbn, MineralList, CmptName	Variable i, ColFlag=0, NLST, NMinerals, NWaves = ItemsInList(S_waveNames)		// Look for a ".lst" file in the same folder	ListOfLSTFiles = IndexedFile(LoadDataPath,-1,".lst")	NLST 				= ItemsInList(ListOfLSTFiles)	if (NLST==0)		ColFlag=-1		// Proceed with column numbers	else		LSTFileName 		= StringFromList(0,ListOfLSTFiles)		if (NLST>1)			Prompt LSTFileName, "Select '.lst' file", popup, ListOfLSTFiles			DoPrompt "Profex load",LSTFileName			if (V_flag)				ColFlag=-1		// Proceed with column numbers			endif		endif	endif		PathAndFileName 	= gPath2Data + LSTFileName		MineralList 	= ParseProfexLSTFile(PathAndFileName)	NMinerals 	= ItemsInList(MineralList)	if (NMinerals == 0)		print 	" 	... could not parse Profex '.lst' file"		ColFlag=-1		// Proceed with column numbers	elseif (NMinerals != (NWaves-5) )		print 	" 	... wrong number of mineral phase names in Profex '.lst' file"		ColFlag=-1		// Proceed with column numbers	else		print 	" 	... found",NMinerals,"mineral phase names in Profex '.lst' file"	endif			WAVE ProfexWave 	= $StringFromList(0,S_waveNames)	Duplicate /O ProfexWave, $(SampleName + "_axis") /WAVE=Axis		WAVE ProfexWave 	= $StringFromList(1,S_waveNames)	Duplicate /O ProfexWave, $(SampleName + "_data") /WAVE=Data		WAVE ProfexWave 	= $StringFromList(2,S_waveNames)	Duplicate /O ProfexWave, $(SampleName + "_fit") /WAVE=Fit		WAVE ProfexWave 	= $StringFromList(3,S_waveNames)	Duplicate /O ProfexWave, $(SampleName + "_res") /WAVE=resid		WAVE ProfexWave 	= $StringFromList(4,S_waveNames)	Duplicate /O ProfexWave, $(SampleName + "_bg") /WAVE=background		AssocDataList 		= SampleName + "_bg;"			for (i=5;i<NWaves;i+=1)		MineralAbbn 			= StringFromList(i-5,MineralList)		CmptName 				= SampleName + "_" + MineralAbbn		WAVE ProfexWave 	= $StringFromList(i,S_waveNames)		AssocDataList 		= AssocDataList+CmptName+";"		Duplicate /O ProfexWave, $(CmptName)	endfor		Note /K Data, SampleName	Note Data, gPath2Data	Note Data, "Data type=Profex"		String WaveNameList = SampleName + "_data;" + SampleName + "_fit;" + SampleName + "_res;"	return WaveNameListEnd// Assumes //Function PlotProfexDataFit()//	//	WAVE /T DataList 	= root:SPECTRA:wDataList//	WAVE DataSel 	 	= root:SPECTRA:wDataSel//	WAVE DataGroup 	= root:SPECTRA:wDataGroup//	//	NVAR PlotAssd 				= root:SPECTRA:Plotting:gPlotAssociatedFlag	//	Variable UserLegend 			= NumVAROrDefault("root:SPECTRA:Plotting:gFileNameLegendFlag",0)//	Variable PlotTime 			= NumVAROrDefault("root:SPECTRA:Plotting:gPlotvsTimeFlag",0)//	//	Variable i=0, DataNum, Num2Plot, AppendFlag = 0, timeFlag=0//	String DataNote, DataFileName, DataType, Folder2DName, Data2DName, Data2DFull, LegendText=""//	String AxisName, AxisAndFolderName, DataName, DataAndFolderName, PlotName, FolderStem = "root:SPECTRA:Data:Load"//	//	WaveStats /Q/M=0 DataSel//	Num2Plot = (PlotAllFlag == 1) ? V_npnts : V_sum//	//	do//		// Bit 0 or 3 is set: Normal selection. //		if (((DataSel[i] & 2^0) != 0) || ((DataSel[i] & 2^3) != 0) || (PlotAllFlag == 1))//			//			DataNum 				= i//			DataName				= DataList[DataNum]//			DataAndFolderName	= FolderStem + num2str(DataGroup[DataNum]) + ":" + DataName//			DataNote 				= Note($DataAndFolderName)//			DataFileName 			= ReturnTextBeforeNthChar(DataNote,"\r",1)//			DataType 				= StringByKey("Data type",DataNote,"=","\r")//			//			if (PlotTime == 0)//				AxisName 				= AxisNameFromDataName(DataName)//				AxisAndFolderName	= AxisNameFromDataName(DataAndFolderName)//			else//				AxisName 				= AnyNameFromDataName(DataName,"time")//				AxisAndFolderName	= AnyNameFromDataName(DataAndFolderName,"time")//				if (!WaveExists($AxisAndFolderName))//					Print " 	*** No data-point acquisition times were loaded for",DataName//					return 0//				endif//			endif//			//			Folder2DName 		= FolderStem + num2str(DataGroup[DataNum]) + ":TwoD"//			Data2DName 			= AnyNameFromDataName(DataName,"2D")//			Data2DFull 			= ParseFilePath(2,Folder2DName,":",0,0) + Data2DName//			//			if (WaveExists($Data2DFull))//				Plot2DData(Data2DFull,DataNote)//			else//				Display /K=1/W=(525,44,1234,707)  $DataAndFolderName vs $AxisAndFolderName as "Plotted Data"//				ControlBar 180//				PlotName = WinName(0,65)//				//				MakePlotDataFolders(PlotName,1)//				//				PlotDataInWindow(PlotName, DataList, DataSel, DataGroup, "red", PlotAllFlag, AppendFlag, 0, 1, PlotTime, PlotAssd,"",UserLegend)////				if (cmpstr(DataType,"Complex") == 0)////					PlotDataInWindow(PlotName, DataList, DataSel, DataGroup, "red", PlotAllFlag, AppendFlag, 1, 1, PlotTime, PlotAssd,"")////				endif////				//				if (WideFlag)//					CheckWindowPosition(PlotName,0,44,2000,707)//				else//					CheckWindowPosition(PlotName,525,44,1234,707)//				endif//				//				timeFlag = (PlotTime && WideFlag) ? 1 : 0//				SetCommonPlotFormat(PlotName,timeFlag)//				//				TransferPlotPreferences(PlotName,1)//				//				AddPlotFormatControls(PlotName)//				//				UpdateTraceStyle(PlotName,"_all_")//				//				PlotControlButtons("ReplaceCursorsButton")//	//				if (PlotTime && WideFlag)//					// some formatting and display tweaks for wide display of time-axis data//					ModifyGraph /W=$PlotName dateInfo(bottom)={0,1,0}, grid(bottom)=1,nticks(bottom)=12//				endif//				//				return 0//			endif//		endif//		//		i+=1//	while(i<numpnts(DataSel))//EndFunction LoadRigakuASC(FileName,SampleName,NLoaded)	String FileName, SampleName	Variable &NLoaded		SVAR gPath2Data 			= root:SPECTRA:GLOBALS:gPath2Data	String PathAndFileName 	= gPath2Data + FileName 		String XRDLine, DataNote	Variable i, j, NXRD=0, NPts, Start, Stop, Step, AdoptFlag, Success, FileRefNum		Open /R FileRefNum as PathAndFileName			do		FReadLine FileRefNum, XRDLine		XRDLine = ReplaceString("	",ReplaceString(" ",XRDLine,""),"")				if (strlen(XRDLine) == 0)			break	// No more lines in file.		elseif (StrSearch(XRDLine,"*START",0) > -1)			Start 	= str2num(StringByKey("*START",XRDLine+",","="))		elseif (StrSearch(XRDLine,"*STOP",0) > -1)			Stop 	= str2num(StringByKey("*STOP",XRDLine+",","="))		elseif (StrSearch(XRDLine,"*STEP",0) > -1)			Step 	= str2num(StringByKey("*STEP",XRDLine+",","="))		elseif (StrSearch(XRDLine,"*COUNT",0) > -1) 			if (StrSearch(XRDLine,"*COUNTER",0) > -1)			else				// The line before the start of a data segment, which gives the expected number of data points				NPts 	= str2num(StringByKey("*COUNT",XRDLine+",","="))				Print " 	... found a new XRD file with",NPts,"points starting at line",j				Make /N=(NPts)/D/FREE XRDAxis, XRDData				XRDAxis[] 	= Start + p*Step				AdoptFlag = 0				NXRD += 1				i = 0			endif		elseif( StrLen(XRDLine)>4 && StrSearch(XRDLine,"*",0) == -1)			XRDData[i] 		= str2num(StringFromList(0,XRDLine,","))			XRDData[i+1] 	= str2num(StringFromList(1,XRDLine,","))			XRDData[i+2] 	= str2num(StringFromList(2,XRDLine,","))			XRDData[i+3] 	= str2num(StringFromList(3,XRDLine,","))			i +=4			if (i == NPts)				AdoptFlag = 1			endif		elseif (StrSearch(XRDLine,"*END",0) > -1)			// End of a data segment. 			AdoptFlag = 2		endif				if (AdoptFlag>0)			DataNote 	= FileInfoWaveNote(gPath2Data,FileName)			DataNote 	= DataNote + "Rigaku XRD file\r\r"			Note /K XRDData, DataNote						String DataName 	= SampleName + "_"+num2str(NXRD)			Success 		= SingleAxisDataErrorsFitLoad(DataName,DataNote,XRDAxis,XRDData,$"",$"",$"",$"")			if (!Success)				break			endif			AdoptFlag = 0			NLoaded +=1			I = 0		endif				j +=1 	while(1)		Close FileRefNumEnd// *************************************************************// ****		TAB 5:	X-ray Diffraction Operations// *************************************************************Function AppendPlotXRDControls(WindowName)	String WindowName		String cmd, PlotFolderName = "root:SPECTRA:Plotting:"+WindowName		Button XRAY_SaveGSASButton,pos={593,97},size={100,18},proc=XRDControlButtons,title="Save GSAS", disable=1	Button XRAY_SavePanButton,pos={593,121},size={100,18},proc=XRDControlButtons,title="Save Pan", disable=1EndFunction XRDControlButtons(ctrlname):ButtonControl	String ctrlname		String PlotName = WinName(0,65)	String PrefsFolderName 	= "root:SPECTRA:Plotting:Preferences"	String PlotFolderName 	= "root:SPECTRA:Plotting:" + PlotName	String CopyFolderName 	= "root:SPECTRA:Plotting:"+PlotName+":DataDuplicates"	SVAR gSelection1 	= $(PlotFolderName+":gSelection1")			String ExportStyle	Variable NumTraces, TraceIndex,  i		if (StrSearch(ctrlname,"SaveXRD",0) > -1)		if  (cmpstr(ctrlname,"XRD_SaveGSASButton")==0)			ExportStyle = "GSAS"		elseif (cmpstr(ctrlname,"XRD_SavePanButton")==0)			ExportStyle = "PANA"		endif					if (cmpstr("_all_",gSelection1) == 0)			NumTraces = ItemsInList(TraceNameList(PlotName,";",1))			for (i=0;i<NumTraces;i+=1)				WAVE Axis 	= WaveRefIndexed(PlotName, i, 2)				WAVE Data 	= WaveRefIndexed(PlotName, i, 1)				SaveGSASFXY(Axis,Data)				//				CopyIndexTraceToDataFolder(PlotName,CopyFolderName,i, 1)			endfor				else			SaveGSASFXY(XWaveRefFromTrace(PlotName,gSelection1),TraceNameToWaveRef(PlotName,gSelection1))			//			TraceIndex = WhichListItem(gSelection1,TraceNameList(PlotName, ";", 1))			CopyIndexTraceToDataFolder(PlotName,CopyFolderName,TraceIndex, 1)		endif	endifEnd// ***************************************************************************// **************** 			Useful XRD formulae// ***************************************************************************// Input: FWHM and PeakTheta in DEGREESFunction ScherrerFormula(lambda,FWHM,PeakTheta)	Variable lambda,FWHM,PeakTheta		Variable DegToRad = (2*pi)/360	Variable FWHMRad = FWHM * DegToRad	Variable PeakThetaRad = PeakTheta * DegToRad / 2		Variable ScherrerConst = 0.9	//	return (ScherrerConst * lambda)/(FWHM * cos(PeakThetaRad))	return (ScherrerConst * lambda)/(FWHMRad * cos(PeakThetaRad))EndFunction /T MakeXRDWavelengthList()		String OldDF = getDataFolder(1)	NewDataFolder/O/S root:SPECTRA	NewDataFolder/O/S root:SPECTRA:Fitting	NewDataFolder/O/S root:SPECTRA:Fitting:XRD		MakeVariableIfNeeded("gXRDLambda",0.729294)		MakeVariableIfNeeded("gXRDLambdaChoice",1)		MakeVariableIfNeeded("gXRDLambda2",0.729294)		MakeVariableIfNeeded("gXRDLambda2Choice",1)	SetDataFolder $(OldDF)		return "enter manually;Cu Ka1: 1.54055  ;Co Ka1: 1.78895 ;Mo Ka1: 0.70929 ;17 keV: 0.729294 ; 8.33 keV: 1.48782 ;DND: 0.826561 "EndFunction /T MakeSpaceGroupList()	String SpaceGroupList = "cubic: F -4 3 m;"		// Sphalerite ZnS		SpaceGroupList += "tetragonal: I -4 m 2;"		// The tetragonal sub-group from sphalerite ZnS		SpaceGroupList += "hexagonal: P 63 m c;"		// Wurtzite ZnS		SpaceGroupList += "orthorhombic: C m c 21;"	// The orthorhombic sub-group from wurtzite ZnS		SpaceGroupList += "tetragonal: I 41/a m d;"	// Anatase TiO2		return SpaceGroupListEndFunction /T MakeReflectionsList(SpaceGroup)	String SpaceGroup		String ReflectionsList		// Should do this properly!	strswitch(SpaceGroup)		case "cubic: F -4 3 m":			// Sphalerite ZnS			ReflectionsList = "111;200;220;311;222;400;331;420;422;511;333;440;511;333;440;531;442;600;620;533;444;"			break		case "tetragonal: I -4 m 2":			// The tetragonal sub-group from sphalerite ZnS			ReflectionsList = "101;110;002;200;112;211;103;202;220;301;310;213;222;004;114;312;204;321;303;105;400;"			break		case "hexagonal: P 63 m c":			// Wurtzite ZnS			ReflectionsList = "100;002;101;102;110;103;200;112;201;004;202;104;203;210;211;114;105;212;204;300;301;213"			break		case "orthorhombic: C m c 21":			// The orthorhombic sub-group from wurtzite ZnS			ReflectionsList = "110;020;002;111;021;112;022;200;130;131;113;023;220;040;202;132;221;041;004;222;042;133;114;024;"			break		case "tetragonal: I 41/a m d":			// Anatase TiO2			ReflectionsList = "101;103;004;112;200;202;105;211;213;204;116;220;107;215;301;206;008;303;224;"			break	endswitch		return ReflectionsListEnd// ***************************************************************************// **************** 			Main procedures for Simulating XRD Patterns// ***************************************************************************Proc TrialUnitCell(ctrlName) : ButtonControl	String ctrlName	PauseUpdate; Silent 1	LaunchRealUnitCellFit(1)EndProc FitUnitCell(ctrlName) : ButtonControl	String ctrlName	PauseUpdate; Silent 1		LaunchRealUnitCellFit(2)EndProc LaunchRealUnitCellFit(FitFlag)	Variable FitFlag	PauseUpdate; Silent 1	Variable UserPromptFlag = 1	if (exists("HPFitCoefs")==1)		UserPromptFlag=0	endif	// Backwards compatibility!	if (exists("gUnitFitTypeStr")==0)		String /G gUnitFitTypeStr = StringFromList(gUnitFitType-1, gUnitFitModels)	endif	CreateHPCoefs(gSamplePeakType, gUnitFitTypeStr, gAmBGFlag,gNExtraGauss)		// Put the fit coefficients in a table for viewing	DisplayCoefficientsTable("HP_Fitting_Coefficients","High Pressure XRD Fit Coefficients","HPFitCoefsLegend;HoldHPFitCoefs;HPFitCoefs;","130;24;80", "2;1;2;", 691,44,1025,320,"no")		if (UserPromptFlag==1)		DoAlert 0, "Please enter some reasonable coefficient values!"		return 	endif		String DataName = StripCharsFromString(StringFromList(gFitTraceNum, TraceNameList(gCallPlot, ";", 1),";"),"'")		RealFitUnitCell(DataName,gUnitFitTypeStr,FitFlag)End//Proc RealFitUnitCell(XRDData,SeriesFlag,FitFlag)Proc RealFitUnitCell(XRDData,UnitFitTypeStr,FitFlag)	Variable /G gFitFlag//gNPDFPeaks	String XRDData//	Variable SeriesFlag	String UnitFitTypeStr	Variable FitFlag=gFitFlag	Prompt FitFlag, "Trial or Fit?", popup, "trial;fit single;"//fit all forwards;fit all reverse"	PauseUpdate; Silent 1		gFitFlag=FitFlag	Variable /G gCoefsForEachTraceFlag	Variable NumTraces, i, V_fitOptions, GoodFitFlag, Index	String LabelStr, FitName, ResidsName, BGName, CoefName, HPHoldString="", SpaceGroup	NumTraces = numpnts(ListOfDataNames)		if (exists("Coefs3")==0)		Make /D/N=3 Coefs3	endif	if (exists("Coefs4")==0)		Make /D/N=4 Coefs4	endif		if (gCalibrantFlag==1)		CreateHPFitResultWaves()	endif		i=0	do		LabelStr = HPFitCoefsLegend[i]		if (cmpstr(LabelStr[0,0],"[")==0)			HoldHPFitCoefs[i] = 1			HPHoldString+="1"		else			HPHoldString+=num2str(HoldHPFitCoefs[i])		endif		i+=1	while(i<numpnts(HoldHPFitCoefs))		RemoveAllFittingTraces(XRDData)	FitName = ReplaceTextInString(XRDData,"_data","") + "_fit"	ResidsName = ReplaceTextInString(XRDData,"_data","") + "_res"	BGName = ReplaceTextInString(XRDData,"_data","") + "_bg"	Duplicate /O $XRDData, $FitName, $ResidsName, $BGName	$FitName = NAN	$ResidsName = NAN	$BGName = NAN		SpaceGroup = ReturnTextBeforeNthChar(UnitFitTypeStr,":",1)	ApplyUnitCellConstraints(SpaceGroup,HPFitCoefs,HoldHPFitCoefs)	if (FitFlag==1)		// Trial only		DiffractionPattern(HPFitCoefs,$FitName, XWaveRefFromTrace("", XRDData))		AppendToGraph $FitName vs XWaveRefFromTrace("", XRDData)	else		Duplicate /O/D HPFitCoefs, HPFitcoefs_save	endif		if (FitFlag==2)		// Fit the currently displayed pattern		Print " *** Fitting to XRD pattern",XRDData		Variable V_FitQuitReason, V_FitError		V_fitOptions=4		Variable V_chisq=0			// The fitting part		if ((exists("Mask")==1) && (gUseMaskFlag==1))			FuncFit /Q/H=HPHoldString DiffractionPattern HPFitCoefs $XRDData[pcsr(A),pcsr(B)] /X=XWaveRefFromTrace("", XRDData) /D=$FitName /M=Mask /R=$ResidsName		else			FuncFit /Q/H=HPHoldString DiffractionPattern HPFitCoefs $XRDData[pcsr(A),pcsr(B)] /X=XWaveRefFromTrace("", XRDData) /D=$FitName /R=$ResidsName		endif		ApplyUnitCellConstraints(UnitFitTypeStr,HPFitCoefs,HoldHPFitCoefs)		GoodFitFlag = FittingReport(V_FitError,V_FitQuitReason,V_chisq,0)		HPFitCoefs[5,]=abs(HPFitCoefs[p])				if (exists("gPrevCoef")==2)			gPrevCoef = gPresCoef			gPresCoef = HPFitCoefs[gMonitorCoef]		endif				AppendToGraph $FitName vs XWaveRefFromTrace("", XRDData)		AppendToGraph $ResidsName vs XWaveRefFromTrace("", XRDData)		WaveStats /Q/R=(pcsr(A),pcsr(B)) $XRDData		ModifyGraph offset($ResidsName)={0,V_min}				if (gRecordCellVolFlag == 1)			RecordUnitCellVolume()		endif		if (gCoefsForEachTraceFlag == 1)			CoefName = "fc_" + ReplaceTextInString(ReplaceTextInString(XRDData,"_data",""),"_norm","")			Duplicate /O/D HPFitCoefs, $CoefName		endif				if ((gAutoSaveHPCoefFlag==1) && (GoodFitFlag==1))			SaveHPFitCoefs("la")		endif	endif		// Display the background	Coefs4[]=HPFitCoefs[p]	$BGName[] = poly(Coefs4,XWaveRefFromTrace("", XRDData)[p])		if (gAmBGFlag == 1)		Index = FindStringInTextWave("Amorphous BG Intensity",HPFitCoefsLegend)		$BGName[] += AmorphousBG(HPFitCoefs[Index],HPFitCoefs[Index+1],HPFitCoefs[Index+2], XWaveRefFromTrace("", XRDData)[p])	endif	if (gNExtraGauss > 0)		Index = FindStringInTextWave("Gaussian Intensity",HPFitCoefsLegend)		i=0		do			Coefs3[0] = HPFitCoefs[Index+(3*i)+0]			Coefs3[1] = HPFitCoefs[Index+(3*i)+1]			Coefs3[2] = HPFitCoefs[Index+(3*i)+2]			$BGName[] += GaussianPeak(Coefs3,XWaveRefFromTrace("", XRDData)[p])			i+=1		while(i<gNExtraGauss)	endif	$BGName[0,min(pcsr(A),pcsr(B))-1]=NAN	$BGName[max(pcsr(A),pcsr(B))+1,]=NAN	AppendToGraph $BGName vs XWaveRefFromTrace("", XRDData)	ModifyGraph rgb($BGName)=(3,52428,1)End// ********************************************************// ******     			High Pressure XRD Refinement Functions// ********************************************************Function DiffractionPattern(w, ywv, xwv) : FitFunc	Wave w, ywv, xwv		WAVE Coefs3=Coefs3	WAVE Coefs4=Coefs4	NVAR gMaxNoPeaks=gMaxNoPeaks	NVAR gAmBGFlag=gAmBGFlag	SVAR gUnitFitModels=gUnitFitModels	NVAR gUnitFitType=gUnitFitType	SVAR gUnitFitTypeStr=gUnitFitTypeStr	NVAR gNExtraGauss = gNExtraGauss	SVAR gSamplePeakType=gSamplePeakType	NVAR lambda = gHPLambda		Variable i, ii, d_n, TTO, h, k, l, Mix, Shape	String ReflectionsList, Reflection		// Handle possible 2-theta offset	TTO = w[4]		// Ensure no negative peak coefficients	w[5,]=abs(w[p])		// Polynomial background	Coefs4[]=w[p]	ywv[] = poly(Coefs4,xwv[p])	ii = 10		// Backwards compatibility!	if (exists("gUnitFitTypeStr")==0)		String /G gUnitFitTypeStr = StringFromList(gUnitFitType-1, gUnitFitModels)	endif	// Generate the list of reflections to include	ReflectionsList = MakeReflectionsList(gUnitFitTypeStr)	//	print ReflectionsList		// The broadening parameter as a function of 2-theta 	Duplicate /O/D xwv, sig, tant, delTT	tant = tan((2*pi*xwv)/360)	sig[] = sqrt(w[ii+1]*(tant[p])^2 + w[ii+2]*tant[p] + w[ii+3])		// The Voigt parameters as a function of 2-theta	Duplicate /O/D xwv, VWidth, VAmpl	Shape = ShapeFromMix(w[ii+5])	VWidth[] = CalculateVWidthParam(sig[p],Shape)	VAmpl[] = CalculateVAmplitude(Vwidth[p],1)		i=0	do		Reflection = StringFromList(i,ReflectionsList)		h = str2num(Reflection[0,0])		k = str2num(Reflection[1,1])		l = str2num(Reflection[2,2])			d_n = dFromhkl(h,k,l,w[5],w[6],w[7],w[8],w[9],w[10])		//		Print " The ",h,k,l," d-spacing is",d_n				delTT[] = (720 * asin(lambda/(2*d_n)))/(2*pi) - (xwv[p] + TTO)				// Voigt		ywv[] += (w[ii+6+i]/sqrt(2)) * (1-(w[ii+4]*(delTT[p])^2)/tant[p]) * VAmpl * BenVoigtAlgorithm(delTT[p]*VWidth[p],Mix)			// Pure Gaussian//		ywv[] += (w[ii+5+i]/(sqrt(2*pi*sig2[p]))) * (1-(w[ii+4]*delTT2[p])/tant[p]) * exp(-delTT2[p]/(2*sig2[p]))				i+=1	while(i<gMaxNoPeaks)	ii+=i+6		// An amorphous background	if (gAmBGFlag==1)		ywv[] += AmorphousBG(w[ii],w[ii+1],w[ii+2],xwv[p]+TTO)		ii+=3	endif		// Additional Gaussian peaks	if (gNExtraGauss>0)		i=0		do			Coefs3[0] = w[ii+(3*i)+0]			Coefs3[1] = w[ii+(3*i)+1]			Coefs3[2] = w[ii+(3*i)+2]			ywv[] += GaussianPeakBG(Coefs3,xwv[p])			i+=1		while(i<gNExtraGauss)	endif		KillWaves /Z sig, tant, delTT, VWidth, VAmplEnd// To avoid negative background values, add the value of sinc at the first minium. // sinc(x) has the first minimum for x: tan(x)=x// I solved this numerically, giving x ~ 4.4934095 Function AmorphousBG(int,RR,DW, TT)	Variable int,RR,DW, TT		NVAR lambda = gHPLambda	Variable q = TwoThetaToQ(lambda,TT)		return int * sinc(q*RR) * exp(-abs(DW)*TT)//	return int * (sinc(q*RR) * exp(-abs(DW)*TT) - sinc(4.4934095))EndFunction /T LegendForSpaceGroup(SpaceGroup)	String SpaceGroup		strswitch (SpaceGroup)		case "cubic":			return "Sample a;[b];[c];[alpha];[beta];[gamma];"			break		case "tetragonal":			return "Sample a;[b];c;[alpha];[beta];[gamma];"			break		case "hexagonal":			return "Sample a;[b];c;[alpha];[beta];[gamma];"			break		case "orthorhombic":			return "Sample a;b;c;[alpha];[beta];[gamma];"			break		case "rhombohedral":			return "Sample [a];[b];[c];alpha;beta;gamma;"			break		case "monoclinic":			return "Sample a;b;c;alpha;[beta];gamma;"			break		case "triclinic":			return "Sample a;b;c;alpha;beta;gamma;"			break	endswitchEndFunction ApplyUnitCellConstraints(SpaceGroup,w,h)	String SpaceGroup	Wave w,h		// single unit cell parameter for a cubic structure	strswitch (SpaceGroup)		case "cubic":			w[6] = w[5]; h[6] = 1			w[7] = w[5]; h[7] = 1						w[8] = 90; h[8] = 1			w[9] = 90; h[9] = 1			w[10] = 90; h[10] = 1			break		case "tetragonal":			w[6] = w[5]; h[6] = 1						w[8] = 90; h[8] = 1			w[9] = 90; h[9] = 1			w[10] = 90; h[10] = 1			break		case "hexagonal":			w[6] = w[5]; h[6] = 1						w[8] = 90; h[8] = 1			w[9] = 90; h[9] = 1			w[10] = 120; h[10] = 1		case "orthorhombic":			w[8] = 90; h[8] = 1			w[9] = 90; h[9] = 1			w[10] = 90; h[10] = 1			break		case "rhombohedral":			w[6] = w[5]			w[7] = w[5]			break		case "monoclinic":			break		case "triclinic":			break	endswitchEnd// ********************************************************// ******     			XRD DATA Fitting Coefficients// ********************************************************Function CreateHPCoefs(SamplePeakType,UnitFitTypeStr,AmBGFlag,NExtraGauss)	String SamplePeakType, UnitFitTypeStr	Variable AmBGFlag, NExtraGauss		SVAR gUnitFitModels=gUnitFitModels//	SVAR gUnitCellTypeStr=gUnitCellTypeStr	NVAR gUnitFitType=gUnitFitType	NVAR gMaxNoPeaks=gMaxNoPeaks	Variable i, j, Index	String PeakLegendList, AmBGList, ExtraPeakList, ReflectionsList, LegendList, SpaceGroup		if (waveexists(HPFitCoefs) == 0)		// The polynomial background and 2-theta offset. 		Make /D/O/N=(5) HPFitCoefs		Make /O/N=(5) HoldHPFitCoefs		Make /O/T/N=(5) HPFitCoefsLegend	endif		Make /O/D/N=6 Params_Cell, Hold_Cell	Params_Cell[] = HPFitCoefs[p+5]	Hold_Cell[] = HoldHPFitCoefs[p+5]		Make /O/D/N=5 Params_Profile, Hold_Profile	Params_Profile[] = HPFitCoefs[p+11]	Hold_Profile[] = HoldHPFitCoefs[p+11]		Make /O/D/N=(gMaxNoPeaks) Params_Peak, Hold_Peak	Params_Peak[] = HPFitCoefs[p+16]	Hold_Peak[] = HoldHPFitCoefs[p+16]		Index = FindStringInTextWave("Amorphous BG Intensity",HPFitCoefsLegend)	Make /O/D/N=3 Params_AmBG, Hold_AmBG	if (Index > -1)		Params_AmBG[] = HPFitCoefs[p+Index]		Hold_AmBG[] = HoldHPFitCoefs[p+Index]	else		// Default parameters		Params_AmBG[1] = 2.1	endif		Index = FindStringInTextWave("Gaussian Intensity",HPFitCoefsLegend)	if (Index > -1)		Make /O/D/N=(numpnts(HPFitCoefs)-Index) Params_Gauss, Hold_Gauss		Params_Gauss[] = HPFitCoefs[p+Index]		Hold_Gauss[] = HoldHPFitCoefs[p+Index]	else		Make /O/D/N=3 Params_Gauss, Hold_Gauss		// Default parameters	endif	ReDimension /N=5 HPFitCoefs	ReDimension /N=5 HPFitCoefsLegend	ReDimension /N=5 HoldHPFitCoefs		HPFitCoefsLegend[0]="BG Poly 0"	HPFitCoefsLegend[1]="BG Poly 1"	HPFitCoefsLegend[2]="BG Poly 2"	HPFitCoefsLegend[3]="BG Poly 3"	HPFitCoefsLegend[4]="2-theta offset"		// Generate the list of reflections to include	ReflectionsList = MakeReflectionsList(UnitFitTypeStr)	// Update the Legend for the given Space Group//	SpaceGroup = ReturnTextBeforeNthChar(UnitFitTypeStr,":",1)	SpaceGroup = StripSuffixBySeparator(UnitFitTypeStr,":")	LegendList = LegendForSpaceGroup(SpaceGroup)		// Unit cell parameters	AddPeakToCoefWave(HPFitCoefs, Params_Cell, HPFitCoefsLegend,LegendList,HoldHPFitCoefs,Hold_Cell)	ApplyUnitCellConstraints(SpaceGroup,HPFitCoefs,HoldHPFitCoefs)		// Peak Profile parameters	AddPeakToCoefWave(HPFitCoefs, Params_Profile, HPFitCoefsLegend,"Profile U;Profile V;Profile W;Profile A;Mixing;",HoldHPFitCoefs,Hold_Profile)		Make /O/N=1 Params_SglPeak, Hold_SglPeak		i=0	do		Params_SglPeak[0] = Params_Peak[i]		Hold_SglPeak[0] = Hold_Peak[i]		PeakLegendList = StringFromList(i,ReflectionsList) +" Peak Intensity;"		AddPeakToCoefWave(HPFitCoefs, Params_SglPeak, HPFitCoefsLegend,PeakLegendList,HoldHPFitCoefs,Hold_SglPeak)				i+=1	while(i<gMaxNoPeaks)		// Add Amorphous scattering background	if (AmBGFlag == 1)		AmBGList = "Amorphous BG Intensity;Bond Length;Debye Waller Factor;"		AddPeakToCoefWave(HPFitCoefs, Params_AmBG, HPFitCoefsLegend,AmBGList,HoldHPFitCoefs,Hold_AmBG)	endif		// Add additional Gaussian peaks	if (NExtraGauss>0)		Make /O/N=3 Params_SglGauss		i=0		do			Params_SglGauss[] = Params_Gauss[p+3*i]			ExtraPeakList = "Gaussian Intensity;Position;Width;"			AddPeakToCoefWave(HPFitCoefs, Params_SglGauss, HPFitCoefsLegend,ExtraPeakList,HoldHPFitCoefs,Hold_Gauss)			i+=1		while(i<NExtraGauss)	endif		KillWaves /Z Params_Cell, Hold_Cell, Params_Profile, Hold_Profile	KillWaves /Z Params_Peak, Hold_Peak, Params_SglPeak, Hold_SglPeak, Params_AmBG, Hold_AmBG	KillWaves /Z Params_Gauss, Hold_Gauss, Params_SglGaussEndFunction AddPeakToCoefWave(Coef, CoefValues, CoefLegend,CoefLegendList,Hold,HoldValues)	Wave Coef, CoefValues, Hold, HoldValues	Wave /T CoefLegend	String CoefLegendList		Variable NumParams, PrevNPts, i, j	NumParams = ItemsInList(CoefLegendList)	PrevNPts = numpnts(Coef)	ReDimension /N=(PrevNPts+NumParams) Coef	if (waveexists(CoefLegend) == 1)		ReDimension /N=(PrevNPts+NumParams) CoefLegend	endif	if (waveexists(Hold) == 1)		ReDimension /N=(PrevNPts+NumParams) Hold	endif		i=0	j=PrevNPts	do		if (waveexists(CoefValues) == 1)			Coef[j] = CoefValues[i]		endif				CoefLegend[j] = StringFromList(i,CoefLegendList)				if (waveexists(HoldValues) == 1)			Hold[j] = HoldValues[i]		endif		j+=1		i+=1	while(i<NumParams)End// ********************************************************// ******     			Smaller XRD DATA Fitting Routines// ********************************************************Function  SelectUnitFitType(ctrlName,popNum,popStr) : PopupMenuControl	String ctrlName	Variable popNum	String popStr		SVAR gUnitFitModels=gUnitFitModels	SVAR gUnitFitTypeStr=gUnitFitTypeStr	SVAR gSamplePeakType=gSamplePeakType	NVAR gUnitFitType=gUnitFitType	NVAR gAmBGFlag=gAmBGFlag	NVAR gNExtraGauss=gNExtraGauss		// Backwards compatibility!	if (exists("gUnitFitTypeStr")==0)		String /G gUnitFitTypeStr = StringFromList(gUnitFitType-1, gUnitFitModels)	endif	gUnitFitTypeStr = popStr	gUnitFitType = popNum//	popStr = StringFromList(gUnitFitType-1, gUnitFitModels)	Variable UserPromptFlag = 1	if (exists("HPFitCoefs")==1)		UserPromptFlag=0	endif		CreateHPCoefs(gSamplePeakType,gUnitFitTypeStr,gAmBGFlag, gNExtraGauss)	if (UserPromptFlag==1)		DoAlert 0, "Please enter some reasonable coefficient values!"		return 0	endifEndFunction  SelectSamplePeakType(ctrlName,popNum,popStr) : PopupMenuControl	String ctrlName	Variable popNum	String popStr		SVAR gUnitFitModels=gUnitFitModels	SVAR gUnitFitTypeStr=gUnitFitTypeStr	SVAR gSamplePeakType=gSamplePeakType	NVAR gUnitFitType=gUnitFitType	NVAR gAmBGFlag=gAmBGFlag	NVAR gNExtraGauss=gNExtraGauss		gSamplePeakType = popStr		// Backwards compatibility!	if (exists("gUnitFitTypeStr")==0)		String /G gUnitFitTypeStr = StringFromList(gUnitFitType-1, gUnitFitModels)	endif	CreateHPCoefs(gSamplePeakType,gUnitFitTypeStr,gAmBGFlag,gNExtraGauss)EndFunction SetNExtraGaussians(ctrlName,varNum,varStr,varName) : SetVariableControl	String ctrlName	Variable varNum	String varStr	String varName		SVAR gUnitFitModels=gUnitFitModels	SVAR gUnitFitTypeStr=gUnitFitTypeStr	SVAR gSamplePeakType=gSamplePeakType	NVAR gUnitFitType=gUnitFitType	NVAR gAmBGFlag=gAmBGFlag	NVAR gNExtraGauss=gNExtraGauss		gNExtraGauss = varNum		// Backwards compatibility!	if (exists("gUnitFitTypeStr")==0)		String /G gUnitFitTypeStr = StringFromList(gUnitFitType-1, gUnitFitModels)	endif	CreateHPCoefs(gSamplePeakType,gUnitFitTypeStr,gAmBGFlag,gNExtraGauss)EndFunction SetNumDiffractionPeaks(ctrlName,varNum,varStr,varName) : SetVariableControl	String ctrlName	Variable varNum	String varStr	String varName		SVAR gUnitFitModels=gUnitFitModels	SVAR gUnitFitTypeStr=gUnitFitTypeStr	SVAR gSamplePeakType=gSamplePeakType	NVAR gUnitFitType=gUnitFitType	NVAR gAmBGFlag=gAmBGFlag	NVAR gNExtraGauss=gNExtraGauss	NVAR gMaxNoPeaks=gMaxNoPeaks		gMaxNoPeaks = varNum		// Backwards compatibility!	if (exists("gUnitFitTypeStr")==0)		String /G gUnitFitTypeStr = StringFromList(gUnitFitType-1, gUnitFitModels)	endif	CreateHPCoefs(gSamplePeakType,gUnitFitTypeStr,gAmBGFlag,gNExtraGauss)EndProc SetAmorphousBG(ctrlName,checked) : CheckBoxControl	String ctrlName	Variable checked	PauseUpdate; Silent 1		gAmBGFlag = checked		// Backwards compatibility!	if (exists("gUnitFitTypeStr")==0)		String /G gUnitFitTypeStr = StringFromList(gUnitFitType-1, gUnitFitModels)	endif	CreateHPCoefs(gSamplePeakType,gUnitFitTypeStr,gAmBGFlag,gNExtraGauss)EndProc RecordVolume(ctrlName,checked) : CheckBoxControl	String ctrlName	Variable checked	PauseUpdate; Silent 1		gRecordCellVolFlag = checked		if (gRecordCellVolFlag == 1)		String /G gVolumesName, gVolumeErrorsName		String VolumesAxisName, VolumesAxisErrorsName				if (exists(gVolumesName)==0)			gVolumesName = GenericUserStringInput(ListOfDataNames[0] + "_Volumes","Name for saving the unit cell volumes")			gVolumesName = ReplaceTextInString(gVolumesName,"_data","")+"_data"			gVolumeErrorsName = gVolumesName+"_sig"			VolumesAxisName = ReplaceTextInString(gVolumesName,"_data","")+ "_axis"			VolumesAxisErrorsName = VolumesAxisName+"_sig"			Make /O/D/N=(numpnts(ListOfDataNames)) $gVolumesName, $gVolumeErrorsName, $VolumesAxisName, $VolumesAxisErrorsName		endif	endifEndProc CalibrantOnly(ctrlName,checked) : CheckBoxControl	String ctrlName	Variable checked	PauseUpdate; Silent 1		gCalibrantFlag = checkedEndProc AutoSaveHPCoef(ctrlName,checked) : CheckBoxControl	String ctrlName	Variable checked	PauseUpdate; Silent 1		gAutoSaveHPCoefFlag = checkedEndProc GetGaussianParams(Sigma)	Variable /G gSigma	Variable Sigma = gSigma	Prompt Sigma, "Enter the gaussian sigma [FWHM ~ 2.3549 sigma]"		gSigma=SigmaEnd// ***************************************************************************// **************** 			Converting d-Spacing to 2-Theta// ***************************************************************************// Two kinds of input files: // 1. A LIST of 2theta peak position values - the filename includes "Position" and can be treated as a "_data" wave in its own right. // 2. An AXIS associated with some data - the filename ends "_axis"Proc Convert2ThetaValuesToDSpacings(PeakPosition,TTOffset,HPLambda)	Variable /G gHPLambda, gTTOffset	String /G gPeakPosition	String PositionsString = ExclusiveWaveList(ExclusiveWaveList(WaveList("*Position*", ";", ""),"_sig",";"),"_axis",";")+WaveList("*_axis", ";", "")	String PeakPosition = gPeakPosition	Prompt PeakPosition, "Choose XRD data to convert", popup, PositionsString	Variable TTOffset=gTTOffset	Prompt TTOffset, "The 2-theta offset"	Variable HPLambda=gHPLambda	Prompt HPLambda, "The x-ray wavelength []"	PauseUpdate; Silent 1		// Helps with naming if I append "_data" automatically when required.	Variable PosLen = strlen(PeakPosition)	if ((cmpstr(PeakPosition[PosLen-5,PosLen-1],"_data") != 0) && (cmpstr(PeakPosition[PosLen-5,PosLen-1],"_axis") != 0))		Print " *** Appending the suffix '_data' onto the end of the Peak Position wave"		String NewPeakPosition = PeakPosition+"_data"		Rename $PeakPosition, $NewPeakPosition		PeakPosition = NewPeakPosition	endif	gPeakPosition=PeakPosition	gTTOffset=TTOffset	gHPLambda=HPLambda		String PeakPositionError, PeakPositionAxis, PeakPositionAxisError	String dSpacing, dSpacingError, dSpacingAxis, dSpacingAxisError		PeakPositionError = PeakPosition+"_sig"	dSpacing = ReplaceTextInString(PeakPosition,"Position","dSpacing")	dSpacingError = dSpacing+"_sig"		Duplicate /O/D $PeakPosition, $dSpacing, $dSpacingError, dS1, dS2	$dSpacingError = 0		// Include any fitted 2-theta offset	$PeakPosition += TTOffset	$dSpacing = TwoThetaTod(gHPLambda,$PeakPosition)		if (exists(PeakPositionError)==1)		dS1[] = TwoThetaTod(gHPLambda,$PeakPosition[p]+$PeakPositionError[p])		dS2[] = TwoThetaTod(gHPLambda,$PeakPosition[p]-$PeakPositionError[p])		// Is this the best way to estimate error propagation? 		$dSpacingError = abs(dS1-dS2)/2	endif	KillWaves /Z dS1, dS2	// Include any fitted 2-theta offset	$PeakPosition -= TTOffset		dSpacingAxis = ReplaceTextInString(dSpacing,"_data","_axis")	dSpacingAxisError = dSpacingAxis+"_sig"	PeakPositionAxis = ReplaceTextInString(PeakPosition,"_data","_axis")	PeakPositionAxisError = PeakPositionAxis+"_sig"		if (exists(PeakPositionAxis)==0)		FindWavesOfSameLength(PeakPosition)		String /G gPeakPositionAxis		GetPeakPositionAxis()		PeakPositionAxis=gPeakPositionAxis	endif	Duplicate /O/D $PeakPositionAxis, $dSpacingAxis $dSpacingAxisError	if (exists(PeakPositionAxisError)==1)		$dSpacingAxisError = $PeakPositionAxisError	else		$dSpacingAxisError=0	endif	Killstrings /Z gPeakPositionAxis, gCandidateAxisListEnd// ***************************************************************************// **************** 			Converting d-Spacing to 2-Theta// ***************************************************************************// Single kind of input files: // 1. An AXIS associated with some data - the filename ends "_axis"Proc ConvertDSpacingAxisTo2Theta(dSpacing,HPLambda)	Variable /G gHPLambda	String /G gdSpacing	String dSpacingsString = "all axis waves;"+WaveList("*_axis", ";", "")	String dSpacing = gdSpacing	Prompt dSpacing, "Choose XRD data to convert", popup, dSpacingsString	Variable HPLambda=gHPLambda	Prompt HPLambda, "The x-ray wavelength []"	PauseUpdate; Silent 1		gdSpacing=dSpacing	gHPLambda=HPLambda		String SingleAxisName	Variable NAxes, i=0		Print " *** Converting the following d-space axes into 2-theta, using wavelength = ",HPLambda,"."	if (cmpstr(dSpacing,"all axis waves")==0)		// Convert all axis waves ...		NAxes = ItemsInList(WaveList("*_axis", ";", ""))		do			SingleAxisName = StringfromList(i,WaveList("*_axis", ";", ""))			Print "          ........ ",SingleAxisName			SingleDTo2Theta(SingleAxisName,HPLambda)			i+=1		while(i<NAxes)	else		// ... or just the chosen one. 		SingleDTo2Theta(dSpacing,HPLambda)	endifEndProc SingleDTo2Theta(SingleAxisName,HPLambda)	String SingleAxisName	Variable HPLambda	PauseUpdate; Silent 1	String SingleAxisErrors, SingleDataName, SingleDataErrors	SingleDataName = ReplaceTextInString(SingleAxisName,"_axis","_data")	SingleAxisErrors = SingleAxisName+"_sig"	SingleDataErrors = SingleDataName+"_sig"		$SingleAxisName[] = dToTwoTheta(HPLambda,$SingleAxisName[p])		if (exists(SingleDataName)==1)		if ((exists(SingleAxisErrors)==1) && (exists(SingleDataErrors)==1))			Sort $SingleAxisName, $SingleAxisName, $SingleDataName, $SingleAxisErrors, $SingleDataErrors		else			if ((exists(SingleAxisErrors)==1) && (exists(SingleDataErrors)==0))				Sort $SingleAxisName, $SingleAxisName, $SingleDataName, $SingleAxisErrors			else				if ((exists(SingleAxisErrors)==0) && (exists(SingleDataErrors)==1))					Sort $SingleAxisName, $SingleAxisName, $SingleDataName, $SingleDataErrors				else					Sort $SingleAxisName, $SingleAxisName, $SingleDataName				endif			endif		endif	else		Sort $SingleAxisName, $SingleAxisName	endifEnd// ***************************************************************************// **************** 			Converting Voigt Parameters to FWHM// ***************************************************************************Proc ConvertPeakCoefficientsToFWHM(Peaktype,PeakName,BSizeFlag,Size,HPLambda)	Variable /G gHPLambda	String /G gPeakName	String PeaksString = ReplaceTextInList(WaveList("*_Width_data", ";", ""),"_Width_data","")	//	Variable PeakType	Prompt Peaktype, "Peak type", popup, "Voigt;Gaussian;Lorentzian;"	//	String PeakName = gPeakName	Prompt PeakName, "Choose peak for FWHM calculation", popup, PeaksString	//	Variable HPLambda=gHPLambda	Prompt HPLambda, "The x-ray wavelength []"	// 	Variable BSizeFlag	Prompt BSizeFlag, "Remove finite size contribution?", popup, "yes;no;"	Variable Size	Prompt Size, "Particle size []"	PauseUpdate; Silent 1		gPeakName=PeakName	gHPLambda=HPLambda		if (PeakType>1)		DoAlert 0, "Only Voigt curves supported at present!"		return	endif		Variable i=0	String PositionName = PeakName + "_Position_data"	String WidthName = PeakName + "_Width_data"	String WidthAxisName = PeakName + "_Width_axis"	String ShapeName = PeakName + "_Shape_data"	String FWHMName = PeakName + "_FWHM_data"	String FWHMAxisName = PeakName + "_FWHM_axis"		if ((exists(WidthName)==0) || (exists(ShapeName)==0))		DoAlert 0, "Please create and choose the suitable peak parameter waves!"		return	endif		if (numpnts($WidthName) != numpnts($ShapeName))		DoAlert 0, "The peak parameter waves are not all the same length!"		return	endif		Duplicate /O/D $WidthAxisName, $FWHMAxisName	Duplicate /O/D $WidthName, $FWHMName	$FWHMName[] = CalculateBenVoigtFWHM($WidthName[p],$ShapeName[p],PeakType)		if (BSizeFlag == 1)		if (exists(PositionName)==0)			DoAlert 0, "Please create peak position wave!"			return		endif				String StrainName = PeakName + "_Strain_data"		String StrainAxisName = PeakName + "_Strain_axis"		Duplicate /O/D $WidthName, $StrainName		Duplicate /O/D $WidthAxisName, $StrainAxisName				Variable BSize		do			BSize = 0.9*HPLambda/(Size*cos(pi*$PositionName[i]/360))						$StrainName[i] = sqrt($WidthName[i]^2 - BSize^2)			i+=1		while(i<numpnts($WidthName))	endifEnd// ***************************************************************************// **************** 			Crystallography Functions// ***************************************************************************// Input: Unit Cell cell lengths () and angles (degrees)// Output: The unit cell vectors in cartesian coordinates.// Note: Assume that a lies along the x-axis. Then:// 		a = (ax,0,0)// 		b = (bx, by, 0)// 		c = (cx, cy, cz)Function FractionalToCartesian(Unitx,Unity,Unitz,a,b,c,alp,bet,gam)	Wave Unitx,Unity,Unitz	Variable a,b,c,alp,bet,gam		WAVE aV = aVector	WAVE bV = bVector	WAVE cV = cVector	Variable i	Variable alpha = (2*pi/360) * alp	Variable betta = (2*pi/360) * bet	Variable gama = (2*pi/360) * gam	Variable small = 1e-15	Variable nAtoms = numpnts(Unitx)		aV = 0	aV[0] = a		bV[0] = a*b*cos(gama)/aV[0]	bV[1] = sqrt(b^2 - bV[0]^2)	bV[2] = 0		cV[0] = a*c*cos(alpha)/aV[0]	cV[1] = (b*c*cos(betta) - bV[0]*cV[0])/bV[1]	cV[2] = sqrt(c^2 - cV[0]^2 - cV[1]^2)		Duplicate /O Unitx, fracUnitx	Duplicate /O Unity, fracUnity	Duplicate /O Unitz, fracUnitz		Unitx[] = fracUnitx[p]*aV[0] + fracUnity[p]*bV[0] + fracUnitz[p]*cV[0]	Unity[] = fracUnitx[p]*aV[1] + fracUnity[p]*bV[1] + fracUnitz[p]*cV[1]	Unitz[] = fracUnitx[p]*aV[2] + fracUnity[p]*bV[2] + fracUnitz[p]*cV[2]	//	KillWaves /Z fracUnitx, fracUnity, fracUnitz//	aV[] = (aV[p] < small) ? aV[p] : 0EndSTATIC Function CheckCubic(a,b,c,alp,bet,gam)	Variable a,b,c,alp,bet,gam		Variable small = 0.001	if ((abs(a-b)<small) && (abs(a-c)<small))		if ((abs(alp-90)<small) && (abs(bet-90)<small) && (abs(gam-90)<small))			return 1		endif	endif	return 0End// Note: input angles are in degrees. STATIC Function UnitCellVolume(a,b,c,alpha,beta,gama)	Variable a,b,c,alpha,beta,gama		Variable alp,bet,gam	alp = (2*pi)*(alpha/360)	bet = (2*pi)*(beta/360)	gam = (2*pi)*(gama/360)		return a*b*c*sqrt(1-(cos(alp))^2-(cos(bet))^2-(cos(gam))^2+2*cos(alp)*cos(bet)*cos(gam))End// Note: input angles are in degrees. Function dFromhkl(h,k,l,a,b,c,alpha,betta,gama)	Variable h,k,l,a,b,c,alpha,betta,gama		Variable alp,bet,gam	alp = (2*pi)*(alpha/360)	bet = (2*pi)*(betta/360)	gam = (2*pi)*(gama/360)		Variable P1, P2, P3, Q1, Q2, Q3, V		P1 = (h^2/a^2)*(sin(alp))^2	P2 = (k^2/b^2)*(sin(bet))^2	P3 = (l^2/c^2)*(sin(gam))^2		Q1 = ((2*h*k)/(a*b)) * (cos(alp)*cos(bet) - cos(gam))	Q2 = ((2*k*l)/(b*c)) * (cos(bet)*cos(gam) - cos(alp))	Q3 = ((2*l*h)/(c*a)) * (cos(gam)*cos(alp) - cos(bet))		V = UnitCellVolume(a,b,c,alpha,betta,gama)/(a*b*c)		return V/sqrt(P1 + P2 + P3 + Q1 + Q2 + Q3)EndFunction TwoTFromhkl(h,k,l,a,b,c,alpha,betta,gama,lambda)	Variable h,k,l,a,b,c,alpha,betta,gama,lambda		Variable d 	= dFromhkl(h,k,l,a,b,c,alpha,betta,gama)		Variable TwoT = lambda/(2*sin((pi/360)*d))		return TwoTEnd// ***************************************************************************//									Save as GSAS input file format// ***************************************************************************Function SaveGSASFXY(Axis,Data)	Wave Axis, Data		Variable NumAxisPts, AxisSpacing = 0.025, AppendFlag=0	String LeftDelimiter="", Delimiter="   ", NptsStr, ValueStr	Duplicate /O/D Data, tempData	Duplicate /O/D Axis, tempAxis		String SampleName = SampleNameFromDataName(NameOfWave(Data)) 	String FileName = SampleName + ".gsa"		Variable AxisStep = CheckConstantStep(tempAxis,0.0001,0)	if ((AxisStep < 0) || (AxisStep == 0))		Print " ....... Exporting",SampleName," interpolated onto a new axis of fixed step",abs(AxisStep)		NumAxisPts = MakeConstantStepAxisData(tempData,tempAxis,AxisStep)	else		Print " ....... Exporting",SampleName,"."		NumAxisPts = numpnts(tempAxis)	endif	tempAxis *= 100	String HeaderList = "gHeaderLine1;gHeaderLine2;"	String ColumnList = "tempAxis;tempData;"		String PaddingList = "0;0;"	String FormatStr = "%7.6E"	String FormatList = FormatStr+";"+FormatStr+";"	NptsStr = num2str(NumAxisPts)		String /G gHeaderLine1, gHeaderLine2	gHeaderLine1 = SampleName + ": 2-theta Scan "	gHeaderLine2 = "BANK 1  " + NptsStr + "  " + NptsStr + " CONS "		// The first 2theta value	sprintf ValueStr, FormatStr, Axis[0]*100	gHeaderLine2 += ValueStr + " "		// The 2theta step size	sprintf ValueStr, FormatStr, AxisSpacing*100	gHeaderLine2 += ValueStr + " "		// Other stuff	gHeaderLine2 += " 0 0  FXY"	//	UltimateSavePadDelColumnFile(UserNoteBookName,AppendFlag,HeaderLineList,ColumnList,FormatList,PaddingList,LeftDelimiter,Delimiter,TotPadLine,NDataPts,FileName)//	UltimateSavePadDelColumnFile("_new_",0,AppendFlag,HeaderList,ColumnList,FormatList,PaddingList,LeftDelimiter,Delimiter,80,NumAxisPts,FileName)	KillWaves /Z tempData, tempAxis	KillStrings /Z gHeaderLine1, gHeaderLine2End// ***************************************************************************//									Save as Panalytical Analysis Software input file format// ***************************************************************************Proc SavePanalyticalInputFile()	PauseUpdate; Silent 1		String DataName = PromptUserToSelectXRDData("Select the XRD data to save in Panalytical format",0,0)	if (strlen(DataName) > 0)		if (cmpstr("_all_",DataName) == 0)			Print " *** Saving all data in Panalytical format"		else			Print " *** Saving",DataName,"in Panalytical format."		endif		ConvertOneOrManyXRDAxes(DataName,0,5)	endifEndFunction SavePanalytical(Data,Axis,DataFolder)	Wave Data, Axis	String DataFolder		Duplicate /O/D Data, tempData	Duplicate /O/D Axis, tempAxis		Variable AxisStep = CheckConstantStep(tempAxis,0.0001,0)	if ((AxisStep < 0) || (AxisStep == 0))		MakeConstantStepAxisData(tempData,tempAxis,AxisStep)	endif		String SampleName = SampleNameFromDataName(NameOfWave(Data)) 	String FileName = SampleName + ".txt"		String FormatList, HeaderList = ""	String ColumnList = "tempAxis;tempData;"	WaveStats /M=1/Q Data	if (V_min<1)		FormatList = "%5.3f;%5.3f;"	else		FormatList = "%5.3f;%d;"	endif	String PaddingList = "0;0;"		String LeftDelimiter="", Delimiter="   "	Variable AppendFlag = 0, TotPadLine = 80, NumAxisPts=numpnts(Axis)	//	Print " FileName is", FileName//	UltimateSavePadDelColumnFile("_new_",0,AppendFlag,HeaderList,ColumnList,FormatList,PaddingList,LeftDelimiter,Delimiter,80,NumAxisPts,FileName)		KillWaves /Z tempData, tempAxisEnd