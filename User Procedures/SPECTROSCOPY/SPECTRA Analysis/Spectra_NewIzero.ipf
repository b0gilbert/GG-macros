#pragma rtGlobals=1		// Use modern global access method.// *!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*// ****					Important Notes on Copies and Updates// *!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*// 	Whenever data files are plotted, duplicates of each plotted data are made in the folder "root:SPECTRA:Plotting:"+PlotName+":DataDuplicates"//	Whenever any of the "Align" functions are used, the transformed data is generated by applying an operation to the untouched saved data. Function MakeIzeroFolder()	NewDataFolder/O root:SPECTRA	NewDataFolder/O root:SPECTRA:Fitting	NewDataFolder/O root:SPECTRA:Fitting:IzeroFitEndFunction MakeIoCoefficients(PlotName)	String PlotName		String CopyFolderName = "root:SPECTRA:Plotting:"+PlotName+":DataDuplicates"	String DataName, CoefName, TraceList = AxisTraceListBG(PlotName,"left","")	Variable i, NumTraces = ItemsInList(TraceList)		for (i=0;i<NumTraces;i+=1)		DataName 	= Replacestring("_data",StringFromList(i,TraceList),"")		CoefName	= DataName+"_IoCf"		Make /D/N=5 $(CheckFolderColon(CopyFolderName)+CoefName)=NAN	endforEnd// *************************************************************// ****		Manual Subtraction or Division of One Trace by Another, or by the polynomial// *************************************************************Function ApplyManualNormMethod(PlotName,PlotFolderName,Selection1,Selection2,Selection3,AutoKeepFlag)	String PlotName,PlotFolderName,Selection1,Selection2,Selection3	Variable AutoKeepFlag		String ResultName, IzeroFolderName = "root:SPECTRA:Fitting:IzeroFit"	String MathOpName, CopyFolderName = "root:SPECTRA:Plotting:"+PlotName+":DataDuplicates"	//	WAVE axis 		= XWaveRefFromTrace(PlotName,Selection1)				// The trace axis//	WAVE data		= TraceNameToWaveRef(PlotName,Selection1)				// The original data, overwritten following an Alignment.//	Variable NPts = numpnts(data)		NVAR gPlotIoDiff			= $(PlotFolderName+":gPlotIoDiff")	NVAR gPlotIoMult			= $(PlotFolderName+":gPlotIoMult")	NVAR gPlotIoRatio			= $(PlotFolderName+":gPlotIoRatio")	NVAR gIoRatioMinus1		= $(PlotFolderName+":gIoRatioMinus1")		NVAR	gData3Scale			= $(PlotFolderName+":gData3Scale")		Variable NPts 	= DimSize(TraceNameToWaveRef(PlotName,Selection1),0)	Variable Cmplx1 = WaveType(TraceNameToWaveRef(PlotName,Selection1)) & 0x01	Variable Cmplx2 = WaveType(TraceNameToWaveRef(PlotName,Selection2)) & 0x01		Variable CmplxMath	if ((Cmplx1==1) && (Cmplx2==1))		CmplxMath = 1		Make /C/O/D/N=(NPts) ResultC, ResultErrorsC	elseif ((Cmplx1==0) && (Cmplx2==0))		CmplxMath = 0		Make /O/D/N=(NPts) Result, ResultErrors	else		Print " *** Cannot do math on mixed complex and real waves"		return 0	endif		String OldDF = getDataFolder(1)	NewDataFolder/O/S root:SPECTRA:Fitting	NewDataFolder/O/S root:SPECTRA:Fitting:IzeroFit		KillWaves /Z DataMinusBG, DataDivideBG, DataMultiplyBG, DataMinusBG_sig, DataDivideBG_sig, DataMultiplyBG_sig			if (WaveExists(TraceNameToWaveRef(PlotName,Selection2)) == 0)			Print " *** Manual background subtraction failed. The second trace ("+Selection2+") is not actually plotted. This is probably a bug. "		else					if (cmpstr("_none_",Selection1) == 0)			elseif (cmpstr("_all_",Selection1) == 0)				print " *** Currently these Math routines do not work on ALL traces. You might try to reboot the Serial Data Processing"			else								if (gPlotIoDiff)					MathOpName = "Subtraction"				endif				if (gPlotIoRatio)					if (gIoRatioMinus1)						MathOpName = "Division less one"					else						MathOpName = "Division"					endif				endif				if (gPlotIoMult)					MathOpName = "Multiplication"				endif										if (CmplxMath)					ApplyMathToTwoCmplxWaves(TraceNameToWaveRef(PlotName,Selection1),XWaveRefFromTrace(PlotName,Selection1),TraceNameToWaveRef(PlotName,Selection2),XWaveRefFromTrace(PlotName,Selection2), ResultC,1,MathOpName)										if (gPlotIoDiff)						Duplicate /O ResultC, $"DataMinusBG"					endif					if (gPlotIoRatio)						Duplicate /O ResultC, $"DataDivideBG"					endif					if (gPlotIoMult)						Duplicate /O ResultC, $"DataMultiplyBG"					endif				else				//				print Selection3//				print NameOfWave(TraceNameToWaveRef(PlotName,Selection3))								// 2025-09-08 					if ( WaveExists(TraceNameToWaveRef(PlotName,Selection3)) )						ApplyMathToThreeDataWaves(TraceNameToWaveRef(PlotName,Selection1),XWaveRefFromTrace(PlotName,Selection1),TraceNameToWaveRef(PlotName,Selection2),XWaveRefFromTrace(PlotName,Selection2),TraceNameToWaveRef(PlotName,Selection3),XWaveRefFromTrace(PlotName,Selection3), Result,gData3Scale,1,MathOpName)					else						ApplyMathToTwoDataWaves(TraceNameToWaveRef(PlotName,Selection1),XWaveRefFromTrace(PlotName,Selection1),TraceNameToWaveRef(PlotName,Selection2),XWaveRefFromTrace(PlotName,Selection2), Result,1,MathOpName)							endif										if (gPlotIoDiff)						Duplicate /O Result, $"DataMinusBG"					endif					if (gPlotIoRatio)						Duplicate /O Result, $"DataDivideBG"					endif					if (gPlotIoMult)						Duplicate /O Result, $"DataMultiplyBG"					endif				endif								ShowNormalizationResults(PlotName,PlotFolderName,Selection1,Selection2,3,0)								if (AutoKeepFlag)					KeepIzeroResults(PlotName,PlotFolderName,Selection1,Selection2,3)				endif							endif		endif		SetDataFolder $(OldDF)End//					Make /O/D/N=(NPts) $("DataMinusBG") /WAVE=Result//					Make /O/D/N=(NPts) $("DataMinusBG_sig") /WAVE=ResultErrors//					Make /O/D/N=(NPts) $("DataDivideBG") /WAVE=Result//					Make /O/D/N=(NPts) $("DataDivideBG_sig") /WAVE=ResultErrors//					Make /O/D/N=(NPts) $("DataMultiplyBG") /WAVE=Result//					Make /O/D/N=(NPts) $("DataMultiplyBG_sig") /WAVE=ResultErrors// *************************************************************// ****		Main routine for launching two background removal methods// *************************************************************Function BackgroundRemovalProc(PlotName,PlotFolderName,Selection1,Selection2,BGType,AxisOffset,FitAxisOffset,FitScaleFactor,PolyOrder,IoMaskFlag,CsrRangeChoice,IoRatioMinus1,AutoKeepFlag)	String PlotName,PlotFolderName,Selection1, Selection2	Variable BGType, AxisOffset,FitAxisOffset, FitScaleFactor, PolyOrder,IoMaskFlag,CsrRangeChoice,IoRatioMinus1, AutoKeepFlag		String Selection	Variable i, GoodFitFlag, ReportFlag=1, NumTraces = ItemsInList(TraceNameList(PlotName, ";", 1),";")		// Cannot define fit range by point values, because subsequent interpolation may mess this up	Variable FitMin = min(GetCursorPositionOrValue(PlotName,"A",1),GetCursorPositionOrValue(PlotName,"B",1))	Variable FitMax = max(GetCursorPositionOrValue(PlotName,"A",1),GetCursorPositionOrValue(PlotName,"B",1))		if (FitMin == FitMax)		DoAlert 0, "Please expand the region selected by the cursors"		return 0	endif		RemoveFromGraph /Z polynomial	MirrorLeftAxisIfRightAxisUnused("")		if (cmpstr("_none_",Selection1) == 0)		// No traces selected. 		return 0			elseif (cmpstr("_all_",Selection1) == 0)		// All traces selected				for (i=0;i<NumTraces;i+=1)			ReportFlag 	= 0							// disable reporting results if we are selecting ALL			Selection 		= NameOfWave(WaveRefIndexed(PlotName,i,1))			GoodFitFlag 	= LaunchBGRemoval(PlotName,PlotFolderName,Selection,Selection2,FitMin, FitMax,BGType,AxisOffset,FitAxisOffset,FitScaleFactor,PolyOrder,IoMaskFlag,CsrRangeChoice,IoRatioMinus1,AutoKeepFlag,ReportFlag)						if (GoodFitFlag < 0)				return 0 // Means we need to stop the entire fitting loop			endif		endfor				GoodFitFlag 	= 0	 							// disable plotting results if we are selecting ALL				else		GoodFitFlag 	= LaunchBGRemoval(PlotName,PlotFolderName,Selection1,Selection2,FitMin, FitMax,BGType,AxisOffset,FitAxisOffset,FitScaleFactor,PolyOrder,IoMaskFlag,CsrRangeChoice,IoRatioMinus1,AutoKeepFlag,ReportFlag)	endif		if (GoodFitFlag == 1)								// Single trace selected		ShowNormalizationResults(PlotName,PlotFolderName,Selection1,Selection2,BGType,PolyOrder)	else		RemoveFromGraph /Z/W=$PlotName polynomial, DataMinusBG, DataDivideBG	endifEndFunction LaunchBGRemoval(PlotName,PlotFolderName,Selection1,Selection2,FitMin, FitMax,BGType,AxisOffset,FitAxisOffset,FitScaleFactor,PolyOrder,IoMaskFlag,CsrRangeChoice,IoRatioMinus1,AutoKeepFlag,ReportFlag)	String PlotName,PlotFolderName,Selection1, Selection2	Variable FitMin, FitMax,BGType, AxisOffset,FitAxisOffset, FitScaleFactor, PolyOrder,IoMaskFlag,CsrRangeChoice,IoRatioMinus1, AutoKeepFlag, ReportFlag		WAVE axis 		= XWaveRefFromTrace(PlotName,Selection1)									// The trace axis	WAVE results		= TraceNameToWaveRef(PlotName,Selection1)									// The original data, overwritten following an Alignment.	WAVE data			= $(CheckFolderColon(PlotFolderName)+"DataDuplicates:"+Selection1)		// The duplicated data stored in Graph:DataDuplicates		// Make sure that the actual mask and axis are associated with the data	DisplayMaskBeneathData(PlotName,PlotFolderName,Selection1)	WAVE Iomask 		= $(PlotFolderName+":mask")	WAVE Pymask 		= $(PlotFolderName+":invmask")		NVAR PolyZeroFlag 	= $(PlotFolderName+":gPolyZeroFlag")		if (WaveExists(data) == 0)		return 0	endif			Variable GoodFitFlag=-0, BIG=2e9, SplineOrder=100*PolyOrder		if (BGType == 1)		GoodFitFlag 	= PolynomialFit(axis,data,Pymask,FitMin,FitMax,PolyOrder,CsrRangeChoice,IoMaskFlag,IoRatioMinus1,PolyZeroFlag)			elseif (BGType == 4)		GoodFitFlag 	= ExponentialFit(axis,data,Pymask,FitMin,FitMax,PolyOrder,CsrRangeChoice,IoMaskFlag,IoRatioMinus1,PolyZeroFlag)			elseif (BGType == 3)		GoodFitFlag 	= SplineFit(axis,data,Pymask,FitMin,FitMax,SplineOrder,CsrRangeChoice,IoMaskFlag,IoRatioMinus1)					elseif (BGType == 2)		if (XWaveRefFromTrace(PlotName,Selection1)[0] > XWaveRefFromTrace(PlotName,Selection1)[BIG])			Print " 		Skipping",Selection1,". The axis runs from low to high, causing problems for these fit routines. "		elseif (cmpstr(Selection1,Selection2) == 0)			// Selections 1 and 2 are identical. 		else			GoodFitFlag = IzeroFit(PlotFolderName,axis,data,results,XWaveRefFromTrace(PlotName,Selection2),TraceNameToWaveRef(PlotName,Selection2),Pymask,FitMin,FitMax,AxisOffset,FitAxisOffset,FitScaleFactor,PolyOrder,CsrRangeChoice,IoMaskFlag,IoRatioMinus1,ReportFlag)		endif	endif		if ((GoodFitFlag) && (AutoKeepFlag))		KeepIzeroResults(PlotName,PlotFolderName,Selection1,Selection2,BGType)	endif				return GoodFitFlagEnd// *************************************************************// ****		Izero FITTING: Scale, Offset and Shift one (Io) trace relative to another// *************************************************************Function IzeroFit(PlotFolderName,axis,data,results,IzeroAxis,Izero,mask,FitMin,FitMax,AxisOffset,FitAxisOffset,FitScaleFactor,POrder,CsrRangeChoice,UseMaskFlag,IoRatioMinus1,ReportFlag)	String PlotFolderName	Wave axis					// The axis of Selected Trace 1	Wave data					// The Duplicate of Selected Trace 1	Wave results				// The Selected Trace 1	Wave IzeroAxis			// The axis of Selected Trace 2	Wave Izero				// The Selected Trace 2	Wave mask	Variable FitMin,FitMax,AxisOffset,FitAxisOffset,FitScaleFactor,POrder,CsrRangeChoice,UseMaskFlag,IoRatioMinus1,ReportFlag			NVAR gFitDataOffset		= $(PlotFolderName+":gFitDataOffsetFlag")	Variable PolyZeroFlag 	= NumVarOrDefault(PlotFolderName+":gPolyZeroFlag",0)		String holdStr, msg	Variable NIoPts, NMaskPts, Npts = numpnts(IzeroAxis), GoodFitFlag		// These fit range point values are relative to the (fixed) Izero axis. 	Variable FitMinPt	= min(AxisValueToPoint(IzeroAxis, FitMin),AxisValueToPoint(IzeroAxis, FitMax))	Variable FitMaxPt	= max(AxisValueToPoint(IzeroAxis, FitMin),AxisValueToPoint(IzeroAxis, FitMax))		Variable RatioOffset 	= (IoRatioMinus1 == 1) ? 1 : 0		// Check whether a mask exists, if it is requests. 	if (UseMaskFlag && (waveexists(mask))==0)		UseMaskFlag = 0	endif		String OldDF = getDataFolder(1)	NewDataFolder/O/S root:SPECTRA:Fitting	NewDataFolder/O/S root:SPECTRA:Fitting:IzeroFit		KillWaves /A/Z				NVAR gAxisOffset					= $(PlotFolderName+":gAxisOffset")		NVAR gLogYLeft					= $(PlotFolderName+":gLogYLeft")		Variable /G gLogFlag 				= gLogYLeft				Variable /G gBGType				= 2		Variable /G gMinFitPt			= FitMinPt		Variable /G gMaxFitPt			= FitMaxPt		Variable /G gMaskFlag			= UseMaskFlag				Make /O/D/N=(Npts) AxisOrig, DataOrig, AxisShift, DataShift, MaskOrig, IzeroOrig		Make /O/D/N=(Npts) polynomial=NAN, DataMinusBG=NAN, DataDivideBG=NAN, DataMultiplyBG=NAN		Make /O/D/N=(Npts) DataMinusBG_sig=NAN, DataDivideBG_sig=NAN, DataMultiplyBG_sig=NAN		Make /O/T/N=1 T_Constraints		T_Constraints[0] = {"K1 > 0"}				if (ReportFlag)			msg = "\r *** Aligning the spectrum "+ReplaceString("_data",NameOfWave(data),"")+" to the spectrum "+ReplaceString("_data",NameOfWave(Izero),"")+" using a scale factor and offset."			msg += " Data range is "+num2str(IzeroAxis[FitMinPt])+" to "+num2str(IzeroAxis[FitMaxPt])+"."			if (ReportFlag)				if (POrder == 0)					msg += " No polynomial background. "				else					msg += " Including a polynomial background with "+num2str(POrder)+" terms. "				endif			endif			if (UseMaskFlag==1)				msg = ReplaceString("the spectrum",msg,"the masked spectrum")			endif			if (gLogYLeft==1)				msg = ReplaceString("Aligning",msg,"Aligning (log units) ")			endif			Print msg		endif				WaveStats /Q/M=1 data		if (V_numNANS > 0)			if (ReportFlag)				Print " 		... Replacing NANs in the data with zeroes"			endif			ReplaceNANsWithValue(data,0)		endif				// All the data, Izero and mask waves need to be on the Izero axis. 		Variable /G gPolyCenterOffset	= 0		if (PolyZeroFlag==0)			gPolyCenterOffset	= mean(IzeroAxis,FitMinPt,FitMaxPt)		endif				AxisOrig 	= IzeroAxis		if (EqualWaves(axis,IzeroAxis,1) != 1)			if (ReportFlag)				Print " 		... Interpolating",ReplaceString("_data",NameOfWave(data),""),"onto the axis of",ReplaceString("_data",NameOfWave(Izero) ,"")			endif			DataOrig[] 	= data[BinarySearchInterp(axis, AxisOrig[p])]			if (UseMaskFlag)				MaskOrig[] 	= round(mask[BinarySearchInterp(axis, AxisOrig[p])])			endif		else			DataOrig[] 	= data[p]			if (UseMaskFlag)				MaskOrig[] 	= mask[p]			endif		endif		DataShift[] = DataOrig[p]				if (gLogYLeft == 1)			IzeroOrig 	= log(Izero)		else			IzeroOrig 	= Izero		endif				if ((FitAxisOffset == 1) && (AxisOffset == 0))			AxisOffset = gPolyCenterOffset/1000		// Enforce non-zero initial guess		endif				// Make the Coefficient waves		if (!(WaveExists(IoCoefs)))			Make /D/O/N=(3+POrder) IoCoefs		else			ReDimension /N=(3+POrder) IoCoefs		endif		if  (!(WaveExists(PyCoefs)))			Make /D/O/N=(1+POrder) PyCoefs=1		else			ReDimension /N=(1+POrder) PyCoefs		endif				IoCoefs[0]		= AxisOffset				// Rigid axis shift		IoCoefs[1]		= 1							// Spectrum scaling		IoCoefs[2,]	= PyCoefs[p-2]			// Offset (POrder = 0) and polynomial terms				holdStr 	= num2str((FitAxisOffset == 0))		holdStr 	+= num2str((FitScaleFactor == 0))		holdStr 	+= MakeStringOfChars(1+POrder,"0")				if (UseMaskFlag)			WaveStats /W/Q/M=1/R=[FitMinPt,FitMaxPt] MaskOrig			WAVE M_WaveStats						if (M_WaveStats[3] == 0)				DoAlert 0, "The entire fit range is masked!"				SetDataFolder $(OldDF)				return 0			endif						NMaskPts = M_WaveStats[23]			Make /O/D/N=(NMaskPts) DataMasked, IzeroMasked, AxisMasked			KillWaves M_WaveStats		endif						Variable V_FitOptions=4						// Hide the Fit display update window		Variable V_FitQuitReason, V_FitError		// Allow diagnosis of fit failure				if (UseMaskFlag==1)			FuncFit /Q/H=holdStr AxisShiftIzeroPolyMaskBG,  IoCoefs,  IzeroOrig[FitMinPt,FitMaxPt] /X=AxisOrig /M=MaskOrig /C=T_Constraints		else			if (FitScaleFactor)				FuncFit /Q/H=holdStr AxisShiftIzeroPolyBG,  IoCoefs,  IzeroOrig(FitMinPt,FitMaxPt) /X=AxisOrig /C=T_Constraints			else				FuncFit /Q/H=holdStr AxisShiftIzeroPolyBG,  IoCoefs,  IzeroOrig(FitMinPt,FitMaxPt) /X=AxisOrig			endif		endif				if (ReportFlag)			Print FittingReport(V_FitError,V_FitQuitReason,V_chisq,0,(numpnts(IoCoefs) > 3))		endif				if ((V_FitError == 0) && (V_FitQuitReason == 0))					msg 	= "                 Scale Factor = " + num2str(IoCoefs[1]) + ". Offset = " + num2str(IoCoefs[2]) + ". "						if (FitAxisOffset == 1)				gAxisOffset = IoCoefs[0]				ShiftDataOnAxis(AxisOrig,DataShift,DataOrig,gAxisOffset,0)				msg = msg + "Axis shift = " + num2str(gAxisOffset) + "." 			endif						if (ReportFlag)				Print msg			endif						PyCoefs[]	= IoCoefs[p+2]						polynomial = NAN			results 	= NAN						Variable MinPt=0, MaxPt=numpnts(axis) - 1			if (CsrRangeChoice == 1)				// Default - update the entire axis range. 				FitMinPt=0;FitMaxPt=inf	// <--- ugly solution to getting the polynomial range correct. 			elseif (CsrRangeChoice == 2)				// Update only the range between the cursors. Set the rest to NAN. 				MinPt 	= min(AxisValueToPoint(axis, FitMin),AxisValueToPoint(axis, FitMax))				MaxPt 	= max(AxisValueToPoint(axis, FitMin),AxisValueToPoint(axis, FitMax))			else				// Truncate the results to the cursor range				WaveStats /Q/M=1/R=[FitMinPt,FitMaxPt] IzeroAxis				ReDimension /N=(V_npnts) axis, data, polynomial, results				ReDimension /N=(V_npnts) DataMinusBG, DataMultiplyBG, DataDivideBG, DataMinusBG_sig, DataMultiplyBG_sig, DataDivideBG_sig								// The actual axis is converted to the truncated Selection2 axis. 				axis[] 			= IzeroAxis[FitMinPt+p]								MinPt 	= 0				MaxPt 	= numpnts(axis) - 1			endif						// The polynomial is on the Izero axis			polynomial[FitMinPt,FitMaxPt] 	= PolynomialPart(PyCoefs,AxisOrig[p])						// The results are exactly the plotted data on their own axis. 			results[MinPt,MaxPt] 		= IoCoefs[1]*DataShift[BinarySearchInterp(AxisOrig, axis[p])] + polynomial[BinarySearchInterp(AxisOrig, axis[p])]						// Do not update the data (saved in the PlotFolder:DataDuplicates) . This allows the Undo button to work. 						DataMinusBG[MinPt,MaxPt]		= results[p] - Izero[BinarySearchInterp(AxisOrig, axis[p])]			DataMultiplyBG[MinPt,MaxPt]	= results[p] * Izero[BinarySearchInterp(AxisOrig, axis[p])]			DataDivideBG[MinPt,MaxPt]		= results[p]/Izero[BinarySearchInterp(AxisOrig, axis[p])] - RatioOffset						// ERROR PROPAGATION									GoodFitFlag = 1		else			GoodFitFlag = 0		endif	SetDataFolder $(OldDF)		return GoodFitFlagEndFunction IzeroErrorPropagation()	WAVE Results_sig 		= $(ReplaceString("_data",GetWavesDataFolder(results,1),"_data_sig"))	WAVE Izero_sig 			= $(ReplaceString("_data",GetWavesDataFolder(Izero_sig,1),"_data_sig"))		WAVE DataMinusBG_sig 		= $(GetWavesDataFolder(DataMinusBG,1)+"_sig")	WAVE DataMultiplyBG_sig 	= $(GetWavesDataFolder(DataMultiplyBG,1)+"_sig")	WAVE DataDivideBG_sig 		= $(GetWavesDataFolder(DataDivideBG,1)+"_sig")EndFunction AxisShiftIzeroPolyMaskBG(w,yw,xw) : FitFunc		Wave w, xw, yw		NVAR gMaskFlag 			= gMaskFlag	NVAR gMinFitPt			= gMinFitPt	NVAR gMaxFitPt			= gMaxFitPt	NVAR gLogFlag				= gLogFlag		String IzeroFolderName	= "root:SPECTRA:Fitting:IzeroFit"	WAVE PyCoefs				= $(IzeroFolderName+":PyCoefs")	WAVE AxisOrig			= $(IzeroFolderName+":AxisOrig")	WAVE DataOrig			= $(IzeroFolderName+":DataOrig")	WAVE DataShift			= $(IzeroFolderName+":DataShift")	WAVE MaskOrig			= $(IzeroFolderName+":MaskOrig")		Variable i, j=0		// This should be identical to the yw wave. 	WAVE AxisMasked			= $(IzeroFolderName+":AxisMasked")	WAVE DataMasked			= $(IzeroFolderName+":DataMasked")			for (i=gMinFitPt;i<=gMaxFitPt;i+=1)		if (MaskOrig[i] == 1)			AxisMasked[j] = AxisOrig[i]			DataMasked[j] = DataOrig[i]			j+=1		endif	endfor		// INPUT = Data in Fitting:Izero folder, which is the copy of the Plotting:Graph#:Originals 	if (abs(w[0]) > 0)		ShiftDataOnAxis(AxisOrig,DataShift,DataOrig,w[0],gLogFlag)	endif		PyCoefs[]=w[p+2]	j=0	for (i=gMinFitPt;i<=gMaxFitPt;i+=1)		if (MaskOrig[i] == 1)			yw[j] = w[1]*DataShift[i] + PolynomialPart(PyCoefs,xw[j])			j+=1		endif	endfor	if (gLogFlag == 1)		yw[] = log(yw[p])	endifEndFunction AxisShiftIzeroPolyBG(w,yw,xw) : FitFunc		Wave w, xw, yw		NVAR gMaskFlag 			= gMaskFlag	NVAR gMinFitPt			= gMinFitPt	NVAR gLogFlag				= gLogFlag		String IzeroFolderName	= "root:SPECTRA:Fitting:IzeroFit"	WAVE PyCoefs				= $(IzeroFolderName+":PyCoefs")	WAVE AxisOrig			= $(IzeroFolderName+":AxisOrig")	WAVE DataOrig			= $(IzeroFolderName+":DataOrig")	WAVE DataShift			= $(IzeroFolderName+":DataShift")		// INPUT = Data in Fitting:Izero folder, which is the copy of the Plotting:Graph#:Originals 	if (abs(w[0]) > 0)		ShiftDataOnAxis(AxisOrig,DataShift,DataOrig,w[0],gLogFlag)	endif		PyCoefs[]=w[p+2]		if (gLogFlag == 1)		yw[] = log(w[1]*DataShift[gMinFitPt + p] + PolynomialPart(PyCoefs,xw[p]))	else		yw[] = w[1]*DataShift[gMinFitPt + p] + PolynomialPart(PyCoefs,xw[p])	endifEnd// Rigid shift of the axis, then replaces the data back onto the original energy axis - faster than explicitly interpolating. // The plotted data is shifted relative to the axis and data stored in the Originals folder in the Plot folder. // The axes are never changed, only the data on the axis. // 	If an Alignment is performed AND the offset is allowed to vary, the data in the Originals folder is updated ...// ... the AxisOffset reset to zero, but the total axis offset updated. Function ShiftDataOnAxis(refaxis,shiftdata,dataorig,Shift,LogFlag)	Wave refaxis, shiftdata, dataorig	Variable Shift, LogFlag		String IzeroFolderName = "root:SPECTRA:Fitting:IzeroFit"	String AxisShiftName	= IzeroFolderName + ":AxisShift"		Duplicate /O/D refaxis, $AxisShiftName	WAVE AxisShift		= $AxisShiftName		AxisShift = refaxis - Shift		shiftdata[] = dataorig[BinarySearchInterp(refaxis, AxisShift[p])]End// Manual shifting data along the axis. Slightly different DataFolder usage to the fitting above. Function SetAxisOffset(ctrlName,varNum,varStr,varName) : SetVariableControl	String ctrlName	Variable varNum	String varStr	String varName		String PlotName = WinName(0,65)	String PlotFolderName 	= "root:SPECTRA:Plotting:"+PlotName	String CopyFolderName 	= "root:SPECTRA:Plotting:"+PlotName+":DataDuplicates"	Variable i, NumTraces		NVAR gAxisOffset			= $(PlotFolderName+":gAxisOffset")	SVAR gSelection1 			= $(PlotFolderName+":gSelection1")		if (cmpstr("_none_",gSelection1) == 0)		gAxisOffset = 0		return 0	elseif (abs(gAxisOffset) < 1e-10)		gAxisOffset = 0	else		gAxisOffset = varNum	endif	if (cmpstr("_all_",gSelection1) == 0)		DoAlert 1,"Shift ALL left-plotted traces?"		if (V_flag==1)			NumTraces = ItemsInList(TraceNameList(PlotName,";",1))			for (i=0;i<NumTraces;i+=1)				WAVE DataOrig = $(CopyFolderName+":"+NameOfWave(WaveRefIndexed(PlotName,i,1)))								// INPUT = Data in PlotName:DataDuplicates folder				ShiftDataOnAxis(WaveRefIndexed(PlotName,i,2),WaveRefIndexed(PlotName,i,1),DataOrig,gAxisOffset,0)			endfor		else			return 0		endif		else		WAVE DataOrig = $(CopyFolderName+":"+gSelection1)				// INPUT = Data in PlotName:DataDuplicates folder		ShiftDataOnAxis(XWaveRefFromTrace(PlotName,gSelection1),TraceNameToWaveRef(PlotName,gSelection1),DataOrig,gAxisOffset,0)	endifEnd// *************************************************************// ****		SPLINE FITTING// *************************************************************Function SplineFit(axis,data,mask,FitMin,FitMax,POrder,CsrRangeFlag,UseMaskFlag,IoRatioMinus1)	Wave axis,data,mask	Variable FitMin,FitMax, POrder,CsrRangeFlag,UseMaskFlag,IoRatioMinus1		Variable i, n, Npts = numpnts(data), GoodFitFlag		// Use min, max statemens for cases in which axis runs backwards. 	Variable FitMinPt	= min(AxisValueToPoint(axis, FitMin),AxisValueToPoint(axis, FitMax))	Variable FitMaxPt	= max(AxisValueToPoint(axis, FitMin),AxisValueToPoint(axis, FitMax))		Variable MinPt 	= (CsrRangeFlag == 1) ? 0 : FitMinPt	Variable MaxPt 	= (CsrRangeFlag == 1) ? Npts : FitMaxPt	Variable NInterp 	= MaxPt-MinPt+1		String OldDF = getDataFolder(1)	NewDataFolder/O/S root:SPECTRA:Fitting	NewDataFolder/O/S root:SPECTRA:Fitting:IzeroFit		KillWaves /A/Z				Variable /G gBGType				= 3				Make /O/D/N=(Npts) polynomial=NAN, DataMultiplyBG=NAN, DataMinusBG=NAN, DataDivideBG=NAN				Make /D/FREE/N=(NInterp) XSource, YSource, XDest, YDest=0		XDest[] 	= axis[MinPt+p]						if ((waveexists(mask)==1) && (UseMaskFlag==1))			WaveStats /Q/M=1/R=[FitMinPt,FitMaxPt] mask			if (V_avg == 0)				DoAlert 0, "The entire fit range is masked!"				SetDataFolder $(OldDF)				return -1			endif						for (i=MinPt;i<=MaxPt;i+=1)				if (mask[i] == 1)					XSource[n] 	= axis[i]					YSource[n] 	= data[i]					n += 1				endif			endfor						ReDimension /N=(n) XSource, YSource						Print "\r *** Fitting a spline function to",ReplaceString("_data",NameOfWave(data),""),"from",axis[FitMinPt],"to",axis[FitMaxPt],"using a mask."		else			XSource 	= axis[MinPt+p]			YSource 	= data[MinPt+p]			Print "\r *** Fitting a spline function to",ReplaceString("_data",NameOfWave(data),""),"from",axis[FitMinPt],"to",axis[FitMaxPt],"."		endif				Interpolate2 /T=3/I=3/F=(POrder/100)/X=XDest /Y=YDest XSource, YSource					polynomial[MinPt,MaxPt] 		= YDest[p-MinPt]				DataMinusBG[MinPt,MaxPt]		= data[p] - polynomial[p]		DataMultiplyBG[MinPt,MaxPt]	= data[p] * polynomial[p]				if (IoRatioMinus1 == 1)			DataDivideBG[MinPt,MaxPt]	= data[p]/polynomial[p] - 1		else			DataDivideBG[MinPt,MaxPt]	= data[p]/polynomial[p]		endif				GoodFitFlag = 1			SetDataFolder $(OldDF)		return GoodFitFlagEnd// *************************************************************// ****		POLYNOMIAL FITTING// *************************************************************Function ExponentialFit(axis,data,mask,FitMin,FitMax,POrder,CsrRangeFlag,UseMaskFlag,IoRatioMinus1,PolyZeroFlag)	Wave axis,data,mask	Variable FitMin,FitMax,POrder,CsrRangeFlag,UseMaskFlag,IoRatioMinus1,PolyZeroFlag		Variable Npts = numpnts(data), GoodFitFlag		// Use min, max statements for cases in which axis runs backwards. 	Variable FitMinPt	= min(AxisValueToPoint(axis, FitMin),AxisValueToPoint(axis, FitMax))	Variable FitMaxPt	= max(AxisValueToPoint(axis, FitMin),AxisValueToPoint(axis, FitMax))		Variable MinPt 	= (CsrRangeFlag == 1) ? 0 : FitMinPt	Variable MaxPt 	= (CsrRangeFlag == 1) ? Npts : FitMaxPt		String HoldString="", OldDF = getDataFolder(1)	NewDataFolder/O/S root:SPECTRA:Fitting	NewDataFolder/O/S root:SPECTRA:Fitting:IzeroFit		KillWaves /A/Z				// The start of the exponential decay axis is at FitMin		Variable /G gX0 		= axis[FitMinPt]				// A maximum of 2 decays		Variable nExps 	= max(0,min(2,POrder))				Make /D/O/N=(1+2*nExps) ExpCoefs		ExpCoefs[1,] = 0.1				if (PolyZeroFlag==1)			ExpCoefs[0] = 0			// Enforce zero offset			HoldString 	= "1"		else			ExpCoefs[0] = data[FitMaxPt]			HoldString 	= "0"		endif		HoldString 	= HoldString + MakeStringOfChars(nExps*2,"0")				Make /O/D/N=(Npts) polynomial=NAN, DataMultiplyBG=NAN, DataMinusBG=NAN, DataDivideBG=NAN				Variable V_FitOptions=4					// Hide the Fit display update window		Variable V_FitQuitReason, V_FitError	// Allow diagnosis of fit failure						if ((waveexists(mask)==1) && (UseMaskFlag==1))			WaveStats /Q/M=1/R=[FitMinPt,FitMaxPt] mask			if (V_avg == 0)				DoAlert 0, "The entire fit range is masked!"				SetDataFolder $(OldDF)				return -1			endif						Print "\r *** Fitting exponential decay to",ReplaceString("_data",NameOfWave(data),""),"from",axis[FitMinPt],"to",axis[FitMaxPt],"using a mask."			FuncFit /Q/H=HoldString ExponentialPart,  ExpCoefs,  data(FitMinPt,FitMaxPt) /X=axis /M=mask		else			Print "\r *** Fitting exponential decay to",ReplaceString("_data",NameOfWave(data),""),"from",axis[FitMinPt],"to",axis[FitMaxPt],"."			FuncFit /Q/H=HoldString ExponentialPart,  ExpCoefs,  data(FitMinPt,FitMaxPt) /X=axis		endif				Print FittingReport(V_FitError,V_FitQuitReason,V_chisq,0,1)		if (V_FitError==0)		//		if ((V_FitQuitReason == 0) && (V_FitQuitReason == 0))						polynomial[MinPt,MaxPt] 	= ExponentialPart(ExpCoefs,axis[p])						DataMinusBG[MinPt,MaxPt]		= data[p] - polynomial[p]			DataMultiplyBG[MinPt,MaxPt]	= data[p] * polynomial[p]						if (IoRatioMinus1 == 1)				DataDivideBG[MinPt,MaxPt]	= data[p]/polynomial[p] - 1			else				DataDivideBG[MinPt,MaxPt]	= data[p]/polynomial[p]			endif						GoodFitFlag = 1		else			GoodFitFlag = 0		endif	SetDataFolder $(OldDF)		return GoodFitFlagEnd//		dblexp_XOffset	Double exponential:// 	y = K0+K1*exp(-(x-x0)/K2)+K3*exp(-(x-x0)/K4)// 1 or 2 xponential decays from the axis zero with an offsetFunction ExponentialPart(fc,x): FitFunc	Wave fc	Variable x		NVAR gX0 			= gX0		Variable NExps 	= numpnts(fc)-1		if (numpnts(fc) == 1)		return fc[0]	else		if (NExps==1)			return fc[0] + fc[1]*exp(-(x-gX0)/fc[2])		else			return fc[0] + fc[1]*exp(-(x-gX0)/fc[2]) + fc[3]*exp(-(x-gX0)/fc[4])		endif	endifEnd// *************************************************************// ****		POLYNOMIAL FITTING// *************************************************************Function PolynomialFit(axis,data,mask,FitMin,FitMax,POrder,CsrRangeFlag,UseMaskFlag,IoRatioMinus1,PolyZeroFlag)	Wave axis,data,mask	Variable FitMin,FitMax,POrder,CsrRangeFlag,UseMaskFlag,IoRatioMinus1,PolyZeroFlag		Variable Npts = numpnts(data), GoodFitFlag		// Use min, max statemens for cases in which axis runs backwards. 	Variable FitMinPt	= min(AxisValueToPoint(axis, FitMin),AxisValueToPoint(axis, FitMax))	Variable FitMaxPt	= max(AxisValueToPoint(axis, FitMin),AxisValueToPoint(axis, FitMax))		Variable MinPt 	= (CsrRangeFlag == 1) ? 0 : FitMinPt	Variable MaxPt 	= (CsrRangeFlag == 1) ? Npts : FitMaxPt		String OldDF = getDataFolder(1)	NewDataFolder/O/S root:SPECTRA:Fitting	NewDataFolder/O/S root:SPECTRA:Fitting:IzeroFit		KillWaves /A/Z				Variable /G gBGType				= 1		// All the data, Izero and mask waves need to be on the Izero axis. 		Variable /G gPolyCenterOffset	= 0		if (PolyZeroFlag==0)			gPolyCenterOffset	= mean(axis,FitMinPt,FitMaxPt)		endif					Make /D/O/N=(1+POrder) PyCoefs		PyCoefs[0] = data[FitMinPt]		PyCoefs[1,] = 1				Make /O/D/N=(Npts) polynomial=NAN, DataMultiplyBG=NAN, DataMinusBG=NAN, DataDivideBG=NAN				Variable V_FitOptions=4					// Hide the Fit display update window		Variable V_FitQuitReason, V_FitError	// Allow diagnosis of fit failure						if ((waveexists(mask)==1) && (UseMaskFlag==1))			WaveStats /Q/M=1/R=[FitMinPt,FitMaxPt] mask			if (V_avg == 0)				DoAlert 0, "The entire fit range is masked!"				SetDataFolder $(OldDF)				return -1			endif						Print "\r *** Fitting polynomial background to",ReplaceString("_data",NameOfWave(data),""),"from",axis[FitMinPt],"to",axis[FitMaxPt],"using a mask."			FuncFit /Q PolynomialPart,  PyCoefs,  data(FitMinPt,FitMaxPt) /X=axis /M=mask		else			Print "\r *** Fitting polynomial background to",ReplaceString("_data",NameOfWave(data),""),"from",axis[FitMinPt],"to",axis[FitMaxPt],"."			FuncFit PolynomialPart,  PyCoefs,  data(FitMinPt,FitMaxPt) /X=axis		endif				Print FittingReport(V_FitError,V_FitQuitReason,V_chisq,0,1)				if ((V_FitQuitReason == 0) && (V_FitQuitReason == 0))						polynomial[MinPt,MaxPt] 	= PolynomialPart(PyCoefs,axis[p])						DataMinusBG[MinPt,MaxPt]		= data[p] - polynomial[p]			DataMultiplyBG[MinPt,MaxPt]	= data[p] * polynomial[p]						if (IoRatioMinus1 == 1)				DataDivideBG[MinPt,MaxPt]	= data[p]/polynomial[p] - 1			else				DataDivideBG[MinPt,MaxPt]	= data[p]/polynomial[p]			endif						GoodFitFlag = 1		else			GoodFitFlag = 0		endif	SetDataFolder $(OldDF)		return GoodFitFlagEnd// A polynomial that is centered around gPolyCenterOffset, not zeroFunction PolynomialPart(polycoefs,x): FitFunc	Wave polycoefs	Variable x		NVAR gPolyCenterOffset=gPolyCenterOffset		if (numpnts(polycoefs) == 1)		return polycoefs[0]	else		return poly(polycoefs,x-gPolyCenterOffset)	endifEnd// *************************************************************// ****		Displaying the results of the Normalization// *************************************************************Function ShowNormalizationResults(PlotName,PlotFolderName,Data,Izero,BGType,PolyOrder)	String PlotName,PlotFolderName, Data, Izero	Variable BGType, PolyOrder		String IzeroFolderName = "root:SPECTRA:Fitting:IzeroFit"	String CopyFolderName = "root:SPECTRA:Plotting:"+PlotName+":DataDuplicates"		NVAR gPlotIoDiff			= $(PlotFolderName+":gPlotIoDiff")	NVAR gPlotIoMult			= $(PlotFolderName+":gPlotIoMult")	NVAR gPlotIoRatio			= $(PlotFolderName+":gPlotIoRatio")	NVAR gCsrRangeFlag		= $(PlotFolderName+":gCsrRangeFlag")		WAVE polynomial			= $(IzeroFolderName+":polynomial")	WAVE DataMinusBG		= $(IzeroFolderName+":DataMinusBG")	WAVE DataMultiplyBG		= $(IzeroFolderName+":DataMultiplyBG")	WAVE DataDivideBG		= $(IzeroFolderName+":DataDivideBG")		WAVE Axis 	= XWaveRefFromTrace(PlotName,Data)	WAVE Axis2 	= XWaveRefFromTrace(PlotName,Izero)		RemoveFromGraph /Z/W=$PlotName DataMinusBG, DataDivideBG, polynomial		if ((WaveExists(polynomial) == 1) && (PolyOrder > 0))		WaveStats /M=1/Q polynomial		if (V_npnts > 0)			if (BGType == 1 || BGType==3 || BGType==4)				// If we are only fitting a background polynomial, display this on the regular left axis. 				AppendToGraph /W=$PlotName polynomial vs Axis			elseif(BGType == 2)				AppendToGraph /W=$PlotName  polynomial vs Axis2//				AppendToGraph /R/W=$PlotName  polynomial vs Axis2//				ModifyGraph/W=$PlotName  axThick(right)=2, noLabel(right)=2			endif			ModifyGraph /W=$PlotName lstyle(polynomial)=1,rgb(polynomial)=(26214,26214,26214)		endif	endif		if (gPlotIoDiff == 1)		DisplayMathResults(PlotName,"Minus",Axis,DataMinusBG)	endif	if (gPlotIoMult == 1)		DisplayMathResults(PlotName,"Multiply",Axis,DataMultiplyBG)	endif	if (gPlotIoRatio == 1)		DisplayMathResults(PlotName,"Divide",Axis,DataDivideBG)	endif		UpdatePlottedTraceLists(PlotName)EndFunction DisplayMathResults(PlotName,MathOp,axis,result)	String PlotName, MathOp	Wave axis,result		Variable XAxMin, XAxMax, YAxMin, YAxMax, LogFlag		Variable Cmplx1 = WaveType(result) & 0x01		String AxesInfo, AxisName = "Io"+MathOp+"Axis"		CheckDisplayed /W=$PlotName result	if (V_flag == 0)		AppendToGraph /W=$PlotName/L=$AxisName result vs axis		ModifyGraph /W=$PlotName rgb($NameOfWave(result))=(0,0,0), lsize($NameOfWave(result))=2				ModifyGraph /W=$PlotName axThick($AxisName)=0, noLabel($AxisName)=2		ModifyGraph /W=$PlotName zero($AxisName)=4,zeroThick($AxisName)=1		if (Cmplx1)			ModifyGraph cmplxMode($NameOfWave(result))=1		endif	endif		AxesInfo 	= PlotAxesInfo(PlotName)	LogFlag 	= NumberByKey("log(x)", AxisInfo(PlotName,"left"),"=")	ModifyGraph /W=$PlotName log($AxisName)=LogFlag	SetAxis /A=2 $AxisNameEnd// *************************************************************// ****		Adopting the results of the normalization into memory// *************************************************************Function KeepIzeroResults(PlotName,PlotFolderName,Selection1,Selection2,BGType)	String PlotName,PlotFolderName,Selection1,Selection2	Variable BGType		NVAR gPlotIoDiff			= $(PlotFolderName+":gPlotIoDiff")	NVAR gPlotIoMult			= $(PlotFolderName+":gPlotIoMult")	NVAR gPlotIoRatio			= $(PlotFolderName+":gPlotIoRatio")		String Suffix, AxisName, AxisFolder, ResultsName, ResultsErrorsName, ResultsFolder, NewName, TypeStr		AxisName			= NameOfWave(XWaveRefFromTrace(PlotName,Selection1))	AxisFolder			= GetWavesDataFolder(TraceNameToWaveRef(PlotName,Selection1),1)			Variable CmplxResult = WaveType(TraceNameToWaveRef(PlotName,Selection1)) & 0x01	ResultsFolder 		= "root:SPECTRA:Fitting:IzeroFit"	if (BGType == 0)		Suffix = ""	elseif (BGType==1)		Suffix = "Py"	else		Suffix = "Io"	endif		If (gPlotIoDiff == 1)		ResultsName 			= "DataMinusBG"		ResultsErrorsName 	= "DataMinusBG_sig"		WAVE Results	= $(ResultsFolder+":"+ResultsName)				// *!*!*! Temporary naming change. //		NewName 	= AnyNameFromDataName(Selection1,Suffix+"D_data")		NewName 	= ReplaceString("_AVG",Selection1,"_DIFF",1,1)		//		Note /K Results,"Name="+NewName+"\r"//		AdoptAxisAndDataFromMemory(AxisName,"null",AxisFolder,ResultsName,ResultsErrorsName,ResultsFolder,NewName,"",0,0,1)	endif		If (gPlotIoRatio == 1)		ResultsName 			= "DataDivideBG"		ResultsErrorsName 	= "DataDivideBG_sig"		WAVE Results	= $(ResultsFolder+":"+ResultsName)				NewName = AnyNameFromDataName(Selection1,Suffix+"R_data")//		Note /K Results,"Name="+NewName+"\r"//		AdoptAxisAndDataFromMemory(AxisName,"null",AxisFolder,ResultsName,ResultsErrorsName,ResultsFolder,NewName,"",0,0,1)	endif		If (gPlotIoMult == 1)		ResultsName 			= "DataMultiplyBG"		ResultsErrorsName 	= "DataMultiplyBG_sig"		WAVE Results	= $(ResultsFolder+":"+ResultsName)				NewName = AnyNameFromDataName(Selection1,Suffix+"M_data")	endif		if (CmplxResult)		TypeStr = "DataType=Complex;"	else		TypeStr = "DataType=Real;"	endif		String OldNote = note(Results)		Note /K Results,"Name="+NewName+";"+TypeStr+"\r"	Note Results, OldNote	AdoptAxisAndDataFromMemory(AxisName,"null",AxisFolder,ResultsName,ResultsErrorsName,ResultsFolder,NewName,"",0,0,1)End