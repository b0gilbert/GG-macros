#pragma rtGlobals=1		// Use modern global access method.// Zachariah et al. The molar Gibbs energy of hydration (DG) of the ions indicates strongest hydration for Na+ and the weakest for Cs+;// namely, ref. [21] gives DG for Na+: 385 kJ/mol, K+: 305 kJ/mol and Cs+: 245 kJ/mol// 2021-08//	Variable F_Si2O 		= 0							// The fraction of hydroxylated surface sites that have a higher strength. //	Variable F_SiO_m		= 0//	Variable F_SiOH_n		= 0//	Variable F_SiONa_n	= 0//	Variable F_SiOH2_p	= 0// conditions for Na//Constant BetaShift = 0//Constant PrideScaling = 0.9//Constant Elastic0 = 3e9//Constant Elastic1 = 3e6// conditions for Li//Constant BetaShift = -0.6//Constant PrideScaling = 1.7Constant Elastic0 = 3e9Constant Elastic1 = 4e6Constant Elastic2 = 2e6Function BetaLayerRemovalSteve2(RoughFlag)	Variable RoughFlag	// The Pride10 PRESSURE curve for diffuse-layer removal 	WAVE Diffuse_Calc_nm		= root:SPECTRA:Data:Load1:Pride10_10mMpH5p5_axis	WAVE Diffuse_Calc_Pa 		= root:SPECTRA:Data:Load1:Pride10_10mMpH5p5_data		Duplicate /O/D Diffuse_Calc_nm, Diffuse_nm	Duplicate /O/D Diffuse_Calc_Pa, Diffuse_Pa		Diffuse_nm += BetaShift	Diffuse_Pa *= PrideScaling		Variable Two_Beta 		= Diffuse_nm[0] 		// The width of the gap when the 2 beta layers are in contact	Variable Diffuse_Pmax	= Diffuse_Pa[0]		// The pressure (Pa) at beta layer contact	Variable Gamma1 		= 0.9375			// The fraction of >SiO-H with higher strength. 	Variable Gamma2 		= (1-Gamma1)		// The fraction of >SiO-Na with lower strength. 		Variable eps1 = 0.2, eps2 = 0.2	Variable H1 = Elastic1, H2 = Elastic2			Variable Ho 	= 2e5						// Hard wall	Variable Dw = 0.275, Da = 0.15	// Diameters of water and ion. 			Variable NDPts = DimSize(Diffuse_Pa,0), NBPts=2001	Variable wStart =Two_Beta, wStop = 0.05	Variable wStep = (wStop - wStart)/(NBPts - 1)		// In Steve's convention, Tau_xx = -P	Make /O/D/N=(NBPts) Beta2_nm, Beta2_Tau1=0, Beta2_Tau2=0	Beta2_nm[] = wStop - p*wStep		// Add the Diffuse layer pressure offset	Beta2_Tau1[NBPts-1] 	= -Diffuse_Pmax	Beta2_Tau2[NBPts-1] 	= -Diffuse_Pmax		Make /O/D/N=(NBPts) Beta2_Pa1=0, Beta2_Pa2=0, Beta2_PNet, Beta2_PRgh, Beta2_PTot, Beta2_vdW, Beta2_H1=0, Beta2_H2=0	Beta2_H1[NBPts-1] 	= H1	Beta2_H2[NBPts-1] 	= H2			// Calculate the Pressure-Separation curve for Patches 1 		BetaLayerMechanicalForce2(Beta2_nm,Beta2_Tau1,Beta2_H1,Beta2_vdW,eps1)		BetaLayerMechanicalForce2(Beta2_nm,Beta2_Tau2,Beta2_H2,Beta2_vdW,eps2)		Beta2_Pa1 	= -1 * Beta2_Tau1	Beta2_Pa2 	= -1 * Beta2_Tau2	Beta2_PNet = Gamma1*Beta2_Pa1 + Gamma2*Beta2_Pa2		// Add roughness	Make /O/D/N=(NBPts) roughness	SetScale /P x, (wStop), (-wStep), roughness, Beta2_PRgh	Beta2_PNet[0] += Elastic0	Beta2_PRgh = Beta2_PNet	Variable rms = 0.06	roughness[] = gauss(pnt2x(roughness,p),abs(wStop - wStart - 0.1)/2,rms)	Convolve /A roughness, Beta2_PRgh	Variable A1 = areaXY(Beta2_nm,Beta2_PNet), A2 = areaXY(Beta2_nm,Beta2_PRgh)	Beta2_PRgh *= (A1/A2)		// Join the Beta and Diffuse layer curves in one	Make /O/D/N=(NBPts+NDPts) Full_nm, Full_Pa, Full_vdW	Full_nm[0,NBPts-1] 	= Beta2_nm[p]	Full_nm[NBPts,] 		= Diffuse_nm[p-NBPts]	Full_Pa[NBPts,] 		= Diffuse_Pa[p-NBPts]		if (RoughFlag)		Full_Pa[0,NBPts-1] 	= Beta2_PRgh[p]	else		Full_Pa[0,NBPts-1] 	= Beta2_PNet[p]	endif		// Calculate the van der Waals (twice for plotting)	Variable Ah = 2e6/(6*pi)//	BetaLayerVanDerWaalsForce(Beta2_nm,Beta2_vdW,Ah)	BetaLayerVanDerWaalsForce(Full_nm,Full_vdW,Ah)	// The User Wave for plotting vs SFA data in F/R (mN/m)	WAVE PressureAxis 	= root:SPECTRA:Data:Load7:Pressure_Steve_axis	WAVE PressureData 	= root:SPECTRA:Data:Load7:Pressure_Steve_data	Redimension /N=(NBPts+NDPts) PressureAxis, PressureData		PressureAxis = Full_nm	PressureData = Full_Pa //+ Full_vdW		ConvertPtoFR(PressureAxis,PressureData)EndFunction BetaRough(Beta2_nm,Beta2_PRgh,roughness)	Wave Beta2_nm, Beta2_PRgh, roughness		End// The Hamaker constant, A, in zJ = 10-21JFunction BetaLayerVanDerWaalsForce(ww,PP,Ah)	Wave ww, PP	Variable Ah		PP[] 	= -Ah/ww[p]^3End// This module needs to return a Pressure-Distance curve// Using Piotr's codeFunction BetaLayerMechanicalForce2(ww,Tau,HH,vdW,eps)	Wave ww, Tau, HH, vdW	Variable eps		Variable i, n, NPts=DimSize(ww,0)	Variable Dw	= 0.275, Da = 0.15	Variable Hamaker 	= 21e-20/(6*pi)	Variable Hnm 		= Hamaker/1e-27		Variable Brkt, Relax, RScale = 0.5		// Calculate how many water layers //	Variable wn = ceil(ww[NPts-1]/Dw) * Dw	Variable wn = ww[NPts-1]		Variable HHn 	 = HH[NPts-1]	Variable Taun 	 = Tau[NPts-1]		for (i=NPts-2;i>-1;i-=1)		Variable w 	= ww[i]						if (((wn-w) >Dw) && (1))			n +=1 //			wn 	= ceil(w/Dw) * Dw			// If w < Dw, then this logarithm becomes NaN as 1 - (Dw/w) < 0//			Taun 	= Tau[i+1] - HHn * Ln(1 - (Dw/w))						if (w < Dw)				Brkt = 1 - (Dw/wn)				Relax = 1.3* HHn * Ln(1 - (Dw/wn))			else				Brkt = 1 - (Dw/w)				Relax = HHn * Ln(1 - (Dw/w))			endif						Taun 	= Tau[i+1] - RScale * Relax						wn 	= w						HHn 	= HHn * (1 + eps)			 // print " 	-- removed water layer",n-1,". wn is",wn," and the Ln-bracket is",Brkt		endif				HH[i] 		= HHn				Tau[i] 	= Taun + HHn * Ln(w/wn)				vdW[i] 	= Hnm * ( 1/w^3 - 1/wn^3 )			endforEndFunction BreakPointe()	print "here" 		EndConstant BetaShift = 0Constant PrideScaling = 0.9Function BetaLayerRemovalBen(NoBetaFlag)	Variable NoBetaFlag	// The Pride10 PRESSURE curve for diffuse-layer removal 	WAVE Diffuse_Calc_nm		= root:SPECTRA:Data:Load1:Pride10_10mMpH5p5_axis	WAVE Diffuse_Calc_Pa 		= root:SPECTRA:Data:Load1:Pride10_10mMpH5p5_data		Duplicate /O/D Diffuse_Calc_nm, Diffuse_nm	Duplicate /O/D Diffuse_Calc_Pa, Diffuse_Pa		Diffuse_nm += BetaShift	Diffuse_Pa *= PrideScaling		Variable Two_Beta 		= Diffuse_nm[0] 		// The width of the gap when the 2 beta layers are in contact	Variable Diffuse_Pmax	= Diffuse_Pa[0]		// The pressure (Pa) at beta layer contact		Variable NDPts = DimSize(Diffuse_Pa,0), NBPts=20001	Variable wStart =Two_Beta, wStop = 0.05	Variable wStep = (wStop - wStart)/(NBPts - 1)		Make /O/D/N=(NBPts) Beta_nm, Beta_Pa, Beta_BB, Beta_H2O, Beta_Rho, Beta_FR	Beta_nm[] = wStop - p*wStep		Make /O/D/N=(NBPts) Beta_KK54=0, Beta_KK43=0, Beta_KK32=0, Beta_KK21=0, Beta_KK10=0, SiteH2O_5=0, SiteH2O_4=0, SiteH2O_3=0, SiteH2O_2=0, SiteH2O_1=0, SiteH2O_0=0	Variable nm3toL = 1e-24, nm2tom2 = 1e18	Variable cH2O, cNa, cSilanol	BetaLayerConcentrations(Two_Beta,cH2O,cNa,cSilanol)	Variable SiteMolarity = (cSilanol/cAvogadro)/(Two_Beta*nm2tom2*nm3toL)		Beta_H2O[NBPts-1] 		= cH2O			// The number of water molecules in the layer per square meter at the start. This will go down with dehydration. 	Beta_Rho[NBPts-1] 		= 0.997048 	// g/cm3 at 0.1 MPa and 25C	Beta_BB[NBPts-1] 		= 1e8				// 	Beta_Pa[NBPts-1] 			= Diffuse_Pmax				// 		//	SiteH2O_2[NBPts-1] 		= SiteMolarity	// I	SiteH2O_2[NBPts-1] 		= SiteMolarity	// Is this right? //	SiteH2O_3[NBPts-1] 		= cSilanol	// Is this right? 		if (NoBetaFlag)		Beta_Pa = Diffuse_Pmax	else		// Calculate the Pressure-Separation curve		BetaLayerChemicalForce(Beta_nm,Beta_Pa,Beta_BB,Beta_H2O,Beta_Rho)		Beta_FR = Beta_Pa		ConvertPtoFR(Beta_nm,Beta_FR)	endif		// Join the Beta and Diffuse layer curves in one	Make /O/D/N=(NBPts+NDPts) Full_nm, Full_Pa, Full_vdW	Full_nm[0,NBPts-1] 	= Beta_nm[p]	Full_nm[NBPts,] 		= Diffuse_nm[p-NBPts]	Full_Pa[0,NBPts-1] 	= Beta_Pa[p]	Full_Pa[NBPts,] 		= Diffuse_Pa[p-NBPts]		// Subtract the van der Waals 	Variable Ah = 2e6/(6*pi)	BetaLayerVanDerWaalsForce(Full_nm,Full_vdW,Ah)	// The User Wave for plotting vs SFA data in F/R (mN/m)	WAVE PressureAxis 	= root:SPECTRA:Data:Load3:Pressure_Rough_axis	WAVE PressureData 	= root:SPECTRA:Data:Load3:Pressure_Rough_data	Redimension /N=(NBPts+NDPts) PressureAxis, PressureData		PressureAxis = Full_nm	PressureData = Full_Pa		ConvertPtoFR(PressureAxis,PressureData)End// Values for Pressure Oscillations//Constant ChemStoich1=5//Constant ChemStoich0=0.5//Constant ChemRxnScale = 1// Values for SilicaConstant ChemStoich1=5		// Stiochiometry of Surface DehydrationConstant ChemStoich0=1		// Stochiometry of Cation DehydrationConstant ChemRxnScale = 1		Constant ChemBModScale = 10	// Reduction in water Bulk Modulus// Return a Pressure-Distance curveFunction BetaLayerChemicalForce(ww,PP,BB,H2O, Rho)	Wave ww, PP, BB, H2O, Rho		Variable Stoich1=ChemStoich1, Stoich0=ChemStoich0	Variable DG54 = 2000 	// J/mol	Variable DG43 = 2000 	// J/mol	Variable DG32 = 2000 		Variable DG21 = 23000 		// 	Variable DG10 = 230000 		// 				WAVE SiteH2O_5 = root:SiteH2O_5	WAVE SiteH2O_4 = root:SiteH2O_4	WAVE SiteH2O_3 = root:SiteH2O_3	WAVE SiteH2O_2 = root:SiteH2O_2	WAVE SiteH2O_1 = root:SiteH2O_1	WAVE SiteH2O_0 = root:SiteH2O_0	WAVE KK54 = root:Beta_KK54	WAVE KK43 = root:Beta_KK43	WAVE KK32 = root:Beta_KK32	WAVE KK21 = root:Beta_KK21	WAVE KK10 = root:Beta_KK10			Variable i, j, NPTs=DimSize(ww,0)		Variable BBRatio, BBStiff, BBWeak	Variable DPc, DPh54 = 0, DPh43=0, DPh32=0, DPh21=0, DPh10=0			// Integrate from 2-beta.	BB[NPts-1] = BulkModulusFromRho(Rho[NPts-1])		//Starting conditions//	SiteH2O_5[NBPts-1] 		= SiteMolarity			for (i=NPts-2;i>-1;i-=1)				H2O[i] = H2O[i+1]		SiteH2O_5[i] = SiteH2O_5[i+1]		SiteH2O_4[i] = SiteH2O_4[i+1]		SiteH2O_3[i] = SiteH2O_3[i+1]		SiteH2O_2[i] = SiteH2O_2[i+1]		SiteH2O_1[i] = SiteH2O_1[i+1]		SiteH2O_0[i] = SiteH2O_0[i+1]				// The incremental decrease in separation		Variable Dw = ww[i] - ww[i+1]				// Change in pressure due to compression of the beta layer		DPc 	= BB[i+1] * (abs(Dw)/ww[i])				DPh54 = DehydrationReaction(KK54,H2O,SiteH2O_5,SiteH2O_4,i,PP[i+1],DG54,Stoich1)				DPh43 = DehydrationReaction(KK43,H2O,SiteH2O_4,SiteH2O_3,i,PP[i+1],DG43,Stoich1)				DPh32 = DehydrationReaction(KK32,H2O,SiteH2O_3,SiteH2O_2,i,PP[i+1],DG32,Stoich1)				DPh21 = DehydrationReaction(KK21,H2O,SiteH2O_2,SiteH2O_1,i,PP[i+1],DG21,Stoich1)			//	DPh10 = DehydrationReaction(KK10,H2O,SiteH2O_1,SiteH2O_0,i,PP[i+1],DG10,Stoich1)		DPh10 = CationDehydration(KK10,H2O,SiteH2O_1,SiteH2O_0,i,PP[i+1],DG10,Stoich0)		// New density and bulk modulus		Rho[i] = Rho[i+1] * (ww[i+1]/ww[i]) * (H2O[i]/H2O[i+1])		if (1)			BB[i] = BulkModulusFromRho(Rho[i])		else			BBRatio 	= SiteH2O_1[i]/SiteH2O_5[i]			BBWeak 	= BulkModulusFromRho(Rho[i])			BBStiff 	= BulkModulusFromRhoWithW(Rho[i],ww[i])			BB[i] 		= BBRatio * BBStiff + (1-BBRatio) * BBWeak		endif				// Total pressure change		PP[i] = PP[i+1] + DPc - DPh43 - DPh32 - DPh21 - DPh10			endforEndFunction BulkModulusFromRhoWithW(Rho,delta)	Variable Rho,delta		variable B = -1.2286e+10 + 1.4528e+10 * Rho	return B/700	//	return (1/(delta-0.035)^1) * (B/1000000)EndFunction BulkModulusFromRho(Rho)	Variable Rho		variable B = -1.2286e+10 + 1.4528e+10 * Rho		return B/ChemBModScaleEndFunction CationDehydration(KK,H2O,SiteH2O_XX,SiteH2O_X,ii,PP,DG,H2OStoich)	Wave KK, H2O, SiteH2O_XX, SiteH2O_X	Variable ii, PP, DG, H2OStoich		//*****************	Variable RxnScale = ChemRxnScale 	Variable thick = 1.258	Variable TempC 	= 25	Variable TempK 	= 273+TempC	Variable KPre 		= -1/(cR*TempK)	Variable Vh2o		= 18.048e-6	// m3/mol	// Need to convert from Site Molarity to Number Density 		// Change in the equilibrium constant due to pressure	KK[ii] 	= min(1e30, exp(KPre * (DG - RxnScale*H2OStoich*PP*Vh2o)))		// Change in reaction quotient	Variable DN 	= KK[ii] * SiteH2O_XX[ii]	DN 			= min(SiteH2O_XX[ii], DN)		// Change in water content due to dehydration	// Should the effective conentrations of the silanol groups be varied?? 	Variable dH2O 	= MolarityToSurfaceDensity(thick,H2OStoich*DN)	H2O[ii] 			= H2O[ii] - dH2O		// Change in the pressure due to dehydration 	Variable DPh 	= PP * (dH2O/H2O[ii+1])		// Change in SIte speciation due to  dehydration step	SiteH2O_XX[ii] 	= SiteH2O_XX[ii] - DN	SiteH2O_X[ii] 	= SiteH2O_X[ii] + DN	return DPhEndFunction DehydrationReaction(KK,H2O,SiteH2O_XX,SiteH2O_X,ii,PP,DG,H2OStoich)	Wave KK, H2O, SiteH2O_XX, SiteH2O_X	Variable ii, PP, DG, H2OStoich		//*****************	Variable RxnScale = 1	Variable thick 		= 1.258	Variable TempC 	= 25	Variable TempK 	= 273+TempC	Variable KPre 		= -1/(cR*TempK)	Variable Vh2o		= 18.048e-6	// m3/mol	// Need to convert from Site Molarity to Number Density 		// Change in the equilibrium constant due to pressure	KK[ii] 	= min(1e30, exp(KPre * (DG - RxnScale*H2OStoich*PP*Vh2o)))		// Change in reaction quotient	Variable DN 	= KK[ii] * SiteH2O_XX[ii]	DN 				= min(SiteH2O_XX[ii], DN)		// Change in water content due to dehydration	// Should the effective concentrations of the silanol groups be varied?? 	Variable dH2O 	= MolarityToSurfaceDensity(thick,H2OStoich*DN)	H2O[ii] 			= H2O[ii] - dH2O		// Change in the pressure due to dehydration 	Variable DPh 	= PP * (dH2O/H2O[ii+1])		// Change in Site speciation due to dehydration step	SiteH2O_XX[ii] 	= SiteH2O_XX[ii] - DN	SiteH2O_X[ii] 	= SiteH2O_X[ii] + DN	return DPhEnd// Combined nm3toL = 1e-24 and nm2tom2 = 1e18Function SurfaceDensityToMolarity(thick,density)	Variable thick,density		Variable nm2what = 1e-6	return density/(cAvogadro*thick*nm2what)EndFunction MolarityToSurfaceDensity(thick,molarity)	Variable thick,molarity		Variable nm2what = 1e-6	return molarity*(cAvogadro*thick*nm2what)EndFunction ConcTest()	Variable cH2O, cNa, cSilanol, Thickness=1.25	BetaLayerConcentrations(Thickness,cH2O,cNa,cSilanol)EndFunction BetaLayerConcentrations(Thickness,cH2O,cNa,cSilanol)	Variable Thickness, &cH2O, &cNa, &cSilanol		Variable nm2tom2 		= 1e18	Variable nm3toL			= 1e-24	Variable MolarVolH2O 	= 18.048e21 // nm3/mol	Variable SiteDensity 		= 4 		// per nm3	Variable RNa					= 0.15 	// Radius of a Na ion, nm	Variable vNa, vGap, vH2O, pH, cH		// Sum of σβ + Qβ + Qγ is due to Na+ sorption = 	// pH 5.5: Sum = 0.04330 + 0.00728 + 0.00150 = 0.05208 C/m2	pH 		= 5.5	cNa 		= 2 * 0.05208 * cCoulomb	// in ions per square meter	cH 		= 16.55 * cNa	// ratio [SiOH] / [surface Na+ ] =   16.55   SiOH    dominates		// pH 10: Sum = 0.38474 + 0.01342 + 0.00276 = 0.40092 C/m2	//	cNa 		= 2 * 0.40092 * cCoulomb	// in ions per square meter	// ratio [SiOH] / [surface Na+ ] =   0.864   SiOxNa+ dominates		vNa 		= (4/3)*pi*(RNa^3)			// Water volume excluded by a single ion	vGap 		= Thickness * nm2tom2		// Volume of the gap in nm3	vH2O		= vGap - (cNa * vNa)			// Volume of water, which is the gap minus the ion-excluded volume		// Calculate the number of water molecules per m2 in the gap	cH2O 		= cAvogadro * vH2O/18.048e21			// about 30 x 10^18 water molecules per m2 in a 0.9-nm gap. 		// For a check, calculate the number of silanols 	cSilanol = 2 * SiteDensity * nm2tom2 							//  around 8 x 10^18	print " 	*** Beta layer is",Thickness,"nm this and one square meter has a volume of",vGap,"nm3 or",vGap*nm3toL,"L."	print " 				H2O number in the gap is",cH2O," /m2 with excluded water molecules",cAvogadro * (cNa * vNa)/18.048e21,"/m2"	print " 				Silanol surface density (2-sides) is",cSilanol,"/m2 and concentration is",(cSilanol/cAvogadro)/(vGap*nm3toL),"M"	print " 				Na surface density is",cNa,"/m2 and concentration is",(cNa/cAvogadro)/(vGap*nm3toL),"M"	print " 				Proton surface density is",cH,"/m2 and concentration is",(cH/cAvogadro)/(vGap*nm3toL),"M"EndFunction BetaLayerRemovalSteve()	Variable StrongFraction 		= 0.9375							// The fraction of hydroxylated surface sites that have a higher strength. 	Variable WeakFraction 		= (1-StrongFraction)		// The fraction of hydroxylated surface sites that have a higher strength. 		Variable epsilon 				= 0.2	Variable Ho 						= 2e8		// Hard wall	Variable Hs 						= 6e6		// Modulus around 2 GPa	Variable Hw 						= 6e6		// Modulus around 2 GPa	Variable PStart 					= 0 		// 	Variable POffset 				= 4 		// Value in F/R (mN/m)	Variable XStart =1.9, XStop = 0.05		Variable i, Temp=298, NPts=20001	Variable KPre = -1/(cR*(273+Temp))	Variable nm2tom2 	= 1e18		Make /O/D/N=(NPts) Separation, PressureHW, PressureW, PressureS, PressureNet, PressureRough, PressurePlusvdW, P_betaS, P_betaW, P_vdW, ModulusW, ModulusS	Variable XStep = (XStop - XStart)/(NPts - 1)	Separation[] = XStart + p*XStep							P_betaS[0] = PStart		ModulusS[0] = Hs	//	BetaLayerMechanicalForce(Separation,P_betaS,ModulusS,epsilon,NPTs,0)		PressureNet = StrongFraction * P_betaS 				P_betaW[0] = PStart		ModulusW[0] = Hw	//	BetaLayerMechanicalForce(Separation,P_betaW,ModulusW,epsilon,NPTs,0)		PressureNet += WeakFraction * P_betaW 						// Convolve with a roughness 	PressureRough = PressureNet	Make /O/D/N=(NPts) roughness	SetScale /P x, (XStart), (XStep), roughness, PressureRough	Variable rms = 0.04	roughness = gauss(pnt2x(roughness,p),abs(XStop - XStart)/2,rms)	roughness /= 600/rms	Convolve /A roughness, PressureRough		// 	PressurePlusvdW = PressureRough		// Subtract the van der Waals 	Variable Ah = 2e6/(6*pi)	BetaLayerVanDerWaalsForce(Separation,P_vdW,Ah)//	PressurePlusvdW += P_vdW	WAVE PressureAxis =   root:SPECTRA:Data:Load3:Pressure_Rough_axis	WAVE PressureData =   root:SPECTRA:Data:Load3:Pressure_Rough_data		PressureAxis = Separation	PressureData = PressurePlusvdW	Reverse PressureAxis, PressureData		ConvertPtoFR(PressureAxis,PressureData)		// Add a pressure offset	PressureData += POffsetEndFunction ConvertPtoFR(ForceAxis,ForceRadius)	Wave ForceAxis,ForceRadius		ForceAxis *=-1	Reverse ForceAxis, ForceRadius	Variable offset = ForceAxis[0]	ForceAxis -= offset		Integrate /METH=1 ForceRadius /X=ForceAxis		ForceAxis *=-1	Reverse ForceAxis, ForceRadius	ForceAxis -= offset		// Convert from axis in nm to m	ForceRadius /= 1e9	// Convert to F/R in mN/m	ForceRadius *= 2*pi*1000EndWindow PressureRoughPlot() : Graph	PauseUpdate; Silent 1		// building window...	Display /W=(1137,70,1882,583) Pressure_Rough vs Separation as "Rough and Smooth Pressure"	AppendToGraph/R PressureNet vs Separation	ModifyGraph mirror(bottom)=2	ModifyGraph fSize=26	ModifyGraph axThick=2	Label bottom "Separation (nm)"	SetAxis/A/R bottom	Cursor/P A PressureNet 17828;Cursor/P B Pressure_Rough 18064	ShowInfo	Legend/C/N=text0/J/F=0/B=1/A=MC/X=-3.76/Y=6.80 "\\s(Pressure_Rough) Pressure_Rough\r\\s(PressureNet) PressureNet"EndMacroFunction HydrationPressure(AdoptFlag)	Variable AdoptFlag	Variable Temp 	= 25		//˚C	Variable DG1 	= 10000	// J/mol	Variable DG2 	= 30000000	// J/mol	Variable DNh2O1 = 1	Variable DNh2O2 = 1	Variable H1Scale = 1	Variable H2Scale = 1	Variable Vh2o	= 18.048e-6	// m3/mol	Vh2o *=10 	Variable SiteDensity		= 4 // sites per nm2	Variable i, NPts=20001, PStart=000, XStart=1.9, XStop=0.05	Variable XStep = (XStop - XStart)/(NPts - 1)	Variable KPre = -1/(cR*(273+Temp))	Variable nm2tom2 	= 1e18		Make /O/D/N=(NPts) Separation, Pressure, Density, H2O, NaH2O_2, NaH2O_1=0, NaH2O_0=0, KK1, KK2, BulkModulus	SetScale /P x (XStart), (XStep), "nm", Pressure, Separation, Density, H2O, NaH2O_2, NaH2O_1,NaH2O_0, BulkModulus		Make /O/N=(NPts) xPStepC, xPStep1, xPStep2, xH2OtoNa	SetScale /P x (XStart), (XStep), "nm", xPStepC, xPStep1, xPStep2, xH2OtoNa	Separation[] = pnt2x(Separation,p)	Pressure[0] = PStart	BulkModulus = 2.1e9	// GPa	Density[0] = 1/1.002961 // g/cm3 at 0.1 MPa and 25C	KK1[0] = 0		Variable cH2O, cNa//	BetaLayerConcentrations(XStart,SiteDensity,cH2O,cNa)	H2O[0] 			= cH2O		// The number of 'free' and 'bound' water molecules in the layer at the start. This will go down with dehydration. 	NaH2O_2[0] 	= cNa			// The number of fully-hydrated charge-balancing Na ions on both sides at the start. 	xH2OtoNa[0] 	= cH2O/cNa		for (i=1;i<NPts;i+=1)			// Change in pressure due to compression of the beta layer		Variable DPc 	= BulkModulus[i-1] * (abs(XStep)/Separation[i])		Variable Pc 		= Pressure[i-1] + DPc		xPStepC[i] = DPc				// 	--------			First Dehydration 		---------		// Change in the equilibrium constant due to pressure from compression		KK1[i] 	= min(1e30, exp(KPre * (DG1 - H1Scale*Pc*Vh2o)))				// Change in the number of water molecules per m2 due to first dehydration step		Variable DN1 	= min(NaH2O_2[i-1],DNh2O1 * KK1[i] * NaH2O_2[i-1])				// Change in the pressure due to first dehydration step				Variable DPh1 	= Pressure[i-1] * (DN1 / H2O[i-1])		xPStep1[i] = DPh1				// Loss of waters and change in sodium speciation due to first dehydration step		NaH2O_2[i] 	= NaH2O_2[i-1] - (DN1/DNh2O1) 		NaH2O_1[i] 	= NaH2O_1[i-1] + (DN1/DNh2O1) 				// 	--------			Second Dehydration 		---------		KK2[i] 	= min(1e30, exp(KPre * (DG2 - Pc*Vh2o)))		//		Variable DN2 	= (KK2[i] * NaH2O_1[i-1])		Variable DN2 	= min(NaH2O_1[i-1], DNh2O2 * KK2[i] * NaH2O_1[i-1])				Variable DPh2 	= Pressure[i-1] * (DN2 / H2O[i-1])		xPStep2[i] = DPh2				NaH2O_1[i] 	= NaH2O_1[i] - (DN2/DNh2O2)		NaH2O_0[i] 	= NaH2O_0[i-1] + (DN2/DNh2O2)						// Overall change in the numbers of water		H2O[i] 			= H2O[i-1] - DN1 - DN2		xH2OtoNa[i] 	= H2O[i]/cNa				// New density and bulk modulus		Density[i] = Density[i-1] * (Separation[i-1]/Separation[i]) * (H2O[i]/H2O[i-1])				BulkModulus[i] = BulkModulusFromRho(Density[i])				// Total pressure change		Pressure[i] = Pressure[i-1] + DPc - DPh1 - DPh2					endfor		if (AdoptFlag)		Duplicate /O Separation, AdoptSeparation		Duplicate /O Pressure, AdoptPressure		Reverse AdoptSeparation, AdoptPressure		String NewDataAndFolder 	= AdoptAxisAndDataFromMemory("AdoptSeparation","","root","AdoptPressure","","root","Pressure","",1,0,0)	endifEndWindow Graph3() : Graph	PauseUpdate; Silent 1		// building window...	Display /W=(117,56,862,569) NaH2O_0,NaH2O_1,NaH2O_2 vs Separation as "Pressure vs Na Species"	AppendToGraph/R Pressure vs Separation	ModifyGraph lSize(NaH2O_0)=3,lSize(NaH2O_1)=3,lSize(NaH2O_2)=3,lSize(Pressure)=2	ModifyGraph rgb(NaH2O_0)=(1,16019,65535,32768),rgb(NaH2O_1)=(2,39321,1,26214),rgb(NaH2O_2)=(0,43690,65535,26214)	ModifyGraph mirror(bottom)=2	ModifyGraph fSize=26	ModifyGraph lblMargin(right)=31	ModifyGraph axOffset(left)=-2.35714	ModifyGraph axThick=2	Label left "Na Species (ions / m2)"	Label bottom "Separation (nm)"	Label right "\\Z26Pressure (Pa)"	SetAxis/A/R bottom	Legend/C/N=text0/J/F=0/B=1/A=MC/X=28.93/Y=14.56 "\\Z26\\s(NaH2O_2) Na (H2O)2\r\\s(NaH2O_1) Na (H2O)\r\\s(NaH2O_0) Na"	TextBox/C/N=text1/F=0/B=1/A=MC/X=-15.29/Y=-32.52 "\\Z26\\s(Pressure) Pressure"EndMacro// 	2014-08// 	Calculations of the interactions between n clay platelets// From Grodinsky, Chapter 4. // Repulsive force between two plates at constant surface potential, Vo, in V// Separation, D, in nm// Force in N m-2 ???Function edlPlatePlate_Grod(Vo,D,CIConc,z,RelEps,T)	Variable Vo,D,CIConc,z,RelEps,T		Variable Dsi 		= D*1e-9	Variable Epsilon 	= RelEps * cPermittivity		Variable Kap 			= Kappa(CIConc,z,RelEps,T)	Variable InvDebye 	= ReciprocalDebyeLength(CIConc,z,RelEps,T)	Variable coshVal 	= cosh(0.5*Kap*Dsi)		print "Kappa",1e9/Kap,"nm"	print "Debye length",1e9/InvDebye,"nm"	print "cosh term",coshVal		Variable Force 	= 0.5*Epsilon*Kap^2*Vo^2*(1/coshVal)^2		return ForceEnd// Check for errors// Counterion concentration in molarity (= moles/liter)Function Kappa(CIConc,z,RelEps,T)	Variable CIConc,z,RelEps,T		Variable Conc 	= CIConc * 1000	Variable Eps 	= RelEps*cPermittivity		Variable RelKap 	= sqrt((Eps*cR*T)/(2*z^2*cFaraday^2*Conc))		return 1/RelKapEndFunction UUUU(UU)	Variable UU		return (UU*cBoltzmann*298)/cElectronEnd	// From Ohshima// Model 3, linear superposition// Electrolyte concentration, CIConc, in MFunction edlPlatePlate_LSA(Vo,D,CIConc,z,RelEps,T)	Variable Vo,D,CIConc,z,RelEps,T		Variable Dm	 	= D/1e9	Variable Nm3 		= MolarityToNumberDensity(CIConc) 	// input in moles per liter; output in ions per m3	Variable Ncm3 	= Nm3/1e6	Variable PreFac 	= 64*Ncm3*cBoltzmann*T	Variable uu 		= z*cElectron*Vo/(2*cBoltzmann*T)		Variable DebyeHukel 	= sqrt((2*Nm3*z^2*cElectron^2)/(RelEps*cPermittivity*cBoltzmann*T))		Variable Pressure 	= PreFac*tanh(uu)^2*exp(-DebyeHukel*Dm)		return PressureEnd// From Zhang// Distance, D, in nanometers// Clay sheet thickness, tt, in nm// The Hamaker constant, A, in zJ = 10-21JFunction vdWPlatePlate_Zhang(A,D,tt)	Variable A, D, tt		Variable Scale 	= 1e27	Variable PreFac 	= (1e-21*A)/(6*pi)		Variable Force 	= PreFac * (1/D^3 - 2/(D+tt)^3 + 1/(D+2*tt)^3) * Scale		return Force	 End// From Zhang// Distance, D, in nanometers// Clay sheet thickness, tt, in nm// The Hamaker constant, A, in zJ = 10-21JFunction edlPlatePlate_Zhang(Vo,D,CIConc,z,RelEps,T)	Variable Vo,D,CIConc,z,RelEps,T		Variable u 			= z*cElectron*Vo/(cBoltzmann*T)	Variable Nm3 		= MolarityToNumberDensity(CIConc) 	// input in moles per liter; output in ions per m3	Variable Ncm3 	= Nm3/1e6	Variable PreFac 	= 2*Ncm3*cBoltzmann*T		return PreFac*(cosh(u) - 1)End	// -----------------------------------------------------------------------------// 	Tadmor, J. Phys.: Condens. Matter 13, 2001)// Distance, D, in nanometers// Clay sheet thickness, t, in nm// The Hamaker constant, A, in zJ = 10-21J// Pressure in N m-2, presumablyFunction EvdWPlanes(D,t,A)	Variable D, t, A		Variable PreFactor = -1*(1e-21*A)/(12*pi)		Variable Dsi 	= 1e-9 * D	Variable tsi 	= 1e-9 * t		return PreFactor * (1/Dsi^2  +  1/(Dsi+2*tsi)^2 -  2/(Dsi+tsi)^2)End// Distance, D, in nanometers// Clay sheet thickness, t, in nm// The Hamaker constant, A, in zJ = 10-21J// Pressure in N m-2, presumablyFunction Pvdw(D,t,A)	Variable D, t, A		Variable PreFactor = (1e-21*A)/(6*pi)		Variable Dsi 	= 1e-9 * D	Variable tsi 	= 1e-9 * t		return PreFactor * (1/Dsi^2  +  1/(Dsi+2*tsi)^2 +  2/(Dsi+tsi)^2)End// Distance, D, in nanometers// Surface Potential, P, in V// Pressure in N m-2, presumablyFunction Pel(Conc, Pot, D)	Variable Conc, Pot, D		Variable Dsi 			= 1e-9 * D		Variable No 			= MolarityToNumberDensity(Conc)	// ions /m3			// 6 * 10+25	Variable kT 			= 298 * cBoltzmann											// 4 * 10-21	Variable DebyeSqr 	= (2*No*cElectron^2)/(80*cPermittivity*kT)	Variable Debye 		= sqrt(DebyeSqr)		print "Debye",Debye		Variable Debye2 		= 1/(ReciprocalDebyeLength(Conc,1,80,298))		print "Debye2",Debye2	Variable Prefactor 	= 64*No*kT		Variable TanhPot 		= tanh((cElectron*Pot)/kt)		return Prefactor * TanhPot^2 * exp(-Debye2*Dsi)End// UNITS:// Distance in nanometers// The Hamaker constant in zJ = 10-21J// Energies in eV	// *!*!*! This Macro below must be made into a function *!*!*!		//Macro MakeDVLOPotential(DVLOName,Hamaker, SurfaceCharge, Temperature, CIConc, Radius)//	Variable /G gHamaker, gSurfaceCharge, gTemperature, gCIConc, gRadius//	String /G gDVLOName//	////	String DVLOName = gDVLOName//	Prompt DVLOName, "Name the DVLO potential data."//	Variable Hamaker = gHamaker//	Prompt Hamaker, "The Hamaker constant [zJ]"//	Variable SurfaceCharge = gSurfaceCharge//	Prompt SurfaceCharge, "The surface charge density [C/m2]"//	Variable Temperature = gTemperature//	Prompt Temperature, "The Temperature [K]"//	Variable CIConc = gCIConc//	Prompt CIConc, "The counterion concentration [M]"//	Variable Radius = gRadius//	Prompt Radius, "The particle radius [nm]"//	PauseUpdate; Silent 1//	//	gDVLOName 		= DVLOName//	gHamaker 			= Hamaker//	gSurfaceCharge 	= SurfaceCharge//	gTemperature 		= Temperature//	gCIConc 			= CIConc//	gRadius 			= Radius//	//	Print " *** Calculating the DLVO Potential curves for particles in an aqueous solution of symmetrical monovalent electrolyte at",Temperature,"K. "//	Print " 			Spherical particle radius	=",Radius ,"nm. "//	Print " 			Surface charge density 		=",SurfaceCharge,"mC/m^2"//	Print " 			Counterion concentration 	=",CIConc*1000,"mM"//	Print " 			Hamaker constant 			=",Hamaker,"zJ"//	Print " 			...........	Bjerrum length 	=",(1e9) * BjerrumLength(78, Temperature),"nm"//	Print " 			...........	Debye length 		=",(1e9)/ReciprocalDebyeLength(CIConc,1,78,Temperature),"nm"//	Print " 			...........	Surface potential 	=",GrahameSurfacePotential(SurfaceCharge,CIConc,1,78,Temperature),"V"//	//	Make /O/D/N=3001 DVLO_Distance, DVLO_Energy, DVLO_Coulomb, DVLO_Waals//	DVLO_Distance[] = 0.02*x //	//	DVLO_Waals[] 	= DVLOWaals(Hamaker,Radius,DVLO_Distance[p],Temperature)//	//	DVLO_Coulomb[] 	= DVLOCoulomb(SurfaceCharge,CIConc,Radius,DVLO_Distance[p],Temperature)//	//	DVLO_Energy 		= DVLO_Coulomb + DVLO_Waals//	//	// Now adopt the curves. //	if (ItemsInList(FunctionList("UnloadSpectrumPackage",";","")) == 0)//		Execute "LoadSpectrumAnalysisPackage()"//		DoUpdate//		Print " *** Try again!"//		return 0//	endif//	//	String cmd, AxisName, DataName, DataFolderName = ":"//	//	DataName = ReplaceString("_data",DVLOName,"") + "_data"//	AxisName = ReplaceString("_data",DVLOName,"") + "_axis"//	Duplicate /O DVLO_Energy, $DataName//	Duplicate /O DVLO_Distance, $AxisName//	AdoptLocalAxisAndData($AxisName,$DataName)//	KillWaves /Z $DataName//	//	DataName = ReplaceString("_data",DVLOName,"") + "_Cmb_data"//	Duplicate /O DVLO_Coulomb, $DataName//	AdoptLocalAxisAndData($AxisName,$DataName)//	KillWaves /Z $DataName//	//	DataName = ReplaceString("_data",DVLOName,"") + "_vdW_data"//	Duplicate /O DVLO_Waals, $DataName//	AdoptLocalAxisAndData($AxisName,$DataName)//	KillWaves /Z $AxisName, $DataName//End// 	Input: Concentration in moles per liter//	Output: Number density in number per cubic meterFunction MolarityToNumberDensity(Concentration)	Variable Concentration		Variable LiterToM3 	= 1e3		return cAvogadro * Concentration * LiterToM3End// Returns the Bjerrum length in metersFunction BjerrumLength(RelEps, T)	Variable RelEps, T		Variable LB 	= (2*cElectron)^2 / (4 * pi * RelEps*cPermittivity*cBoltzmann*T)		return LBEnd// *** Correct only for symmetric electrolytes!Function ReciprocalDebyeLength(CIConc,z,RelEps,T)	Variable CIConc		// Counterion concentration, M	Variable z				// Counterion valence	Variable RelEps		// Relative permittivity	Variable T				// Temp., in K		// Counterion density, in number per m3. 	Variable NRho = MolarityToNumberDensity(CIConc)		// Bjerrum length, in meters	Variable LB 	= BjerrumLength(RelEps, T)		// Young-Shin correction	Variable Kappa = sqrt(4 * pi * LB * 2 * NRho * z^2)		return Kappa // in units of m-1End// *** Modified for aymmetric electrolytesFunction ReciprocalDebyeLengthAS(CIConc,Z1,Z2,RelEps,T)	Variable CIConc		// Counterion concentration, M	Variable Z1, Z2				// Counterion valence	Variable RelEps		// Relative permittivity	Variable T				// Temp., in K		// Counterion density, in number per m3. 	Variable NRho = MolarityToNumberDensity(CIConc)		// Bjerrum length, in meters	Variable LB 	= BjerrumLength(RelEps, T)		// Young-Shin correction	Variable Kappa = sqrt(4 * pi * LB * 2 * NRho * Z1*Z2)		return Kappa // in units of m-1End// Uses the Grahame Eqn to convert surface charge density to surface potentialFunction GrahameSurfacePotential(sigma,CIConc,z,RelEps,T)	Variable sigma		// Surface change density in C m-2	Variable CIConc		// Counterion concentration, M	Variable z				// Counterion valence	Variable RelEps		// Relative permittivity	Variable T				// Temp., in K		Variable kT = cBoltzmann * T		CIConc	= max(0.00001,CIConc)		// Counterion density, in number per m3. 	Variable NRho = MolarityToNumberDensity(CIConc)		Variable InvSinhTerm = asinh(sigma/sqrt(8*kT*NRho*RelEps*cPermittivity))		Variable Potential = kT/(2*z*cElectron) * InvSinhTerm	//	Print " *** Potential at the surface is",Potential,"Volts"		return Potential // in units of volts = J/CEnd// Calculation of sphere-sphere interaction energies from Elimelech (3.21)Function DVLOCoulomb(Sigma,CIConc,a,h,T)	Variable Sigma,CIConc,a,h,T		Variable kT 			= cBoltzmann * T	Variable a_nm 		= a * 1e-9	// radius	Variable h_nm 		= h * 1e-9	// separation	Variable RelEpsWater	= 78			// relative permittivity of water		// Kappa = inverse Debye Length, in m-1	Variable Kappa = ReciprocalDebyeLength(CIConc,1,RelEpsWater,T)		// Find the surface potential, in volts = J/C	Variable Phi = GrahameSurfacePotential(Sigma,CIConc,1,RelEpsWater,T)		// Calculate gamma	Variable G = tanh(cElectron*Phi/(4*kT))		// *** Remove the h from 1/(h + 2a)	Variable Vc = (64 * pi) * (cPermittivity * RelEpsWater) * ((a_nm^2)/(h_nm + 2*a_nm)) * (kT/cElectron)^2 * G^2 * exp(-Kappa*h_nm)		// Return the Coulomb interaction energy in thermal units	return Vc/kTEnd	// Hamaker interactions for small sphere-sphere interactions// 	Input: 	Hamaker, in zepto-Joules. 1 zJ = 1e-21 J. Function DVLOWaals(Hamaker,a,h,T)	Variable Hamaker,a,h,T		Variable kT = cBoltzmann * T		Variable A_J = (Hamaker * 1e-21)		Variable a_nm = a * 1e-9	Variable h_nm = h * 1e-9		Variable Term1 = (h_nm^2 + 4*a_nm*h_nm)	Variable Term2 = (h_nm^2 + 4*a_nm*h_nm + 4*a_nm^2)		Variable Vw = -(A_J/6)*((2*a_nm^2)/Term1 + (2*a_nm^2)/Term2 + ln((Term1)/(Term2)))		// Return the van der Waals interaction energy in thermal units	return Vw/kTEnd// Hamaker interactions for large spheres. Function oldDVLOWaals(Hamaker,a,h,T)	Variable Hamaker,a,h,T			Variable zJ = 1e-21		Variable e = 1.602176e-19	Variable kT = 1.380650e-23 * T		Variable Vw = -(Hamaker * zJ * a)/(6*h)		return Vw/kTEnd// Calculation of sphere-sphere interaction energies from Elimelech (3.21)//Function oldDVLOCoulomb(Charge,CIConc,a,h,T)//	Variable CIConc,Charge,a,h,T//	//	MakePhysicalConstants()//	NVAR e=gElectron//	NVAR eps = gPermittivity//	NVAR kB=gBoltzmann//	NVAR NA=gAvogadro//	//	Variable kT = kB * T//	Variable RelEpsWater = 78			// relative permittivity of water//	//	// K = inverse Debye Length, in nm-1//	Variable K = ReciprocalDebyeLength(CIConc,1,RelEpsWater,T)//	//	// This expression comes from Israelachvilli (12.37)////	Variable K = sqrt(CIConc)/.304	////	// First find the local ion density associated with the surface charge//	Variable Rho_surfacepart = Charge^2/(2*RelEpsWater*eps*298*kB*NA*1000)//	//	Variable Rho_bulkpart = CIConc//	//	Variable SurfaceRho = Rho_surfacepart + Rho_bulkpart//	//	Variable RatioRho = SurfaceRho/CIConc//	//	// Calculate the surface potential//	Variable Phi = ln(RatioRho) * (kT/e)//	//	Variable Yo = (e*Phi)/kT//	////	Variable G = tanh(Yo/4)//	Variable G = tanh(e*Phi/(4*kT))//	//	// Calculate the Coulomb potential////	Variable Vc = (32 * pi * eps * a * (kT/e)^2 * G^2) * exp(-K*h)//	// Note that a is in "nm"//	Variable Vc = (64 * pi * kT * a * CIConc * (G^2/K^2) * exp(-K*h)//	//	// Return the Coulomb interaction energy in eV//	return Vc/kT//End