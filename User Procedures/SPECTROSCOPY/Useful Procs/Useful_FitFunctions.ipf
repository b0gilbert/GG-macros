#pragma rtGlobals=1		// Use modern global access method.// 	V_ChiSq/(V_npnts-numpnts(W_coef)-1)Function StopAllTimers()		Variable i, Duration	for (i=0;i<10;i+=1)		Duration = stopMSTimer(i)	endforEndFunction BreakPoint()End// ***************************************************************************// **************** 			Constructing Hold String// ***************************************************************************Function /T HoldSingleCoefficient(CoeffLegend,CoeffIdx,UberHoldFlag,NoBracketsFlag,CoeffHoldFolder,CoeffHoldName,CoeffLegendText)	Wave /T CoeffLegend	Variable CoeffIdx, UberHoldFlag, NoBracketsFlag	String CoeffHoldFolder, CoeffHoldName, CoeffLegendText		NVAR CoeffHold	= $(CheckFolderColon(CoeffHoldFolder) + CoeffHoldName)		if (NVAR_Exists(CoeffHold))		// This is an override - force a coefficient to be held		CoeffHold = (UberHoldFlag > 0) ? UberHoldFlag : CoeffHold					// This is an override - permit all brackets to be added or omitted regardless of CoeffHold		NoBracketsFlag = (NoBracketsFlag == 0) ? CoeffHold : NoBracketsFlag				if (NoBracketsFlag == 2)			CoeffLegend[CoeffIdx]= CoeffLegendText		else			CoeffLegend[CoeffIdx]= "[" + CoeffLegendText + "]"		endif				if (CoeffHold==2)			return num2str(0)		else			return num2str(1)		endif	else		// Named coefficient does not exist - must hold. But still allow brackets to be omitted		if (NoBracketsFlag == 2)			CoeffLegend[CoeffIdx]= CoeffLegendText		else			CoeffLegend[CoeffIdx]= "[" + CoeffLegendText + "]"		endif				return num2str(1)	endifEndFunction /T MakeHoldString(CoefsHold)	Wave CoefsHold	String HoldString=""	Variable i=0	do		HoldString+=num2str(CoefsHold[i])		i+=1	while(i<numpnts(CoefsHold))		return HoldStringEndFunction /T MakeHoldWave(HoldString,HoldWaveName)	String HoldString, HoldWaveName	String char	Variable i=0, NPts=strlen(HoldString)		Make /O/D/N=(NPts) $HoldWaveName /WAVE=HoldWave	HoldWave = 0		for(i=0;i<NPts;i+=1)		char = HoldString[i,i]		if (cmpstr("1",char) == 0)			HoldWave[i] = 1		endif	endforEnd// A bit complicated .... Function /T ListBoxToHoldString(selWave,col,row0,row1,nHolds)	Wave selWave	Variable col,row0,row1,nHolds		String HoldString=""	Variable i=0		for (i=row0;i<=row1;i+=1)		if (BitTest(selWave[i][col],4))			HoldString = HoldString + MakeStringOfChars(nHolds,"1")		else			HoldString = HoldString + MakeStringOfChars(nHolds,"0")		endif	endfor		return HoldStringEndFunction RecordErrors(HoldStr,IgorSigmas,UserSigmas)	String HoldStr	Wave IgorSigmas,UserSigmas		String HoldChar	Variable i, NCoeffs = numpnts(UserSigmas)	for (i=0;i<NCoeffs;i+=1)		HoldChar = HoldStr[i,i]		if (cmpstr("0",HoldChar) == 0)			UserSigmas[i] = IgorSigmas[i]		endif	endforEnd// A convolution provides rapid peak broadeningFunction GaussianConvolution(Data, Axis, Sigma,MinIdx,MaxIdx)	Wave Data, Axis	Variable Sigma, MinIdx, MaxIdx		Variable MeanIndex = MinIdx + (MaxIdx - MinIdx)/2		Make /D/O/N=3 w	w[0]=1/(sqrt(2*Sigma))	w[1]=Axis[MeanIndex]	w[2]=Sigma	// Make a single Gaussian peak in the center of the RDF range	Duplicate /D/O Axis, GaussWave		GaussWave[] = GaussianPeakBG(w,Axis[p])		Convolve  /A GaussWave, Data//	KillWaves /Z w, GaussWaveEnd// ***************************************************************************// **************** 			Process Bar// ***************************************************************************Function OpenProcBar(text)	String text		DoWindow /K Process	ProcessBar(text)	DoWindow /C ProcessEndFunction UpdateProcessBar(fraction)	Variable fraction		Variable TotLen, Len		TotLen = 359	Len = 26 + TotLen*fraction		SetDrawLayer /W=Process/K UserFront	SetDrawLayer /W=Process UserFront	SetDrawEnv /W=Process fillfgc= (65535,0,26214)	DrawRect /W=Process 26,31,Len,44		DoUpdateEndFunction CloseProcessBar()		DoWindow /K Process	KillVariables /Z gAbortFlag	KillStrings /Z gProcTextEndFunction SetAbortFlag()	NVAR gAbortFlag=gAbortFlag		Print "We should be aborting now!"	gAbortFlag=1EndFunction ProcessBar(text)	String text		NewPanel /K=1/W=(591,156,1146,224)	SetDrawLayer ProgBack	SetDrawEnv fillpat=11,fillfgc= (65535,0,52428)	DrawRect 25,30,385,45		SetDrawLayer ProgBack	SetDrawEnv fname= "Helvetica",fsize= 14,fstyle= 1,textrgb= (0,0,65535)	DrawText 31,25,text	Button AbortButton,pos={395,20},proc=SetAbortFlag,size={50,20},title="Abort"End// ***************************************************************************// **************** 			Displaying Tables of Coefficient// ***************************************************************************oikFunction DisplayCoefficientsTable(WindowName,WindowTitle,CoeffNameList,CoeffTitleList,ColWidthList, ColAlignList, x1,y1,x2,y2,BringToFront)	String WindowName, WindowTitle, CoeffNameList, CoeffTitleList,ColWidthList, ColAlignList,BringToFront	Variable x1,x2,y1,y2		Variable Width, Alignment, FixWidthFlag=0, AutoWidthFlag=0, FixAlignFlag=0, NumWaves = ItemsInList(CoeffNameList, ";")	String CoeffName, CoeffTitle		if (ItemsInList(ColWidthList, ";") == 1)		if (cmpstr(StringFromList(0, ColWidthList, ";"),"_auto_")==0)			AutoWidthFlag = 1		else			Width = str2num(StringFromList(0, ColWidthList, ";"))			FixWidthFlag = 1		endif	endif	if (ItemsInList(ColAlignList, ";") == 1)		Alignment = str2num(StringFromList(0, ColAlignList, ";"))		FixAlignFlag = 1	endif		if (numtype(NumWaves) == 0)		String TableName=WinList(WindowName,";","WIN:2")		if (strlen(TableName)==0)			CoeffName	= StringFromList(0, CoeffNameList, ";")			CoeffTitle 	= StringFromList(0, CoeffTitleList, ";")			if (exists(CoeffName)==1)				Edit /K=1/W=(x1,y1,x2,y2) $CoeffName as WindowTitle				DoWindow /C $WindowName				CheckWindowPosition(WindowName,x1,y1,x2,y2)				if (FixWidthFlag == 0)					Width = str2num(StringFromList(0, ColWidthList, ";"))				endif				if (AutoWidthFlag == 1)					Width = max(20,8*strlen(CoeffTitle))				endif								ModifyTable width($CoeffName)=Width								if (FixAlignFlag == 0)					Alignment = str2num(StringFromList(0, ColAlignList, ";"))				endif				ModifyTable alignment($CoeffName)=Alignment				ModifyTable title($CoeffName)=CoeffTitle			else				Print " *** Cannot make the table,",WindowTitle,", as the first wave,",CoeffName,",does not exist."				return 1			endif						if (NumWaves > 1)				AppendCoefficientsToTable(WindowName,CoeffNameList,CoeffTitleList,ColWidthList, ColAlignList,1,FixWidthFlag,AutoWidthFlag,FixAlignFlag)			endif		else			AppendCoefficientsToTable(WindowName,CoeffNameList,CoeffTitleList,ColWidthList, ColAlignList,0,FixWidthFlag,AutoWidthFlag,FixAlignFlag)			if (cmpstr(BringToFront,"yes")==0)				DoWindow /F $WindowName			endif		endif	else		Print " *** Some kind of problem!!"	endifEndFunction AppendCoefficientsToTable(WindowName,CoeffNameList,CoeffTitleList,ColWidthList, ColAlignList,StartIdx,FixWidthFlag,AutoWidthFlag,FixAlignFlag)	String WindowName, CoeffNameList, CoeffTitleList, ColWidthList, ColAlignList	Variable StartIdx,FixWidthFlag,AutoWidthFlag,FixAlignFlag		String CoeffName, CoeffTitle	Variable i, Width, Alignment, NumWaves = ItemsInList(CoeffNameList, ";")	for (i=StartIdx;i<NumWaves;i+=1)		CoeffName = StringFromList(i, CoeffNameList, ";")		CoeffTitle 	= StringFromList(i, CoeffTitleList, ";")		CheckDisplayed /W=$WindowName, $CoeffName		if (V_flag != 1)			if (exists(CoeffName)==1)				AppendToTable $CoeffName				if (FixWidthFlag == 0)					Width = str2num(StringFromList(0, ColWidthList, ";"))				endif				if (AutoWidthFlag == 1)					Width = max(20,8*strlen(CoeffTitle))				endif				ModifyTable width($CoeffName)=Width				if (FixAlignFlag == 0)					Alignment = str2num(StringFromList(0, ColAlignList, ";"))				endif				ModifyTable alignment($CoeffName)=Alignment				ModifyTable title($CoeffName)=CoeffTitle			else				Print " *** The wave,",CoeffName,",does not exist, and cannot be appended to the table,"			endif		endif	endfor			End//******************************************************************//******* 				EXAFS data background subtraction//******************************************************************// ** Two kinds of background subtraction:// 1. Linear fit to pre-edge region// 2. Polynomial fit to entire spectrum, including arc-tan expression for the edge jump. Function FitXASPreEdge(FitChoiceStr,XASAxis, XASData,SampleName,EdgeVal,AxisScale,KillFlag)	Wave XASAxis, XASData	String FitChoiceStr, SampleName	Variable EdgeVal, AxisScale, KillFlag	String OldDF = getDataFolder(1)	Variable BIG=2e9		if (strlen(SampleName) > 23)		Print " 		.... Error in pre-edge fit routine! The filename is too long by",23-strlen(SampleName),"characters. No pre-edge subtraction. "		return 0	endif		String XASPreEdgeName		= SampleName + "_pre"		// The pre-edge background	String XASEdgeJumpName	= SampleName + "_edg"		// The threshold edge-jump function	String XASNormName			= SampleName + "_stp"		// Data normalized to the stp		if (cmpstr("pre-edge",FitChoiceStr) ==  0)		NewDataFolder/O/S XANESPreEdge					Duplicate /D /O XASData, $XASPreEdgeName, $XASNormName			WAVE XASPreEdge	= $XASPreEdgeName			WAVE XASNorm		= $XASNormName							// Arbitrarily set the pre-edge region to end 20 eV before threshold. 			Variable LinfitMax, LinfitMax_i, i			LinfitMax=EdgeVal-(20*AxisScale)			LinfitMax_i=BinarySearchInterp(XASAxis, LinfitMax)						if (LinfitMax_i > 0)				// Now fit the  pre edge and step - fit in Energy				Make /O/D/N=2 prepolycoefs				prepolycoefs[0]=EdgeVal				prepolycoefs[1] = 0.00001								// Neglect the first 3 points				CurveFit /Q line XASData(3,LinfitMax_i) /X=XASAxis				WAVE W_coef=W_coef				prepolycoefs[0]=W_coef[0]				prepolycoefs[1]=W_coef[1]								XASPreEdge=PreEdgeLine(prepolycoefs,XASAxis)					XASNorm = XASData - XASPreEdge								Print " 		.... Removing linear pre-edge fit from spectrum",SampleName				return EndFitXASPreEdge(XASAxis,XASData,XASNorm,EdgeVal, AxisScale, 1,KillFlag,OldDF)			else				DoAlert 1, "Pre-edge fitting failed - energy units may be incorrect. Abort?"				XASNorm = XASData				return EndFitXASPreEdge(XASAxis,XASData,XASNorm,EdgeVal, AxisScale, (-1)^V_flag,KillFlag,OldDF)			endif	endif		if (cmpstr("arc-tan",FitChoiceStr) ==  0)		if (XASAxis[BIG] < EdgeVal+(10*AxisScale))			Print " *** The XANES spectra are too short for arc-tan threshold fitting."			return EndFitXASPreEdge(XASAxis,XASData,XASNorm,EdgeVal, AxisScale, -1,KillFlag,OldDF)		endif				NewDataFolder/O/S XANESEdgeJump			Variable EdgeIndex, CIdx			Variable /G PrePOrder=2, PostPOrder=2						Duplicate /D /O XASData, $XASPreEdgeName, $XASEdgeJumpName, $XASNormName			WAVE XASPreEdge		= $XASPreEdgeName			WAVE XASEdgeJump	= $XASEdgeJumpName			WAVE XASNorm		= $XASNormName						// The individual coefficient waves			Make /O/D/N=(PrePOrder) prepolycoefs			Make /O/D/N=(PostPOrder) postpolycoefs			Make /O/D/N=3 arctancoefs												// The composit fit coefficients wave			Make /O/D/N=(PrePOrder+PostPOrder+2) edgejumpcoefs			edgejumpcoefs[0]						= XASData[0]									// Estimate the offset			edgejumpcoefs[1,PrePOrder-1]		= 10^-(2+x)									// Initial pre-edge polynomial coeffs			edgejumpcoefs[PrePOrder,PrePOrder+PostPOrder-2]=0							// Initial post-edge polynomial coeffs																												// Arc-tan threshold amplitude 			edgejumpcoefs[PrePOrder+PostPOrder-1]	= XASData[BinarySearchInterp(XASAxis, EdgeVal+(50*AxisScale))] - XASData[BinarySearchInterp(XASAxis, EdgeVal-(10*AxisScale))]			edgejumpcoefs[PrePOrder+PostPOrder]		= EdgeVal								// Arc-tan threshold position				edgejumpcoefs[PrePOrder+PostPOrder+1]	= 0.5*AxisScale						// Arc-tan threshold width			//			edit /k=1 edgejumpcoefs						// The constraints appear to be very useful			Make /O/T/N=5 T_Constraints			CIdx = (PrePOrder+PostPOrder-1)			T_Constraints[0] = {"K"+num2str(CIdx)+" > 0.1"}			T_Constraints[1] = {"K"+num2str(CIdx+1)+" > "+num2str(XASAxis[0])}			T_Constraints[2] = {"K"+num2str(CIdx+1)+" < "+num2str(XASAxis[BIG])}			T_Constraints[3] = {"K"+num2str(CIdx+2)+" < 5"}			T_Constraints[4] = {"K"+num2str(CIdx+2)+" > "+num2str(0.5*AxisScale)}									// ===================================================================================			//										FITTING OCCURS ON A CONSTANT AXIS ENERGY STEP			// ===================================================================================			Duplicate /O/D XASAxis, $(NameOfWave(XASAxis)+"_vst")			// i.e., "variable step"			Duplicate /O/D XASData, $(NameOfWave(XASData)+"_vst")						// Interpolate the raw data onto a constant axis step			AxisDataToConstantStep(XASAxis,XASData,0.1*AxisScale)			WAVE csXASAxis 	= $(NameOfWave(XASAxis)+"_cstep")			// i.e., "constant step"			WAVE csXASData	= $(NameOfWave(XASData)+"_cstep")						String csXASMaskName	= ReplaceString("_data",NameOfWave(csXASData),"_mask")			Duplicate /O/D csXASAxis, $csXASMaskName			WAVE csXASMask	= $csXASMaskName						EdgeVal 		= edgejumpcoefs[PrePOrder+PostPOrder]			EdgeIndex 		= BinarySearch(csXASAxis, EdgeVal)						Variable MinWgt = 0.5			Variable Grad1	= -(MinWgt/(EdgeVal - csXASAxis[0]))			Variable Grad2	= (MinWgt/(csXASAxis[BIG] - EdgeVal))			Variable c1		= 1 - Grad1*csXASAxis[0]			Variable c2		= 1 - Grad2*csXASAxis[BIG]						csXASMask[0,EdgeIndex]		= Grad1 * csXASAxis[p] + c1			csXASMask[EdgeIndex+1,]	= Grad2 * csXASAxis[p] + c2						// FIT 1: Vary the offset, pre-peak line, and linear component of the post-peak polynomial; Fix higher order components of the post-peak polynomial; Vary the arc-tan			String HoldStr = "000" + MakeStringOfChars(PostPOrder-1,"1") + "000"			FuncFit /Q/H=HoldStr PolyAndArcTan edgejumpcoefs csXASData[3,Inf] /X=csXASAxis /W=csXASMask						// FIT 2: Inverse hold & fix selection			edgejumpcoefs[PrePOrder,PrePOrder+PostPOrder-2]=10^-(3+x-PrePOrder)			// Initial post-edge polynomial coeffs			HoldStr	= "110" + MakeStringOfChars(PostPOrder-1,"0") + "111"			FuncFit /Q/H=HoldStr PolyAndArcTan edgejumpcoefs csXASData[3,Inf] /X=csXASAxis /W=csXASMask //C=T_Constraints						// FIT 3: Vary ALL coeffs			FuncFit /Q PolyAndArcTan edgejumpcoefs csXASData[3,Inf] /X=csXASAxis /C=T_Constraints//			FuncFit /Q PolyAndArcTan edgejumpcoefs XASData[3,Inf] /X=XASAxis /C=T_Constraints			// ===================================================================================						// Update the individual coeff waves			prepolycoefs[0,PrePOrder-1]		= edgejumpcoefs[p]			postpolycoefs[0]						= edgejumpcoefs[0]			postpolycoefs[1,PostPOrder-1]		= edgejumpcoefs[p+PrePOrder-1]						EdgeVal 		= edgejumpcoefs[PrePOrder+PostPOrder]			EdgeIndex 		= BinarySearch(XASAxis, EdgeVal)						// The polynomial background			XASPreEdge[0,EdgeIndex]		= Poly(prepolycoefs,XASAxis-EdgeVal)			XASPreEdge[EdgeIndex+1,]	= Poly(postpolycoefs,XASAxis-EdgeVal)						// The normalized curve only has the polynomial background subtracted			XASNorm = XASData - XASPreEdge						// Make all the fit components for viewing			PolyAndArcTan(edgejumpcoefs,XASEdgeJump,XASAxis)	endif		// Scale to unity edge jump and finish	return EndFitXASPreEdge(XASAxis,XASData,XASNorm,EdgeVal, AxisScale, 1,KillFlag,OldDf)EndFunction EndFitXASPreEdge(XASAxis,XASData,XASNorm, EdgeVal, AxisScale, SuccessFlag,KillFlag,OldDf)	Wave XASAxis, XASData, XASNorm	Variable EdgeVal, AxisScale, SuccessFlag,KillFlag	String OldDf				Variable MeanEdgeJump, PostEdgeEnergy, PostEdgeIndex		Variable BIG=2e9				if (SuccessFlag == 1)			// Multiple the data to achieve unity edge jump			PostEdgeEnergy 		= min(EdgeVal+(50*AxisScale),XASAxis[BIG])			PostEdgeIndex 			= BinarySearch(XASAxis, PostEdgeEnergy)			MeanEdgeJump 		= mean(XASNorm,PostEdgeIndex,Inf)						XASData = XASNorm/MeanEdgeJump		endif				if (KillFlag ==1)			KillVariables /Z PrePOrder, PostPOrder			KillWaves /Z W_sigma, W_coefs		endif			SetDataFolder $(OldDF)		return SuccessFlagEndFunction PolyAndArcTan(w, ywv, xwv) : FitFunc	Wave w, ywv, xwv	NVAR gPrePO	= PrePOrder	NVAR gPostPO	= PostPOrder		WAVE prepolycoefs=prepolycoefs	prepolycoefs[0,gPrePO-1]	= w[p]		WAVE postpolycoefs=postpolycoefs	postpolycoefs[0]			= w[0]	postpolycoefs[1,gPostPO-1]	= w[p+gPrePO-1]		WAVE arctancoefs=arctancoefs	arctancoefs[]				= w[p+gPrePO+gPostPO-1]		Variable EdgeVal 	= arctancoefs[1]	Variable EdgeIndex	= BinarySearch(xwv, EdgeVal)		ywv[0,EdgeIndex] 	= Poly(prepolycoefs,xwv-EdgeVal)	ywv[EdgeIndex+1,] 	= Poly(postpolycoefs,xwv-EdgeVal)		ywv[] += ArcTanStep(arctancoefs,xwv[p])//	ywv[] += ASArcTanStep(arctancoefs,xwv[p])End// 	The definition of the width of the arc-tan step function is equal to the FWHM of the // 	peaked function that is generating by taking the first derivative of the step function. // 	This peaked function is centered at the inflection point of the arc-tan step.// 	In terms of the step function itself, this width is equivalent to the distance between the 25% and 75% intensities of the step. // 	Thus, the arc-tan step looks visually broader than the width parameter may indicate.Function ArcTanStep(w,x)	Wave w			// 0 = ampl	Variable x			// 1 = posn						// 2 = sigma		return w[0] * (0.5 + (1/pi)*atan(2*(x-w[1])/w[2]))EndFunction ASArcTanStep(w,x)	Wave w	// 0 = ampl	Variable x	// 1 = posn				// 2 = sigma pre-edge				// 3 = sigma post-edge		if (x<w[1])		return w[0] * (0.5 + (1/pi)*atan(2*(x-w[1])/w[2]))	else		return w[0] * (0.5 + (1/pi)*atan(2*(x-w[1])/w[3]))	endifEnd// This function returns an arctan step, plus ...// a 3rd order polynomial before threshold and a line post threshold. Function PolynomialAndStep(w,x)	Wave w	Variable x		NVAR gPrePO=PrePOrder	NVAR gPostPO=PostPOrder	//	w[gPrePO+gPostPO-1,] = abs(w[p])		WAVE prepolycoefs=prepolycoefs	prepolycoefs[]=w[p]		WAVE postpolycoefs=postpolycoefs	postpolycoefs[0]=w[0]	postpolycoefs[1,]=w[p+gPrePO-1]		WAVE arctancoefs=arctancoefs	arctancoefs[]=w[p+gPrePO+gPostPO-1]		Variable bg, threshold = arctancoefs[1]		if (x<threshold)		bg = Poly(prepolycoefs,x-threshold)	else		bg = Poly(postpolycoefs,x-threshold)	endif		return bg + ArcTanStep(arctancoefs,x)End// ********************************************************// ******     			A Doublet Voigt function// ********************************************************Function AddBenVoigtDoublet(ywv,xwv, GAmpl, branch, posn, split, offset, Gsigma, sigscale, Mix)	Wave ywv,xwv	Variable GAmpl, branch, posn, split, offset, Gsigma, sigscale, Mix		// Convert from my Mixing parameter (0-1) to Wavemetrics' Shape parameter (0 - Inf)	Variable Shape = ShapeFromMix(Mix)		// FIRST PEAK IN DOUBLET: 	// ---------------------------------------------------	// Calculate the Voigt width parameter	Variable Vwidth = CalculateVWidthParam(Gsigma,Shape)		// The Voigt amplitude	Variable Vampl = CalculateVAmplitude(Vwidth,GAmpl)		ywv[] += Vampl*BenVoigtAlgorithm(Vwidth*(xwv[p]+offset-posn),Mix)		// SECOND PEAK IN DOUBLET: 	// ---------------------------------------------------	Vwidth 	= CalculateVWidthParam(Gsigma*sigscale,Shape)	Vampl 	= CalculateVAmplitude(Vwidth,GAmpl*branch)		ywv[] += Vampl*BenVoigtAlgorithm(Vwidth*(xwv[p]+offset-(posn+split)),Mix)End// ********************************************************// ******     			A Convenient Voigt function. See description below. // ********************************************************Function ShapeFromMix(Mix)	Variable Mix	return tan((max(min(Mix,(0.999999)),0.000001)*pi)/2)End// The idea is to input Gaussian peak parameters, plus a mixing ratio, // and return a Voigt peak with the same width and area as the Gaussian. Function AddBenVoigtPeak(ywv,xwv, GAmpl, posn, offset, Gsigma, Mix)	Wave ywv,xwv	Variable GAmpl, posn, offset, Gsigma, Mix	// Note "G" = "Gaussian, and thus GAmpl = Gaussian amplitude, etc. 	// Note: The "offset" is a rather redundant position offset added (stupidly) for XRD patterns		// Convert from my Mixing parameter (0 - 1) to Wavemetrics' Shape parameter (0 - Inf)	Variable Shape = ShapeFromMix(Mix)		// Calculate the Voigt width parameter	Variable Vwidth = CalculateVWidthParam(Gsigma,Shape)		// The Voigt amplitude	Variable Vampl = CalculateVAmplitude(Vwidth,GAmpl)		ywv[] += Vampl*BenVoigtAlgorithm(Vwidth*(xwv[p]+offset-posn),Mix)EndFunction CalculateVWidthParam(Gsigma,Shape)	Variable Gsigma,Shape		// Calculate the Voigt "Width Parameter" by equating the total Voigt HWHM ... 	// 		HWHM_Vt	= HWHM_L/2 + sqrt[ (HWHM_L/2)^2  + HWHM_G^2]	//			... using ...	// 		HWHM_G	= sqrt(ln(2))/w2	= sqrt(ln(2))/Vwidth	// 		HWHM_L	= w4/w2				= VShape/VWidth		//... and the HWHM of the equivalent Gaussian peak specified by the input parameters: 	// 		HWHM_Gauss = sigma*sqrt(2*ln(2))		Variable beta 		= sqrt(ln(2))	Variable PreFac	= Shape/(2*Gsigma*beta)	Variable Term 	= 1 + sqrt(1 + (2*beta^2)/Shape^2)	Variable Vwidth	= PreFac * Term		return VwidthEndFunction CalculateVAmplitude(Vwidth,GAmpl)	Variable Vwidth,GAmpl		// Calculate the Voigt amplitude by equating the AREAS for the input Gauss parameters:	//		AREA_Gauss = GAmpl (for a properly normalized Gaussian distribution)	// ... and the desired Voigt peak. 	// 		AREA_Vt = (Vampl/Vwidth)*sqrt(pi)		Variable Vampl = (Vwidth * GAmpl)/sqrt(pi)		return VamplEndFunction BenVoigtAlgorithm(X,Mix)	variable X,Mix		// Convert from my Mixing parameter to Wavemetrics' Shape parameter	Variable Y = ShapeFromMix(Mix)	variable/C W,U,T= cmplx(Y,-X)	variable S =abs(X)+Y	if( S >= 15 )								//        Region I		W= T*0.5641896/(0.5+T*T)	else		if( S >= 5.5 ) 							//        Region II			U= T*T			W= T*(1.410474+U*0.5641896)/(0.75+U*(3+U))		else			if( Y >= (0.195*ABS(X)-0.176) ) 	//        Region III				W= (16.4955+T*(20.20933+T*(11.96482+T*(3.778987+T*0.5642236))))				W /= (16.4955+T*(38.82363+T*(39.27121+T*(21.69274+T*(6.699398+T)))))			else									//        Region IV				U= T*T				W= T*(36183.31-U*(3321.9905-U*(1540.787-U*(219.0313-U*(35.76683-U*(1.320522-U*0.56419))))))				W /= (32066.6-U*(24322.84-U*(9022.228-U*(2186.181-U*(364.2191-U*(61.57037-U*(1.841439-U)))))))				W= cmplx(exp(real(U))*cos(imag(U)),0)-W			endif		endif	endif	return real(W)endFunction VoigtFWHM(Coefs,x)	Wave Coefs	Variable x		return BenVoigtFWHM(Coefs[0],Coefs[2],Coefs[3],1)EndFunction BenVoigtFWHM(GAmpl,Gsigma,Mix,FWHMFlag)	Variable GAmpl,Gsigma,Mix,FWHMFlag	// Use the Wavemetrics expressions for the HWHM of the desired Voigt peak: 	// 		HWHM_Vt	= HWHM_L/2 + sqrt[ (HWHM_L/2)^2  + HWHM_G^2]		// ... and for the convoluted Gaussian and Lorentzian contributions: 	// 		HWHM_G	= sqrt(ln(2))/w2		= sqrt(ln(2))/Vwidth	// 		HWHM_L	= w4/w2				= VShape/VWidth		// Convert from my Mixing parameter to Wavemetrics' Shape parameter	Variable Shape = ShapeFromMix(Mix)		// Calculate the Voigt width parameter	Variable Vwidth = CalculateVWidthParam(Gsigma,Shape)		// The Voigt amplitude	Variable Vampl = CalculateVAmplitude(Vwidth,GAmpl)		Variable HWHMGs = sqrt(ln(2))/Vwidth	Variable HWHMLr = Shape/Vwidth	Variable HWHMVt		// Return the desired peak width	if (FWHMFlag==1)		// The total Voigt FHWM		HWHMVt = (HWHMLr/2) + sqrt(HWHMLr^2/4 + HWHMGs^2)		return HWHMVt	elseif (FWHMFlag==2)		// The FHWM of the Gaussian component		return 2*HWHMGs	elseif (FWHMFlag==3)		// The FHWM of the Lorentzian component		return 2*HWHMLr	endifEnd// ********************************************************// ***  		INTERPRETING THE COEFFICIENTS OF VOIGT PEAKS ***// ********************************************************//				From the Igor Help file//				Voigt = w[1]*voigt(w[2]*(x-w[3]),w[4])//	After the fit, you can use the returned coefficients to calculate the area (a)//  along with the half width at half max for the Gaussian (wg), Lorentzian (wl) and the Voigt (wv). //  Assuming the coefficient wave is named coef:	 //		AREA:				a	= w[1]*sqrt(pi)/w[2]////		Gaussian HWHM		wg	= sqrt(ln(2))/w[2]//		Lorentzian HWHM	wl	= w[4]/w[2] ////		Voigt HWHM		wv	= wl/2 + sqrt( wl^2/4 + wg^2)// Calculating the AMPLITUDE: //	You can calculate the amplitude of the peak via://		amp= w[1]*w[2]*exp(w[4]^2)*erfc(w[4])//	This was derived by integrating Eq. (2) or Eq. (18) in Armstrong with x=0.	// Calculating the AREA: //	The calculation of the area is based on the following//		voigt(x,y)=(y/pi) Integral[ dt*exp(-t^2)/[y^2+(x-t)^2]],//	where the integration is from -infinity to infinity.	//	The integral of the voigt function given by Armstrong is://		Integral[voigt(x,y) dx] =sqrt(pi),//	where the integration is again from -infinity to infinity.	//	Therefore, the area (neglecting the DC offset) is given by://		Integral[w[1]*voigt(w[2]*x',y) dx'] =sqrt(pi)*w[1]/w[2]// ********************************************************// ******     DATA FITTING FUNCTIONS// ********************************************************// Unlike the Igor poly function, zero-order polynomials are OKFunction BenPoly(w,x)	Wave w	Variable x		Variable POrder = numpnts(w), i, temp		temp=w[0]		if (POrder > 1)		for (i=1;i<POrder;i+=1)			temp += w[i] * x^i		endfor	endif	return tempEndFunction PreEdgeLine(w,x)	Wave w	Variable x		return w[0] + w[1]*xEndFunction GaussianPeakBG(w,x)	Wave w		// 0 = ampl	Variable x		// 1 = posn					// 2 = sigma		Variable denom = w[2] * sqrt(2*pi)		return (w[0]/denom) * exp(-(x-w[1])^2/(2*w[2]^2))EndFunction GaussianFWHM(Coefs,x)	Wave Coefs	Variable x		Variable sigma = Coefs[2]		return sigma * 2 * sqrt(2*ln(2))EndFunction LorentzianPeakBG(w,x)	Wave w		// 0 = ampl	Variable x		// 1 = posn					// 2 = sigma		Variable halfG = 0.5*w[2]		return (w[0]*halfG/pi) / ( (x-w[1])^2 + (halfG)^2 )EndFunction LorentzianFWHM(Coefs,x)	Wave Coefs	Variable x		Variable width = Coefs[2]		return widthEndFunction ASGaussianPeak(w,x)	Wave w	Variable x	// 0 = ampl	// 1 = posn	// 2 = width	// 3 = shape		return 1End// ***************************************************************************// **********************     XRF Lineshapes// ***************************************************************************// Add XRF Compton profile from // M. Van Gysel, P. Lemberge and P. Van Espen// X-Ray Spectrom. 2003; 32: 139â€“147Function ComptonErrFn(w,x)	Wave w		// 0 = ampl	Variable x	// 1 = posn					// 2 = sigma					// 3 = slope		Variable energy 		= -1*abs(x-w[1])	Variable prefactor3 	= exp(energy/(w[2]*w[3]))		Variable prefactor1 	= 2*w[2]*w[3]	Variable prefactor2 	= exp(-1/(2*w[3]^2))		Variable argument 		= energy/(w[2]*sqrt(2))  +  1/(w[3]*sqrt(2))			return w[0]*prefactor3*  (prefactor1/prefactor2) * (erf(argument)+1)	EndFunction ExpDecayOnSlope(w,x) :FitFunc	Wave w		// 0 = bg offset	Variable x	// 1 = bg slope					// 2 = exp amplitude					// 3 = exp time constant		Variable xo=0		return w[0] + w[1]*x + w[2] * exp(-(x-xo)/w[3])EndFunction StretchedExponential(w,x) :FitFunc	Wave w			// 0 = bg offset	Variable x	// 1 = scale					// 2 = width					// 3 = stretch		return w[0] + w[1]* exp( -( x/w[2] )^ w[3])End// ***************************************************************************// **********************     GENERIC FIT REPORTING ROUTINE// ***************************************************************************Function /T FittingReport(FitError,FitQuitReason,FitChiSquared,UserChiSquared,PolyFlag)	Variable FitError,FitQuitReason,FitChiSquared,UserChiSquared, PolyFlag		String UserErrorEstimate, FitReport		if (UserChiSquared==0)		UserErrorEstimate = ""	else		UserErrorEstimate = " User Chi-Squared = "+num2str(UserChiSquared) + "."	endif		if (FitError==0)		if (FitQuitReason == 0)			FitReport = "                 Fit completed normally. Igor Chi-Squared = " + num2str(FitChiSquared) + "." + UserErrorEstimate		elseif (FitQuitReason == 1)			FitReport = "                 Fit aborted once iteration limit was reached. Igor Chi-Squared = " + num2str(FitChiSquared) + "." + UserErrorEstimate		elseif (FitQuitReason == 2)			FitReport = "                 Fit aborted due to no decrease in Chi-Squared. Igor Chi-Squared = " + num2str(FitChiSquared) + "." + UserErrorEstimate		elseif (FitQuitReason == 3)			FitReport = "                 Fit aborted due to unknown reason."		endif	else		if (FitError == 1)			FitReport = "                Fit aborted due to singular matrix error."			if (PolyFlag == 1)				FitReport += " YOU MAY NEED TO REDUCE THE NUMBER OF POLYNOMIAL TERMS."			endif		elseif (FitError == 2)			FitReport = "                Fit aborted due lack of memory."		elseif (FitError == 3)			FitReport = "                Function returned invalid number (INF or NAN)."			if (PolyFlag == 1)				FitReport += " YOU MAY NEED TO REDUCE THE NUMBER OF POLYNOMIAL TERMS."			endif		elseif (FitError > 4)			FitReport = "                Fit aborted due to unknown reason. FitError = "+num2str(FitError)		endif	endif		return FitReportEnd