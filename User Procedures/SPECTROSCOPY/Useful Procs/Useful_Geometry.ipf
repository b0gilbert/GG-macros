#pragma rtGlobals=1		// Use modern global access method.STATIC Function NoZeroRoundingError1D(Data,small)	Wave Data	Variable small		Data[] = (abs(Data[p]) <  small) ? 0 : Data[p]EndFunction /T ListDistances(distance,atom_tag,atom_number,atom_occ,start,stop,maxdist)	Wave distance, atom_number, atom_occ	Wave /T atom_tag	Variable start,stop,maxdist		Variable i	String TempStr, ValueStr=""			for (i=start;i<=stop;i+=1)			if (distance[i] > maxdist)			break		endif			if (atom_occ[i] == 1)			ValueStr += " {"						sprintf TempStr, "%s", atom_tag[i]			ValueStr += PadString(TempStr,4,0x20)						sprintf TempStr, "%d ", atom_number[i]			ValueStr += PadString("n="+TempStr,6,0x20)			//			sprintf TempStr, "%d ", atom_occ[i]//			ValueStr += PadString("Occ="+TempStr,6,0x20)						sprintf TempStr, "%3.4f", distance[i]			ValueStr += PadString("d="+TempStr,6,0x20)//			ValueStr += TempStr	//		ValueStr += PadString(TempStr,10,0x20)						ValueStr += "} "		endif			endfor		return ValueStr+"\r"End// ***************************************************************************// **************** 			Generating random direction vectors// ***************************************************************************Function RandomPolarAngle()		Variable Rnd = 1 + enoise(1)	return acos(1 - Rnd)End	Function RandomEquitorialAngle()	Variable Rnd = enoise(1)	return Rnd * piEndFunction RandomUnitVector(unit)	Wave unit		Variable theta 	= RandomPolarAngle()	Variable phi 	= RandomEquitorialAngle()		unit[0] = sin(theta)*cos(phi)	unit[1] = sin(theta)*sin(phi)	unit[2] = cos(theta)EndFunction RandomCoordinateInBox(Position,BoxEdge)	Wave Position	Variable BoxEdge		Position[0] = enoise(BoxEdge/2)	Position[1] = enoise(BoxEdge/2)	Position[2] = enoise(BoxEdge/2)End// ***************************************************************************// **************** 			Mirror Transformation in X-Y plane// ***************************************************************************Function XYMirrorXYZCoords(XYZCoords,Cartesian)	Wave XYZCoords	Variable Cartesian		Variable i, NPts = DimSize(XYZCoords,0)		for (i=0;i<NPts;i+=1)		XYZCoords[i][Cartesian] *= -1	endforEnd// ***************************************************************************// **************** 			Mirror Transformation in X-Y plane// ***************************************************************************Function ParallelepipedVolume(a,b,c)	Wave a, b, c		if (WaveExists(a)*WaveExists(b)*WaveExists(c) == 0)		return 0	endif		Cross b, c	WAVE W_Cross 	= W_Cross	Variable V 			= MatrixDot(a,W_Cross)	return VEnd// ***************************************************************************// **************** 			3-element vectors// ***************************************************************************Function DistanceBetweenTwoPoints(x1,y1,z1,x2,y2,z2)	Variable x1,y1,z1,x2,y2,z2		return sqrt((x2-x1)^2 + (y2-y1)^2 + (z2-z1)^2)EndFunction NormalizeVector(Vector)	Wave Vector		Variable Const = norm(Vector)	Vector /= Const		return Const		// Better?//	MatrixOp /O Vector 	= Normalize(Vector)EndFunction AngleBetweenTwoVectors(v1,v2)	Wave v1, v2		Variable CosTheta, Norm1, Norm2		Norm1 	= norm(v1)	Norm2 	= norm(v2)		CosTheta 	= MatrixDot(v1,v2)/(Norm1*Norm2)		return acos(CosTheta)End// ***********************************************************// *********// ***********************************************************//// Returns a unit vector normal to the plane defined by 3 points. Function NormalToPlane(a,b,c,n)	Wave a,b,c,n	WAVE vectorA 		= root:StrucSims:Arrays:tVector1	WAVE vectorB		= root:StrucSims:Arrays:tVector2		vectorA = b - c	vectorB = b - a		Cross vectorA, vectorB	WAVE W_Cross		Variable Const = norm(W_Cross)	n 	= W_Cross/Const		NoZeroRoundingError1D(n,1e-10)		// Calculate d,  the shortest distance FROM the plane to the origin	Variable d = MatrixDot(n,b)		return dEndFunction PointPlaneDistance(n,pt,d)	Wave n, pt	Variable d		return MatrixDot(n,pt) - dEndFunction PointPlaneDistance2(PlaneNormal,PlaneDistance,p1,p2,p3)	Wave PlaneNormal	Variable PlaneDistance,p1,p2,p3		WAVE vectorA 		= root:StrucSims:Arrays:tVector1		vectorA[0] 	= p1	vectorA[1] 	= p2	vectorA[2] 	= p3		return PointPlaneDistance(PlaneNormal,vectorA,PlaneDistance)End// ***************************************************************************// **************** 			2D routines// ***************************************************************************Function PointLineDistance(m,c,Px,Py)	Variable m,c,Px,Py		Variable alpha 	= (Px+m*Px-m*c)/(m^2+1)		Variable distSqr 	= (alpha-Px)^2 + (m*alpha+c-Py)^2		return sqrt(distSqr)	EndFunction LineFromTwoPoints(x1,y1,x2,y2)	Variable x1,y1,x2,y2		Variable m,c		m = (y2-y1)/(x2-x1)		c = y1 - m*x1		print m, c	End// ***************************************************************************// **************** 			Translation in Cartesians// ***************************************************************************Function TranslateXYZCoords(XYZCoords,Vector,Scale)	Wave XYZCoords,Vector	Variable Scale		Variable i, NPts = DimSize(XYZCoords,0)		for (i=0;i<NPts;i+=1)		XYZCoords[i][0,2] += Scale * Vector[q]	endforEndFunction XYZCoordsToVector(N,XYZ,Vector)	Wave XYZ, Vector	Variable N		Vector[0] = XYZ[N][0]	Vector[1] = XYZ[N][1]	Vector[2] = XYZ[N][2]EndFunction CoordVectorsToXYZMatrix(NAtoms,atom_x,atom_y,atom_z,XYZ)	Variable NAtoms	Wave atom_x,atom_y,atom_z,XYZ		Variable NCols = DimSize(XYZ,1)	Redimension /N=(NAtoms,NCols) XYZ		XYZ[][0]	= atom_x[p]	XYZ[][1]	= atom_y[p]	XYZ[][2]	= atom_z[p]EndFunction XYZMatrixToCoordVectors(XYZ,atom_x,atom_y,atom_z)	Wave XYZ,atom_x,atom_y,atom_z		Variable NAtoms = DimSize(XYZ,0)	Redimension /N=(NAtoms) atom_x,atom_y,atom_z		atom_x[]	= XYZ[p][0]	atom_y[]	= XYZ[p][1]	atom_z[]	= XYZ[p][2]EndFunction PrintAllAtomCoordinates(XYZ,msg)	Wave XYZ	String msg	Variable i, NAtoms = DimSize(XYZ,0)		Print " *** Atom positions for",NameOfWave(XYZ)	for (i=0;i<NAtoms;i+=1)		PrintAtomCoordinates(XYZ,i,msg)	endforEndFunction PrintAtomCoordinates(XYZ,Num,msg)	Wave XYZ	Variable Num	String msg		String xpos="0.000", ypos="0.000", zpos="0.000"	Variable dist		if (abs(XYZ[Num][0]) > 0.000001)		xpos = num2str(XYZ[Num][0])	endif	if (abs(XYZ[Num][1]) > 0.000001)		ypos = num2str(XYZ[Num][1])	endif	if (abs(XYZ[Num][2]) > 0.000001)		zpos = num2str(XYZ[Num][2])	endif		dist = sqrt(XYZ[Num][0]^2 + XYZ[Num][1]^2 + XYZ[Num][2]^2)		Print " *** Atom",Num,"is at x="+xpos+", y="+ypos+", z="+zpos+" ... "+num2str(dist)+" from the origin ... "+msgEnd// ***************************************************************************// **************** 			Conversion between Crystallographic and Cartesian Axes// ***************************************************************************// See International Tables for Crystallography Vol. C Section 3.3Function SpaceGroupMatrices(a,b,c,alpha,betta,gama)	Variable a, b, c, alpha, betta, gama		// Deg to rad	alpha *= Pi/180	betta *= Pi/180	gama *= Pi/180		// Volume of the unit cell / (a.b.c)	Variable V = sqrt(1 - cos(alpha)^2 - cos(betta)^2 - cos(gama)^2 + 2*cos(alpha)*cos(betta)*cos(gama))		// Create the matrix M	Make/N=(4,4)/D/O SpcGpM = 0		// First row	SpcGpM[0][0] = a	SpcGpM[0][1] = b * cos(gama)	SpcGpM[0][2] = c * cos(betta)		// Second row	SpcGpM[1][0] = 0	SpcGpM[1][1] = b * sin(gama)	SpcGpM[1][2] = c * (cos(alpha) - cos(betta)*cos(gama)) / sin(gama)		// Third row	SpcGpM[2][0] = 0	SpcGpM[2][1] = 0	SpcGpM[2][2] = C * V / sin(gama)		SpcGpM[3][3]=1		Make/O/n=4 tmp	MatrixGaussJ SpcGpM,tmp		// will create M_Inverse	ReName M_Inverse, SpcGpM_Inverse	KillWaves/Z tmp,M_xEnd// ***************************************************************************// **************** 			Rotation in Cartesians. All in radians unless specified// ***************************************************************************// A composite function for rotations about a specific axis. Function RotationAboutAxis(Vector,XYZCoords,Axis,RotMatrix,InvRotMatrix,Phi)	Wave Vector,XYZCoords,Axis,RotMatrix,InvRotMatrix	Variable Phi		// Rotate systems so that the normal lies along the z-axis	MakeRotnMatricesOntoZAx(Axis, RotMatrix, InvRotMatrix)	ApplyRotationMatrixToCoordsPlus(vector,RotMatrix,XYZCoords)		// Rotate the desired amount around the z-axis	MakeZAxisRotationMatrix(RotMatrix,Phi)	ApplyRotationMatrixToCoordsPlus(vector,RotMatrix,XYZCoords)		// Now apply the inverse RotMat away from the z-axis	ApplyRotationMatrixToCoordsPlus(vector,InvRotMatrix,XYZCoords)End// *** "CoordsPlus" indicates an expanded 2D coordinate matrixFunction ApplyRotationMatrixToCoordsPlus(Vector,RotMatrix,CoordsPlus)	Wave Vector, RotMatrix,CoordsPlus		Variable i, M=DimSize(CoordsPlus,0)		for (i=0;i<M;i+=1)		Vector[0,2] = CoordsPlus[i][p]				MatrixMultiply RotMatrix, Vector		WAVE M_product=M_product				Vector = M_product				NoZeroRoundingError1D(Vector,1e-15)				CoordsPlus[i][0,2] = Vector[q]	endfor	KillWaves /Z M_productEnd// *** Coords is a Nx3 matrix of Cartesian vectors Function ApplyRotationMatrixToVector(RotMatrix,Vector)	Wave RotMatrix,Vector		MatrixMultiply RotMatrix, Vector	WAVE M_product=M_product	Vector = M_product		KillWaves /Z M_productEnd// ***************************************************************************// **************** 			Creation of Rotation Matrices// ***************************************************************************Function MakeRotnMatricesOntoZAx(Axis, RotZMatrix, InvRotZMatrix)	Wave Axis, RotZMatrix, InvRotZMatrix		WAVE SphPol		 	= root:StrucSims:Arrays:SphPol	WAVE Identity3x3 	= root:StrucSims:Arrays:Identity3x3		// The spherical polar angles	Variable theta		// The angle between the z-axis and the x-y plane	Variable phi		// The angle between the vector ("Axis") and the x-axis. 		// The Euler angles	Variable alpha	Variable betta		// Rotation about z-axis onto x-z plane	Variable gamm	// Rotation about y-axis onto z-axis. 		// If the Axis vector already lies on the z-axis, angles can be ill-defined. 	if ((abs(Axis[0]) + abs(Axis[1])) < 1e-6)		if (sign(Axis[2]) > 0)			// The vector lies on the z-axis pointing in positive direction			RotZMatrix 		= Identity3x3			InvRotZMatrix 	= Identity3x3			return 0		else			// The vector lies on the z-axis pointing in negative direction			theta 	= pi			phi 	= 0		endif	else		CartesianToSphericalPolars(Axis,SphPol)		theta 	= SphPol[1]		phi 	= SphPol[2]	endif		// NOTE: Some problems when x < 0, now corrected and checked for:	// {1,1,1}, {-1,1,1}, {1,-1,1}, {1,1,-1}, {-1,-1,1}, {-1,1,-1}, {1,-1,-1} {-1,-1,-1}	// for which both forward and reverse rotations are correct. 	// A rotation matrix onto the z-axis. 	alpha = 0	betta = sign(Axis[0]) * theta			// <--- I believe this to be correct for x > 0 and x < 0	gamm = pi-phi	MakeEulerRotationMatrix(RotZMatrix,alpha,betta,gamm)		// The inverse of a rotation matrix onto the z-axis. 	alpha = phi-pi	betta = -1 * sign(Axis[0]) * theta	// <--- Not completely tested 	gamm = 0	MakeEulerRotationMatrix(InvRotZMatrix,alpha,betta,gamm)		// Get rid of annoying round-off errors - DANGEROUS?  //	RotZMatrix[][] 		= (abs(RotZMatrix[p][q]) < 1e-10) ? 0 : RotZMatrix[p][q]//	InvRotZMatrix[][] 	= (abs(InvRotZMatrix[p][q]) < 1e-10) ? 0 : InvRotZMatrix[p][q]EndFunction MakeXYorZRotationMatrix(RotMatrix,AxisFlag,phi)	Wave RotMatrix	Variable AxisFlag,phi	if (AxisFlag == 0)		MakeXAxisRotationMatrix(RotMatrix,phi)	elseif (AxisFlag == 1)		MakeYAxisRotationMatrix(RotMatrix,phi)	elseif (AxisFlag == 2)		MakeZAxisRotationMatrix(RotMatrix,phi)	endifEndFunction /T ReturnAxisName(AxisFlag)	Variable AxisFlag		if (AxisFlag == 0)		return "x-axis"	elseif (AxisFlag == 1)		return "y-axis"	elseif (AxisFlag == 2)		return "z-axis"	endifEnd// to rotate by angle phi about the Z-axis// See: http://mathworld.wolfram.com/RotationMatrix.htmlFunction MakeZAxisRotationMatrix(RotMatrix,phi)	Wave RotMatrix	Variable phi		Variable CosPhi = cos(phi)	Variable SinPhi = sin(phi)		RotMatrix=0	RotMatrix[0][0] = cos(phi)	RotMatrix[0][1] = sin(phi)	//	RotMatrix[1][0] = -sin(phi)	RotMatrix[1][1] = cos(phi)	//	RotMatrix[2][2] = 1End// to rotate by angle phi about the X-axis// See: http://mathworld.wolfram.com/RotationMatrix.htmlFunction MakeXAxisRotationMatrix(RotMatrix,phi)	Wave RotMatrix	Variable phi		RotMatrix=0	RotMatrix[0][0] = 1	//	RotMatrix[1][1] = cos(phi)	RotMatrix[1][2] = sin(phi)	//	RotMatrix[2][1] = -sin(phi)	RotMatrix[2][2] = cos(phi)End// to rotate by angle phi about the Y-axis// See: http://mathworld.wolfram.com/RotationMatrix.htmlFunction MakeYAxisRotationMatrix(RotMatrix,phi)	Wave RotMatrix	Variable phi		RotMatrix=0	RotMatrix[0][0] = cos(phi)	RotMatrix[0][2] = -sin(phi)	//	RotMatrix[1][1] = 1	//	RotMatrix[2][0] = sin(phi)	RotMatrix[2][2] = cos(phi)EndFunction MakeEulerRotationMatrix(RotMatrix,alp,bet,gam)	Wave RotMatrix	Variable alp,bet,gam		// Taken from Messiah. 	RotMatrix[0][0] = cos(gam)*cos(bet)*cos(alp) - sin(gam)*sin(alp)	RotMatrix[0][1] = -sin(gam)*cos(bet)*cos(alp) - cos(gam)*sin(alp)	RotMatrix[0][2] = sin(bet)*cos(alp)	RotMatrix[1][0] = cos(gam)*cos(bet)*sin(alp) + sin(gam)*cos(alp)	RotMatrix[1][1] = -sin(gam)*cos(bet)*sin(alp) + cos(gam)*cos(alp)	RotMatrix[1][2] = sin(bet)*sin(alp)	RotMatrix[2][0] = -cos(gam)*sin(bet)	RotMatrix[2][1] = sin(gam)*sin(bet)	RotMatrix[2][2] = cos(bet)EndFunction AltMakeEulerRotationMatrix(RotMatrix,phi,theta,psi)	Wave RotMatrix	Variable phi,theta,psi		// Taken from Mathworld - the x-convention.  	RotMatrix[0][0] = cos(psi)*cos(phi) - cos(theta)*sin(phi)*sin(psi)	RotMatrix[0][1] = cos(psi)*sin(phi) + cos(theta)*cos(phi)*sin(psi)	RotMatrix[0][2] = sin(psi)*sin(theta)	RotMatrix[1][0] = -sin(psi)*cos(phi) - cos(theta)*sin(phi)*cos(psi)	RotMatrix[1][1] = -sin(psi)*sin(phi) + cos(theta)*cos(phi)*cos(psi)	RotMatrix[1][2] = cos(psi)*sin(theta)	RotMatrix[2][0] = sin(theta)*sin(phi)	RotMatrix[2][1] = -sin(theta)*cos(phi)	RotMatrix[2][2] = cos(theta)End	// ***************************************************************************// **************** 			Converting between Coordinate Systems. // ***************************************************************************// Converts three scalars to just the polar angle, theta, relative to the z-axis. Function CartesianToPolarAngle(x,y,z)	Variable x,y,z		return acos(z/sqrt(x^2+y^2+z^2))			// cos(theta) = z/rEnd// Converts three scalars to just the equatorial angle, phi, relative to the z-axis. Function CartesianToEquatorialAngle(x,y,z)	Variable x,y,z		// tan(phi) = y/x		if (x==0)		return pi/2	else		return atan(y/x)	endifEnd// Converts one 1x3 vector to anotherFunction CartesianToSphericalPolars(CCoords,SPCoords)	Wave CCoords,SPCoords		// r^2 = x^2+y^2+z^2	SPCoords[0] = sqrt(CCoords[0]^2+CCoords[1]^2+CCoords[2]^2)		// cos(theta) = z/r	SPCoords[1] = acos(CCoords[2]/SPCoords[0])		if (CCoords[0] == 0)		SPCoords[2] = pi/2	else		// tan(phi) = y/x		SPCoords[2] = atan(CCoords[1]/CCoords[0])	endifEnd// Converts one 1x3 vector to another// Geometry is taken from // https://math.libretexts.org/Bookshelves/Calculus/Book%3A_Calculus_(OpenStax)/12%3A_Vectors_in_Space/12.7%3A_Cylindrical_and_Spherical_CoordinatesFunction SphericalPolarsToCartesians(CCoords,SPCoords)	Wave CCoords,SPCoords	// SPCoords[0] = r	// SPCoords[1] = phi, the angle relative to z-axis	// SPCoords[2] = theta, the angle relative x-axis 		CCoords[0] 	= SPCoords[0] * sin(SPCoords[1])*cos(SPCoords[2])	CCoords[1] 	= SPCoords[0] * sin(SPCoords[1])*sin(SPCoords[2])	CCoords[2] 	= SPCoords[0] * cos(SPCoords[1])		NoZeroRoundingError1D(CCoords,0.0001)	EndFunction oldMakeRotnMatricesOntoZAx(Axis, RotZMatrix, InvRotZMatrix)	Wave Axis, RotZMatrix, InvRotZMatrix		WAVE Identity3x3 	= root:StrucSims:Arrays:Identity3x3		// The spherical polar angles	Variable theta		// The angle between the z-axis and the x-y plane	Variable phi		// The angle between the vector ("Axis") and the z-axis. 		// The Euler angles	Variable alpha	Variable betta		// Rotation about z-axis onto x-z plane	Variable gamm	// Rotation about y-axis onto z-axis. 		// If the Axis vector already lies on the z-axis, angles can be ill-defined. 	if ((abs(Axis[0]) + abs(Axis[1])) < 1e-6)		// The vector lies on the z-axis		RotZMatrix 		= Identity3x3		InvRotZMatrix 	= Identity3x3		return 0	endif		Duplicate /D/O Axis, SphPol	CartesianToSphericalPolars(Axis,SphPol)	theta 	= SphPol[1]	phi 	= SphPol[2]	KillWaves /Z SphPol		// NOTE: Some problems when x < 0, now corrected and checked for:	// {1,1,1}, {-1,1,1}, {1,-1,1}, {1,1,-1}, {-1,-1,1}, {-1,1,-1}, {1,-1,-1} {-1,-1,-1}	// for which both forward and reverse rotations are correct. 	// A rotation matrix onto the z-axis. 	alpha = 0	betta = sign(Axis[0]) * theta			// <--- I believe this to be correct for x > 0 and x < 0	gamm = pi-phi	MakeEulerRotationMatrix(RotZMatrix,alpha,betta,gamm)		// The inverse of a rotation matrix onto the z-axis. 	alpha = phi-pi	betta = -1 * sign(Axis[0]) * theta	// <--- Not completely tested 	gamm = 0	MakeEulerRotationMatrix(InvRotZMatrix,alpha,betta,gamm)		// Get rid of annoying round-off errors - DANGEROUS?  //	RotZMatrix[][] 		= (abs(RotZMatrix[p][q]) < 1e-10) ? 0 : RotZMatrix[p][q]//	InvRotZMatrix[][] 	= (abs(InvRotZMatrix[p][q]) < 1e-10) ? 0 : InvRotZMatrix[p][q]End